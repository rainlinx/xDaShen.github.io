<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java学习笔记"><meta name="keywords" content="学习笔记"><meta name="author" content="xDaShen"><meta name="copyright" content="xDaShen"><title>Java学习笔记 | xDaShen's Blog</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机的基础知识"><span class="toc-number">1.</span> <span class="toc-text">计算机的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-计算机概述-了解"><span class="toc-number">1.1.</span> <span class="toc-text">1. 计算机概述(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-键盘功能键的认识和快捷键-掌握"><span class="toc-number">1.2.</span> <span class="toc-text">2. 键盘功能键的认识和快捷键(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-常见的DOS命令-掌握"><span class="toc-number">1.3.</span> <span class="toc-text">3. 常见的DOS命令(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java语言概述-了解"><span class="toc-number">1.4.</span> <span class="toc-text">4. Java语言概述(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-JDK-JRE-JVM的作用及关系-掌握"><span class="toc-number">1.5.</span> <span class="toc-text">5. JDK,JRE,JVM的作用及关系(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-JDK的下载-安装-卸载-掌握"><span class="toc-number">1.6.</span> <span class="toc-text">6. JDK的下载,安装,卸载(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-第一个程序：HelloWorld案例-掌握"><span class="toc-number">1.7.</span> <span class="toc-text">7. 第一个程序：HelloWorld案例(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-常见的问题-掌握"><span class="toc-number">1.8.</span> <span class="toc-text">8. 常见的问题(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-path环境变量-掌握"><span class="toc-number">1.9.</span> <span class="toc-text">9. path环境变量(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-classpath环境变量-理解"><span class="toc-number">1.10.</span> <span class="toc-text">10. classpath环境变量(理解)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java语言基础"><span class="toc-number">2.</span> <span class="toc-text">Java语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-关键字-掌握"><span class="toc-number">2.1.</span> <span class="toc-text">1. 关键字(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-标识符-掌握"><span class="toc-number">2.2.</span> <span class="toc-text">2. 标识符(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-注释-掌握"><span class="toc-number">2.3.</span> <span class="toc-text">3. 注释(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-常量-掌握"><span class="toc-number">2.4.</span> <span class="toc-text">4. 常量(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-进制转换-了解"><span class="toc-number">2.5.</span> <span class="toc-text">5. 进制转换(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-变量-掌握"><span class="toc-number">2.6.</span> <span class="toc-text">6. 变量(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-数据类型-掌握"><span class="toc-number">2.7.</span> <span class="toc-text">7. 数据类型(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-数据类型转换-掌握"><span class="toc-number">2.8.</span> <span class="toc-text">8. 数据类型转换(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-运算符-掌握"><span class="toc-number">2.9.</span> <span class="toc-text">1. 运算符(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-键盘录入-掌握"><span class="toc-number">2.10.</span> <span class="toc-text">2. 键盘录入(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-流程控制语句"><span class="toc-number">2.11.</span> <span class="toc-text">3. 流程控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-if语句-掌握"><span class="toc-number">2.12.</span> <span class="toc-text">4. if语句(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-switch语句-掌握"><span class="toc-number">2.13.</span> <span class="toc-text">1. switch语句(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-循环语句-掌握"><span class="toc-number">2.14.</span> <span class="toc-text">2. 循环语句(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-控制跳转语句-掌握"><span class="toc-number">2.15.</span> <span class="toc-text">3. 控制跳转语句(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-方法-掌握"><span class="toc-number">2.16.</span> <span class="toc-text">1. 方法(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数组-掌握"><span class="toc-number">2.17.</span> <span class="toc-text">2. 数组(掌握)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java面向对象"><span class="toc-number">3.</span> <span class="toc-text">Java面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-成员变量和局部变量的区别-理解"><span class="toc-number">3.1.</span> <span class="toc-text">1. 成员变量和局部变量的区别(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-类作为形式参数的问题-理解"><span class="toc-number">3.2.</span> <span class="toc-text">2. 类作为形式参数的问题?(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-匿名对象-理解"><span class="toc-number">3.3.</span> <span class="toc-text">3. 匿名对象(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-封装-理解"><span class="toc-number">3.4.</span> <span class="toc-text">4. 封装(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-private关键字-掌握"><span class="toc-number">3.5.</span> <span class="toc-text">5. private关键字(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-this关键字-掌握"><span class="toc-number">3.6.</span> <span class="toc-text">6. this关键字(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-构造方法-掌握"><span class="toc-number">3.7.</span> <span class="toc-text">7. 构造方法(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-代码：Student-s-new-Student-做了哪些事情-理解"><span class="toc-number">3.8.</span> <span class="toc-text">8. 代码：Student s = new Student();做了哪些事情?(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-面向对象的练习题-掌握"><span class="toc-number">3.9.</span> <span class="toc-text">9. 面向对象的练习题(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-static关键字-理解"><span class="toc-number">3.10.</span> <span class="toc-text">10. static关键字(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-如何制作帮助文档-了解"><span class="toc-number">3.11.</span> <span class="toc-text">1. 如何制作帮助文档(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-通过JDK提供的API学习了Math类-掌握"><span class="toc-number">3.12.</span> <span class="toc-text">2. 通过JDK提供的API学习了Math类(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-代码块-理解"><span class="toc-number">3.13.</span> <span class="toc-text">3. 代码块(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-继承-掌握"><span class="toc-number">3.14.</span> <span class="toc-text">4. 继承(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-final关键字-掌握"><span class="toc-number">3.15.</span> <span class="toc-text">1. final关键字(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-多态-掌握"><span class="toc-number">3.16.</span> <span class="toc-text">2. 多态(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-抽象类-掌握"><span class="toc-number">3.17.</span> <span class="toc-text">3. 抽象类(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-接口-掌握"><span class="toc-number">3.18.</span> <span class="toc-text">4. 接口(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-形式参数和返回值的问题-理解"><span class="toc-number">3.19.</span> <span class="toc-text">1. 形式参数和返回值的问题(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-包-理解"><span class="toc-number">3.20.</span> <span class="toc-text">2. 包(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-导包-掌握"><span class="toc-number">3.21.</span> <span class="toc-text">3. 导包(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-权限修饰符-掌握"><span class="toc-number">3.22.</span> <span class="toc-text">4. 权限修饰符(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-常见的修饰符-理解"><span class="toc-number">3.23.</span> <span class="toc-text">5. 常见的修饰符(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-内部类-理解"><span class="toc-number">3.24.</span> <span class="toc-text">6. 内部类(理解)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java常见对象"><span class="toc-number">4.</span> <span class="toc-text">Java常见对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Scanner的使用-了解"><span class="toc-number">4.1.</span> <span class="toc-text">1. Scanner的使用(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-String类的概述和使用-掌握"><span class="toc-number">4.2.</span> <span class="toc-text">2. String类的概述和使用(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-StringBuffer-掌握"><span class="toc-number">4.3.</span> <span class="toc-text">1. StringBuffer(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-数组高级以及Arrays-掌握"><span class="toc-number">4.4.</span> <span class="toc-text">2. 数组高级以及Arrays(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Integer-掌握"><span class="toc-number">4.5.</span> <span class="toc-text">3. Integer(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Character-了解"><span class="toc-number">4.6.</span> <span class="toc-text">4. Character(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-正则表达式-理解"><span class="toc-number">4.7.</span> <span class="toc-text">1. 正则表达式(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Math-掌握"><span class="toc-number">4.8.</span> <span class="toc-text">2. Math(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Random-理解"><span class="toc-number">4.9.</span> <span class="toc-text">3. Random(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-System-掌握"><span class="toc-number">4.10.</span> <span class="toc-text">4. System(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-BigInteger-理解"><span class="toc-number">4.11.</span> <span class="toc-text">5. BigInteger(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-BigDecimal-理解"><span class="toc-number">4.12.</span> <span class="toc-text">6. BigDecimal(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Date-DateFormat-掌握"><span class="toc-number">4.13.</span> <span class="toc-text">7. Date/DateFormat(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Calendar-掌握"><span class="toc-number">4.14.</span> <span class="toc-text">8. Calendar(掌握)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java集合框架"><span class="toc-number">5.</span> <span class="toc-text">Java集合框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaIO流"><span class="toc-number">6.</span> <span class="toc-text">JavaIO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-异常-理解"><span class="toc-number">6.1.</span> <span class="toc-text">1. 异常(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-File-掌握"><span class="toc-number">6.2.</span> <span class="toc-text">2. File(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IO流-掌握"><span class="toc-number">6.3.</span> <span class="toc-text">2. IO流(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-自学字符流"><span class="toc-number">6.4.</span> <span class="toc-text">3. 自学字符流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-字符流-掌握"><span class="toc-number">6.5.</span> <span class="toc-text">1. 字符流(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IO流小结-掌握"><span class="toc-number">6.6.</span> <span class="toc-text">2. IO流小结(掌握)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-案例-理解-练习一遍"><span class="toc-number">6.7.</span> <span class="toc-text">3. 案例(理解 练习一遍)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java多线程"><span class="toc-number">7.</span> <span class="toc-text">Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-多线程-理解"><span class="toc-number">7.1.</span> <span class="toc-text">1. 多线程(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-多线程-理解-1"><span class="toc-number">7.2.</span> <span class="toc-text">1. 多线程(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-设计模式-理解"><span class="toc-number">7.3.</span> <span class="toc-text">2. 设计模式(理解)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaGUI"><span class="toc-number">8.</span> <span class="toc-text">JavaGUI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java网络编程"><span class="toc-number">9.</span> <span class="toc-text">Java网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-网络编程-理解"><span class="toc-number">9.1.</span> <span class="toc-text">1. 网络编程(理解)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java反射"><span class="toc-number">10.</span> <span class="toc-text">Java反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-反射-理解"><span class="toc-number">10.1.</span> <span class="toc-text">1. 反射(理解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-设计模式"><span class="toc-number">10.2.</span> <span class="toc-text">2. 设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JDK新特性"><span class="toc-number">10.3.</span> <span class="toc-text">3. JDK新特性</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">xDaShen</div><div class="author-info__description text-center">一个秘密的地方偷偷的记录</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">xDaShen's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span></div><div id="post-info"><div id="post-title">Java学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-12-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="计算机的基础知识"><a href="#计算机的基础知识" class="headerlink" title="计算机的基础知识"></a>计算机的基础知识</h1><h2 id="1-计算机概述-了解"><a href="#1-计算机概述-了解" class="headerlink" title="1. 计算机概述(了解)"></a>1. 计算机概述(了解)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)计算机</span><br><span class="line">(<span class="number">2</span>)计算机硬件</span><br><span class="line">(<span class="number">3</span>)计算机软件</span><br><span class="line">	系统软件：window,linux,mac</span><br><span class="line">	应用软件：qq,yy,飞秋</span><br><span class="line">(<span class="number">4</span>)软件开发(理解)</span><br><span class="line">	软件：是由数据和指令组成的。(计算器)</span><br><span class="line">	开发：就是把软件做出来。</span><br><span class="line">	如何实现软件开发呢?</span><br><span class="line">		就是使用开发工具和计算机语言做出东西来</span><br><span class="line">(<span class="number">5</span>)语言</span><br><span class="line">	自然语言：人与人交流沟通的</span><br><span class="line">	计算机语言：人与计算机交流沟通的</span><br><span class="line">		C,C++,C#,Java</span><br><span class="line">(<span class="number">6</span>)人机交换</span><br><span class="line">	图形界面：操作方便只管</span><br><span class="line">	DOS命令：需要记忆一些常见的命令</span><br></pre></td></tr></table></figure>

<h2 id="2-键盘功能键的认识和快捷键-掌握"><a href="#2-键盘功能键的认识和快捷键-掌握" class="headerlink" title="2. 键盘功能键的认识和快捷键(掌握)"></a>2. 键盘功能键的认识和快捷键(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)功能键的认识</span><br><span class="line">	tab</span><br><span class="line">	shift</span><br><span class="line">	ctrl</span><br><span class="line">	alt</span><br><span class="line">	windos</span><br><span class="line">	空格</span><br><span class="line">	上下左右</span><br><span class="line">	回车</span><br><span class="line">	截图</span><br><span class="line">(<span class="number">2</span>)快捷键</span><br><span class="line">	全选	Ctrl+A</span><br><span class="line">	复制	Ctrl+C</span><br><span class="line">	粘贴	Ctrl+V</span><br><span class="line">	剪切	Ctrl+X</span><br><span class="line">	撤销	Ctrl+Z</span><br><span class="line">	保存	Ctrl+S</span><br></pre></td></tr></table></figure>

<h2 id="3-常见的DOS命令-掌握"><a href="#3-常见的DOS命令-掌握" class="headerlink" title="3. 常见的DOS命令(掌握)"></a>3. 常见的DOS命令(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)常见的如下</span><br><span class="line">	盘符的切换</span><br><span class="line">		d:回车</span><br><span class="line">	目录的进入</span><br><span class="line">		cd javase</span><br><span class="line">		cd javase\day01\code</span><br><span class="line">	目录的回退</span><br><span class="line">		cd..</span><br><span class="line">		cd\</span><br><span class="line">	清屏</span><br><span class="line">		cls</span><br><span class="line">	退出</span><br><span class="line">		exit</span><br><span class="line">(<span class="number">2</span>)其他的几个(了解)</span><br><span class="line">	创建目录</span><br><span class="line">		mkdir</span><br><span class="line">	删除目录</span><br><span class="line">		rmdir</span><br><span class="line">	创建文件</span><br><span class="line">		edit</span><br><span class="line">	删除文件</span><br><span class="line">		del</span><br><span class="line">	显示目录下的内容</span><br><span class="line">		dir</span><br><span class="line">	删除带内容的目录</span><br><span class="line">		rd /s/q</span><br></pre></td></tr></table></figure>

<h2 id="4-Java语言概述-了解"><a href="#4-Java语言概述-了解" class="headerlink" title="4. Java语言概述(了解)"></a>4. Java语言概述(了解)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)Java语言的发展史</span><br><span class="line">	Java之父</span><br><span class="line">	JDK1.4.2</span><br><span class="line">	JDK5</span><br><span class="line">	JDK7</span><br><span class="line">(<span class="number">2</span>)Java语言的特点</span><br><span class="line">	有很多小特点，重点有两个开源，跨平台</span><br><span class="line">(<span class="number">3</span>)Java语言是跨平台的，请问是如何保证的呢?(理解)</span><br><span class="line">	我们是通过翻译的案例讲解的。</span><br><span class="line">	</span><br><span class="line">	针对不同的操作系统，提供不同的jvm来实现的。</span><br><span class="line">(<span class="number">4</span>)Java语言的平台</span><br><span class="line">	JavaSE</span><br><span class="line">	JavaME--Android</span><br><span class="line">	JavaEE</span><br></pre></td></tr></table></figure>

<h2 id="5-JDK-JRE-JVM的作用及关系-掌握"><a href="#5-JDK-JRE-JVM的作用及关系-掌握" class="headerlink" title="5. JDK,JRE,JVM的作用及关系(掌握)"></a>5. JDK,JRE,JVM的作用及关系(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)作用</span><br><span class="line">	JVM：保证Java语言跨平台</span><br><span class="line">	JRE：Java程序的运行环境</span><br><span class="line">	JDK：Java程序的开发环境</span><br><span class="line">(<span class="number">2</span>)关系</span><br><span class="line">	JDK：JRE+工具</span><br><span class="line">	JRE：JVM+类库</span><br></pre></td></tr></table></figure>

<h2 id="6-JDK的下载-安装-卸载-掌握"><a href="#6-JDK的下载-安装-卸载-掌握" class="headerlink" title="6. JDK的下载,安装,卸载(掌握)"></a>6. JDK的下载,安装,卸载(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)下载到官网。</span><br><span class="line">	A:也可以到百度搜索即可。</span><br><span class="line">	B:我给你。</span><br><span class="line">(<span class="number">2</span>)安装</span><br><span class="line">	A:绿色版	解压就可以使用</span><br><span class="line">	B:安装版	必须一步一步的安装，一般只要会点击下一步即可</span><br><span class="line">	</span><br><span class="line">	注意：</span><br><span class="line">		建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。</span><br><span class="line">(<span class="number">3</span>)卸载</span><br><span class="line">	A:绿色版	直接删除文件夹</span><br><span class="line">	B:安装版	</span><br><span class="line">		a:控制面板 -- 添加删除程序</span><br><span class="line">		b:通过专业的软件卸载工具。(比如<span class="number">360</span>的软件管家卸载)</span><br></pre></td></tr></table></figure>

<h2 id="7-第一个程序：HelloWorld案例-掌握"><a href="#7-第一个程序：HelloWorld案例-掌握" class="headerlink" title="7. 第一个程序：HelloWorld案例(掌握)"></a>7. 第一个程序：HelloWorld案例(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)程序解释：</span><br><span class="line">	A:Java程序的最基本单位是类，所以我们要定义一个类。</span><br><span class="line">		格式：<span class="class"><span class="keyword">class</span> 类名</span></span><br><span class="line"><span class="class">		举例：<span class="title">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line">	B:在类中写内容的时候，用大括号括起来。</span><br><span class="line">	C:Java程序要想执行，必须有main方法。</span><br><span class="line">		格式：<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	D:要指向哪些东西呢，也用大括号括起来。</span></span><br><span class="line"><span class="function">	E:你要做什么呢?今天我们仅仅做了一个简单的输出</span></span><br><span class="line"><span class="function">		格式：System.out.<span class="title">println</span><span class="params">(<span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line">		注意：<span class="string">""</span>里面的内容是可以改动的。</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)Java程序的开发执行流程：</span><br><span class="line">	A:编写java源程序(.java)</span><br><span class="line">	B:通过javac命令编译生成.class文件</span><br><span class="line">	C:通过java命令运行.class文件</span><br></pre></td></tr></table></figure>

<h2 id="8-常见的问题-掌握"><a href="#8-常见的问题-掌握" class="headerlink" title="8. 常见的问题(掌握)"></a>8. 常见的问题(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)扩展名被隐藏</span><br><span class="line">	如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾</span><br><span class="line">(<span class="number">2</span>)我要求文件名称和类名一致。</span><br><span class="line">	实际上不这样做也是可以的。</span><br><span class="line">	但是，注意：</span><br><span class="line">		javac后面跟的是文件名+扩展名</span><br><span class="line">		java后面跟的类名不带扩展名</span><br><span class="line">(<span class="number">3</span>)Java语言严格区分大小写，请注意。</span><br><span class="line">	 还有就是单词不要写错了。</span><br><span class="line">(<span class="number">4</span>)见到非法字符: \<span class="number">65307</span>肯定是中文问题。</span><br><span class="line">	我们写程序要求标点符号必须全部是英文状态。</span><br><span class="line">(<span class="number">5</span>)括号的配对问题。</span><br><span class="line">	一般来说，括号都是成对出现的。</span><br><span class="line">(<span class="number">6</span>)遇到</span><br><span class="line">	在类 HelloWorld 中找不到主方法, 请将主方法定义为</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	肯定是主方法的格式问题。</span></span><br></pre></td></tr></table></figure>

<h2 id="9-path环境变量-掌握"><a href="#9-path环境变量-掌握" class="headerlink" title="9. path环境变量(掌握)"></a>9. path环境变量(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)path环境变量的作用</span><br><span class="line">	保证javac命令可以在任意目录下运行。</span><br><span class="line">	同理可以配置qq等</span><br><span class="line">(<span class="number">2</span>)path配置的两种方案：</span><br><span class="line">	A:方案<span class="number">1</span>(了解)</span><br><span class="line">	B:方案<span class="number">2</span></span><br><span class="line">		找到环境变量的位置，在系统变量里面</span><br><span class="line">		新建：</span><br><span class="line">			变量名：JAVA_HOME</span><br><span class="line">			变量值：D:\develop\Java\jdk1.7.0_60</span><br><span class="line">		修改：</span><br><span class="line">			变量名：Path</span><br><span class="line">			变量值：%JAVA_HOME%\bin;以前的内容</span><br></pre></td></tr></table></figure>

<h2 id="10-classpath环境变量-理解"><a href="#10-classpath环境变量-理解" class="headerlink" title="10. classpath环境变量(理解)"></a>10. classpath环境变量(理解)</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)classpath环境变量的作用</span><br><span class="line">	保证<span class="class"><span class="keyword">class</span>文件可以在任意目录下运行</span></span><br><span class="line"><span class="class">(2)<span class="title">classpath</span>环境变量的配置</span></span><br><span class="line"><span class="class">	找到环境变量的位置，在系统变量里面</span></span><br><span class="line"><span class="class">	新建：</span></span><br><span class="line"><span class="class">		变量名：<span class="title">classpath</span></span></span><br><span class="line">		变量值：E:\JavaSE\day01\code\HelloWorld案例</span><br></pre></td></tr></table></figure>

<h1 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h1><h2 id="1-关键字-掌握"><a href="#1-关键字-掌握" class="headerlink" title="1. 关键字(掌握)"></a>1. 关键字(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)被Java语言赋予特定含义的单词</span><br><span class="line">(<span class="number">2</span>)特点：</span><br><span class="line">	全部小写。</span><br><span class="line">(<span class="number">3</span>)注意事项：</span><br><span class="line">	A:goto和<span class="keyword">const</span>作为保留字存在。</span><br><span class="line">	B:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记</span><br></pre></td></tr></table></figure>

<h2 id="2-标识符-掌握"><a href="#2-标识符-掌握" class="headerlink" title="2. 标识符(掌握)"></a>2. 标识符(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)就是给类，接口，方法，变量等起名字的字符序列</span><br><span class="line">(<span class="number">2</span>)组成规则：</span><br><span class="line">	A:英文大小写字母</span><br><span class="line">	B:数字</span><br><span class="line">	C:$和_</span><br><span class="line">(<span class="number">3</span>)注意事项：</span><br><span class="line">	A:不能以数字开头</span><br><span class="line">	B:不能是java中的关键字</span><br><span class="line">	C:区分大小写</span><br><span class="line">(<span class="number">4</span>)常见的命名规则(见名知意)</span><br><span class="line">	A:包	全部小写</span><br><span class="line">		单级包：小写</span><br><span class="line">			举例：liuyi,com</span><br><span class="line">		多级包：小写，并用.隔开</span><br><span class="line">			举例：cn.itcast,com.baidu				</span><br><span class="line">	B:类或者接口</span><br><span class="line">		一个单词：首字母大写</span><br><span class="line">			举例：Student,Demo</span><br><span class="line">		多个单词：每个单词首字母大写</span><br><span class="line">			举例：HelloWorld,StudentName</span><br><span class="line">	C:方法或者变量</span><br><span class="line">		一个单词：首字母小写</span><br><span class="line">			举例：name,main</span><br><span class="line">		多个单词：从第二个单词开始，每个单词首字母大写</span><br><span class="line">			举例：studentAge,showAllNames()</span><br><span class="line">	D:常量</span><br><span class="line">		全部大写</span><br><span class="line">		一个单词：大写</span><br><span class="line">			举例：PI</span><br><span class="line">		多个单词：大写，并用_隔开</span><br><span class="line">			举例：STUDENT_MAX_AGE</span><br></pre></td></tr></table></figure>

<h2 id="3-注释-掌握"><a href="#3-注释-掌握" class="headerlink" title="3. 注释(掌握)"></a>3. 注释(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)就是对程序进行解释说明的文字</span><br><span class="line">(<span class="number">2</span>)分类：</span><br><span class="line">	A:单行注释	<span class="comment">//</span></span><br><span class="line">	B:多行注释	<span class="comment">/**/</span></span><br><span class="line"><span class="comment">	C:文档注释(后面讲) /** */</span></span><br><span class="line">(<span class="number">3</span>)把HelloWorld案例写了一个带注释的版本。</span><br><span class="line">	后面我们要写一个程序的过程。</span><br><span class="line">	需求：</span><br><span class="line">	分析：</span><br><span class="line">	实现：</span><br><span class="line">	代码体现：</span><br><span class="line">(<span class="number">4</span>)注释的作用</span><br><span class="line">	A:解释说明程序，提高了代码的阅读性。</span><br><span class="line">	B:可以帮助我们调试程序。</span><br><span class="line">		后面我们会讲解一个更高端的一个调试工具</span><br></pre></td></tr></table></figure>

<h2 id="4-常量-掌握"><a href="#4-常量-掌握" class="headerlink" title="4. 常量(掌握)"></a>4. 常量(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)在程序执行的过程中，其值不发生改变的量</span><br><span class="line">(<span class="number">2</span>)分类：</span><br><span class="line">	A:字面值常量</span><br><span class="line">	B:自定义常量(后面讲)</span><br><span class="line">(<span class="number">3</span>)字面值常量</span><br><span class="line">	A:字符串常量 <span class="string">"hello"</span></span><br><span class="line">	B:整数常量	<span class="number">12</span>,<span class="number">23</span></span><br><span class="line">	C:小数常量	<span class="number">12.345</span></span><br><span class="line">	D:字符常量	<span class="string">'a'</span>,<span class="string">'A'</span>,<span class="string">'0'</span></span><br><span class="line">	E:布尔常量	<span class="keyword">true</span>,<span class="keyword">false</span></span><br><span class="line">	F:空常量	<span class="keyword">null</span>(后面讲)</span><br><span class="line">(<span class="number">4</span>)在Java中针对整数常量提供了四种表现形式</span><br><span class="line">	A:二进制	由<span class="number">0</span>，<span class="number">1</span>组成。以<span class="number">0</span>b开头。</span><br><span class="line">	B:八进制	由<span class="number">0</span>，<span class="number">1</span>，...<span class="number">7</span>组成。以<span class="number">0</span>开头。</span><br><span class="line">	C:十进制	由<span class="number">0</span>，<span class="number">1</span>，...<span class="number">9</span>组成。整数默认是十进制。</span><br><span class="line">	D:十六进制	由<span class="number">0</span>，<span class="number">1</span>，...<span class="number">9</span>,a,b,c,d,e,f(大小写均可)组成。以<span class="number">0</span>x开头。</span><br></pre></td></tr></table></figure>

<h2 id="5-进制转换-了解"><a href="#5-进制转换-了解" class="headerlink" title="5. 进制转换(了解)"></a>5. 进制转换(了解)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)其他进制到十进制</span><br><span class="line">	系数：就是每一个位上的数值</span><br><span class="line">	基数：x进制的基数就是x</span><br><span class="line">	权：对每一个位上的数据，从右，并且从<span class="number">0</span>开始编号，对应的编号就是该数据的权。</span><br><span class="line">	</span><br><span class="line">	结果：系数*基数^权次幂之和。</span><br><span class="line">(<span class="number">2</span>)十进制到其他进制</span><br><span class="line">	除基取余，直到商为<span class="number">0</span>，余数反转。</span><br><span class="line">(<span class="number">3</span>)进制转换的快速转换法</span><br><span class="line">	A:十进制和二进制间的转换</span><br><span class="line">		<span class="number">8421</span>码。</span><br><span class="line">	B:二进制到八进制，十六进制的转换</span><br></pre></td></tr></table></figure>

<h2 id="6-变量-掌握"><a href="#6-变量-掌握" class="headerlink" title="6. 变量(掌握)"></a>6. 变量(掌握)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)在程序的执行过程中，其值在某个范围内可以发生改变的量</span><br><span class="line">(<span class="number">2</span>)变量的定义格式：</span><br><span class="line">	A:数据类型 变量名 = 初始化值;</span><br><span class="line">	B:数据类型 变量名;</span><br><span class="line">	  变量名 = 初始化值;</span><br></pre></td></tr></table></figure>

<h2 id="7-数据类型-掌握"><a href="#7-数据类型-掌握" class="headerlink" title="7. 数据类型(掌握)"></a>7. 数据类型(掌握)</h2><pre><code>(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。
(2)分类：
    A:基本数据类型：4类8种
    B:引用数据类型：类，接口，数组。
(3)基本数据类型
    A:整数            占用字节数
        byte            1
        short            2
        int             4
        long            8
    B:浮点数
        float            4
        double            8
    C:字符
        char            2
    D:布尔
        boolean            1

    注意：
        整数默认是int类型，浮点数默认是double。

        长整数要加L或者l。
        单精度的浮点数要加F或者f。</code></pre><h2 id="8-数据类型转换-掌握"><a href="#8-数据类型转换-掌握" class="headerlink" title="8. 数据类型转换(掌握)"></a>8. 数据类型转换(掌握)</h2><pre><code>(1)boolean类型不参与转换
(2)默认转换
    A:从小到大
    B:byte,short,char -- int -- long -- float -- double
    C:byte,short,char之间不相互转换，直接转成int类型参与运算。
(3)强制转换
    A:从大到小
    B:可能会有精度的损失，一般不建议这样使用。
    C:格式：
        目标数据类型 变量名 = (目标数据类型) (被转换的数据);
(4)思考题和面试题：
    A:下面两种方式有区别吗?

        float f1 = 12.345f;//本来就是float
        float f2 = (float)12.345;//double转float

    B:下面的程序有问题吗，如果有，在哪里呢?

        byte b1 = 3;
        byte b2 = 4;
        byte b3 = b1 + b2;//b1+b2是int,需要强转(byte)(b1 + b2)
        byte b4 = 3 + 4;//会先判断3+4的值是否在byte区间内,区间内就没问题

    C:下面的操作结果是什么呢?
        byte b = (byte)130;//-126

    D:字符参与运算
        是查找ASCII里面的值
        &apos;a&apos;        97
        &apos;A&apos;        65
        &apos;0&apos;        48

        System.out.println(&apos;a&apos;);//a
        System.out.println(&apos;a&apos; + 1);//98

    E:字符串参与运算
        这里其实是字符串的连接        

        System.out.println(&quot;hello&quot;+&apos;a&apos;+1);//helloa1
        System.out.println(&apos;a&apos;+1+&quot;hello&quot;);//98hello
        System.out.println(&quot;5+5=&quot;+5+5);//5+5=55
        System.out.println(5+5+&quot;=5+5&quot;);//10=5+5</code></pre><h2 id="1-运算符-掌握"><a href="#1-运算符-掌握" class="headerlink" title="1. 运算符(掌握)"></a>1. 运算符(掌握)</h2><pre><code>(1)算术运算符
    A:+,-,*,/,%,++,--
    B:+的用法
        a:加法
        b:正号
        c:字符串连接符
    C:/和%的区别
        数据做除法操作的时候，/取得是商，%取得是余数
    D:++和--的用法
        a:他们的作用是自增或者自减
        b:使用
            **单独使用
                放在操作数据的前面和后面效果一样。
                a++或者++a效果一样。
            **参与操作使用
                放在操作数的前面：先自增或者自减，再参与操作
                    int a = 10;
                    int b = ++a;
                放在操作数的后面：先参与操作，再自增或者自减
                    int a = 10;
                    int b = a++;
(2)赋值运算符
    A:=,+=,-=,*=,/=,%=等
    B:=叫做赋值运算符，也是最基本的赋值运算符
        int x = 10; 把10赋值给int类型的变量x。
    C:扩展的赋值运算符的特点
        隐含了自动强制转换。

面试题：

short s = 1;
s = s + 1;//有问题,需要强转(short)(s + 1)

short s = 1;
s += 1;//没问题,隐含了自动强制转换

请问上面的代码哪个有问题?

(3)比较运算符
    A:==,!=,&gt;,&gt;=,&lt;,&lt;=
    B:无论运算符两端简单还是复杂最终结果是boolean类型。
    C:千万不要把==写成了=
(4)逻辑运算符
    A:&amp;,|,^,!,&amp;&amp;,||
    B:逻辑运算符用于连接boolean类型的式子
    C:结论
        &amp;:有false则false
        |:有true则true
        ^:相同则false，不同则true。
            情侣关系。
        !:非true则false，非false则true

        &amp;&amp;:结果和&amp;是一样的，只不过有短路效果。左边是false，右边不执行。
        ||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。
(5)位运算符(了解)
    A:^的特殊用法
        一个数据针对另一个数据位异或两次，该数不变
    B:面试题
        a:请实现两个变量的交换
            **采用第三方变量
            **用位异或运算符
                左边a,b,a
                右边a^b
        b:请用最有效率的方式计算出2乘以8的结果
            2&lt;&lt;3
(6)三元运算符
    A:格式
        比较表达式?表达式1:表达式2;
    B:执行流程：
        首先计算比较表达式的值，看是true还是false。
        如果是true，表达式1就是结果。
        如果是false，表达式2就是结果。
    C:案例：
        a:比较两个数据是否相等
            System.out.println(a == b ? true : false);
        b:获取两个数据中的最大值
            System.out.println(a &gt; b ? a : b);
        c:获取三个数据中的最大值
            System.out.println((a&gt;b?a:b)&gt;c?(a&gt;b?a:b):c);</code></pre><h2 id="2-键盘录入-掌握"><a href="#2-键盘录入-掌握" class="headerlink" title="2. 键盘录入(掌握)"></a>2. 键盘录入(掌握)</h2><pre><code>(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。
(2)如何实现呢?目前就记住
    A:导包
        import java.util.Scanner;
        位置：在class的上边
    B:创建对象
        Scanner sc = new Scanner(System.in);
    C:获取数据
        int x = sc.nextInt();
(3)把三元运算符的案例加入键盘录入改进。
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    System.out.println(a &gt; b ? a : b);</code></pre><h2 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3. 流程控制语句"></a>3. 流程控制语句</h2><pre><code>(1)顺序结构 从上往下，依次执行
(2)选择结构    按照不同的选择，执行不同的代码
(3)循环结构 做一些重复的代码</code></pre><h2 id="4-if语句-掌握"><a href="#4-if语句-掌握" class="headerlink" title="4. if语句(掌握)"></a>4. if语句(掌握)</h2><pre><code>(1)三种格式
    A:格式1
        if(比较表达式) {
            语句体;
        }

        执行流程：
            判断比较表达式的值，看是true还是false
            如果是true，就执行语句体
            如果是false，就不执行语句体

    B:格式2
        if(比较表达式) {
            语句体1;
        }else {
            语句体2;
        }

        执行流程：
            判断比较表达式的值，看是true还是false
            如果是true，就执行语句体1
            如果是false，就执行语句体2

    C:格式3
        if(比较表达式1) {
            语句体1;
        }else if(比较表达式2){
            语句体2;
        }
        ...
        else {
            语句体n+1;
        }

        执行流程：
            判断比较表达式1的值，看是true还是false
            如果是true，就执行语句体1
            如果是false，就继续判断比较表达式2的值，看是true还是false
            如果是true，就执行语句体2
            如果是false，就继续判断比较表达式3的值，看是true还是false
            ...
            如果都不满足，就执行语句体n+1
(2)注意事项
    A:比较表达式无论简单还是复杂，结果是boolean类型
    B:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。
        建议：永远不要省略。
    C:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。
    D:else后面如果没有if，是不会出现比较表达式的。
    E:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。
(3)案例：
    A:比较两个数是否相等

        if (a == b) {
            System.out.println(&quot;a == b&quot;);
        }

    B:获取两个数中的最大值

        if (a &gt; b) {
            System.out.println(a);
        } else if (a &lt; b) {
            System.out.println(b);
        }

    C:获取三个数中的最大值(if语句的嵌套)
        if (a &gt; b) {
            if (a &gt; c) {
                System.out.println(a);
            } else if (c &gt; a) {
                System.out.println(c);
            } else if (b &gt; a) {
                if (b &gt; c) {
                    System.out.println(b);
                } else if (c &gt; b) {
                    System.out.println(c);
                }
            }

    D:根据成绩输出对应的等级
        if (score &gt; 0 &amp;&amp; score &lt; 60) {
            System.out.println(&quot;不及格&quot;);
        } else if (score &gt;= 60 &amp;&amp; score &lt; 90) {
            System.out.println(&quot;合格&quot;);
        } else if (score &gt;= 90 &amp;&amp; score &lt;= 100) {
            System.out.println(&quot;优秀&quot;);
        }
    E:根据月份，输出对应的季节
    F:根据x计算对应y的值并输出
(4)三元运算符和if语句第二种格式的关系
    所有的三元运算符能够实现的，if语句的第二种格式都能实现。
    反之不成立。

    如果if语句第二种格式控制的语句体是输出语句，就不可以。
    因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。</code></pre><h2 id="1-switch语句-掌握"><a href="#1-switch语句-掌握" class="headerlink" title="1. switch语句(掌握)"></a>1. switch语句(掌握)</h2><pre><code>(1)格式：
    switch(表达式) {
        case 值1:
            语句体1;
            break;
        case 值2:
            语句体2;
            break;
        ...
        default:
            语句体n+1;
            break;
    }

    格式解释说明：
        switch:说明这是switch语句。
        表达式:可以是byte,short,int,char
            JDK5以后可以是枚举
            JDK7以后可以是字符串
        case:后面的值就是要和表达式进行比较的值
        break:表示程序到这里中断，跳出switch语句
        default:如果所有的情况都不匹配,就执行这里,相当于if语句中的else
(2)面试题
    switch语句的表达式可以是byte吗?可以是long吗?可以是String吗?
        可以,不可以,JDK7以后可以
(3)执行流程:
    A:首先计算表达式的值
    B:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。
    C:如果没有匹配，就执行default的语句体n+1。
(4)注意事项:
    A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的
    B:default可以省略吗?
        可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。
        特殊情况：
            case就可以把值固定。
            A,B,C,D
    C:break可以省略吗?
        可以省略，但是结果可能不是我们想要的。
        会出现一个现象：case穿透。
        最终我们建议不要省略
    D:default一定要在最后吗?
        不是，可以在任意位置。但是建议在最后。
    E:switch语句的结束条件
        a:遇到break就结束了
        b:执行到末尾就结束了
(5)案例：
    A:键盘录入一个数字(1-7),输出对应的星期几。
        Scanner sc = new Scanner(System.in);

            switch (sc.nextInt()) {
            case ## 1. 
                System.out.println(&quot;Monday&quot;);
                break;
            case ## 2. 
                System.out.println(&quot;Tuesday&quot;);
                break;
            case ## 3. 
                System.out.println(&quot;Wednesday&quot;);
                break;
            case ## 4. 
                System.out.println(&quot;Thursday&quot;);
                break;
            case ## 5. 
                System.out.println(&quot;Friday&quot;);
                break;
            case ## 6. 
                System.out.println(&quot;Saturday&quot;);
                break;
            case ## 7. 
                System.out.println(&quot;Sunday&quot;);
                break;
            default:
                System.out.println(&quot;wrong&quot;);
        }
    B:单项选择题
    C:键盘录入一个字符串的问题
        String s = sc.nextLine();
    D:根据给定的月份,输出对应的季节
(6)if语句和switch语句各自的场景
    A:if
        针对boolean类型的判断
        针对一个范围的判断
        针对几个常量的判断
    B:switch
        针对几个常量的判断</code></pre><h2 id="2-循环语句-掌握"><a href="#2-循环语句-掌握" class="headerlink" title="2. 循环语句(掌握)"></a>2. 循环语句(掌握)</h2><pre><code>(1)有三种:for,while,do...while
(2)for循环语句
    A:格式
        for(初始化语句;判断条件语句;控制条件语句){
            循环体语句;
        }

        执行流程：
            a:执行初始化语句
            b:执行判断条件语句
                如果这里是true，就继续
                如果这里是false，循环就结束
            c:执行循环体语句
            d:执行控制条件语句
            e:回到b
    B:注意事项
        a:判断条件语句无论简单还是复杂，结果是boolean类型
        b:循环体语句如果是一条，可以省略大括号，但是不建议
        c:有分号就没有左大括号，有左大括号就没有分号
    C:案例
        a:输出10次HelloWorld
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(&quot;HelloWorld&quot;);
            }
        b:输出1-10的数据
            for (int i = 1; i &lt; 11; i++) {
                System.out.println(i);
            }
        c:输出10-1的数据
            for (int i = 10; i &gt; 0; i--) {
                System.out.println(i);
            }
        d:求1-10的和
            int sum = 0;
            for (int i = 1; i &lt; 11; i++) {
                sum += i;
            }
            System.out.println(sum);
        e:求1-100的和,求1-100的偶数和,求1-100的奇数和
            int sum = 0;
            int oddSum = 0;
            int evenSum = 0;

            for (int i = 1; i &lt; 101; i++) {
                sum += i;
            }
            System.out.println(&quot;sum:&quot; + sum);

            for (int i = 1; i &lt; 101; i+=2) {
                oddSum += i;
            }
            System.out.println(&quot;oddSum:&quot; + oddSum);

            for (int i = 2; i &lt; 101; i+=2) {
                evenSum += i;
            }
            System.out.println(&quot;evenSum:&quot; + evenSum);
        f:求5的阶乘
            int sum = 1;
            for (int i = 5; i &gt; 0; i--) {
                sum *= i;
            }
            System.out.println(sum);
        g:在控制台打印水仙花数(个位,十位,百位的立方和等于该数)
            for (int i = 100; i &lt; 1000; i++) {
                int ge = i % 10;
                int shi = i / 10 % 10;
                int bai = i / 100 % 10;        
                if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {
                    System.out.println(i);
                }
            }
        h:统计水仙花个数
            int flag = 0;
            for (int i = 100; i &lt; 1000; i++) {
                int ge = i % 10;
                int shi = i / 10 % 10;
                int bai = i / 100 % 10;
                if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {
                    flag++;
                }
            }
            System.out.println(flag);
        i:改进版的回文数
            一个五位数
            个位 = 万位
            十位 = 千位
            个位 + 十位 + 千位 + 万位 = 百位
            for (int i = 10000; i &lt; 100000; i++) {
                int ge = i % 10;
                int shi = i / 10 %10;
                int bai = i / 100 % 10;
                int qian = i /1000 % 10;
                int wan = i / 10000 % 10;
                if (ge == wan &amp;&amp; shi == qian &amp;&amp; (ge + shi + qian + wan) == bai) {
                    System.out.println(i);
                }
            }
        j:统计1-1000之间同时满足如下条件的数据有多少个
            x%3==2
            x%5==3
            x%7==2
            int flag = 0;
            for (int i = 1; i &lt; 1001; i++) {
                if (i % 3 == 2 &amp;&amp; i % 5 == 3 &amp;&amp; i % 7 == 2) {
                    flag++;
                }
            }
            System.out.println(flag);
(3)while循环
    A:基本格式
        while(判断条件语句) {
            循环体语句;
        }

        扩展格式：
        初始化语句;
        while(判断条件语句){
            循环体语句;
            控制条件语句;
        }

        通过查看这个格式，我们就知道while循环可以和for循环等价转换。
    B:while的练习
        把for语句的练习用while改进
    C:for和while的区别
        a:使用上的区别
            for语句的那个控制条件变量,在循环结束后不能在使用了。
            而while的可以继续使用。
        b:理解上的区别
            for适合于一个范围的判断
            while适合次数不明确的
                举例:吃葡萄
    D:案例：
        a:珠穆朗玛峰问题
        b:小芳存钱问题(break以后才能做)
(4)do...while循环
    A:基本格式
        do {
            循环体语句;
        }while(判断条件语句);

        扩展格式：
        初始化语句;
        do {
            循环体语句;
            控制条件语句;
        }while(判断条件语句);

        通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。
    B:三种循环的区别
        a:do...while循环至少执行一次循环体
        b:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体
(5)循环使用的注意事项(死循环)
    A:一定要注意修改控制条件,否则容易出现死循环。
    B:最简单的死循环格式
        a:while(true){...}

        b:for(;;){}</code></pre><h2 id="3-控制跳转语句-掌握"><a href="#3-控制跳转语句-掌握" class="headerlink" title="3. 控制跳转语句(掌握)"></a>3. 控制跳转语句(掌握)</h2><pre><code>(1)break:中断的意思
    A:用在循环和switch语句中，离开此应用场景无意义。
    B:作用
        a:跳出单层循环
        b:跳出多层循环，需要标签语句的配合
(2)continue:继续
    A:用在循环中，离开此应用场景无意义。
    B:作用
        a:跳出单层循环的一次，可以继续下一次
    C:填空题
        for(int x=1; x&lt;=10; x++) {
            if(x%3 == 0) {
                //补齐代码
            }
            System.out.println(&quot;Java基础班&quot;);
        }
        如何让控制台输出2次：Java基础班
            break;
        如何让控制台输出7次：Java基础班
            continue;
        如何让控制台输出13次：Java基础班
            System.out.println(&quot;Java基础班&quot;);
(3)return:返回
    A:用于结束方法的，后面还会在继续讲解和使用。
    B:一旦遇到return,程序就不会在继续往后执行。</code></pre><h2 id="1-方法-掌握"><a href="#1-方法-掌握" class="headerlink" title="1. 方法(掌握)"></a>1. 方法(掌握)</h2><pre><code>(1)方法：就是完成特定功能的代码块。
    注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。
(2)格式：
    修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {
        方法体语句;
        return 返回值;
    }


    修饰符：目前就用 public static。后面再详细讲解其他修饰符
    返回值类型：就是功能结果的数据类型
    方法名：就是起了一个名字，方便我们调用该方法。
    参数类型：就是参数的数据类型
    参数名：就是变量
    参数分类：
        实参：实际参与运算的数据
        形参：方法上定义的，用于接收实际参数的变量
    方法体语句：就是完成功能的代码块
    return：结束方法
    返回值：就是功能的结果，由return带给调用者。
(3)两个明确：
    返回值类型：结果的数据类型
    参数列表：参数的个数及对应的数据类型
(4)方法调用
    A:有明确返回值的方法
        a:单独调用，没有意义
        b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。
        c:赋值调用，推荐方案
    B:void类型修饰的方法
        a:单独调用
(5)案例：
    A:求和方案
        public static void sum(int a, int b) {
            System.out.println(&quot;a + b = &quot; + (a + b));
        }
    B:获取两个数中的较大值
        public static void max(int a, int b) {
            if (a &gt; b) {
                System.out.println(a);
            } else if (b &gt; a) {
                System.out.println(b);
            }
        }
    C:比较两个数据是否相同
        public static void isEquals(int a, int b) {
            if (a == b) {
                System.out.println(&quot;a == b&quot;);
            }
        }
    D:获取三个数中的最大值
        public static void max(int a, int b, int c) {
            if (a &gt; b) {
                if (a &gt; c) {
                    System.out.println(a);
                } else if (c &gt; a) {
                    System.out.println(c);
                }
            } else if (b &gt; a) {
                if (b &gt; c) {
                    System.out.println(b);
                } else if (c &gt; b) {
                    System.out.println(c);
                }
            }
        }
    E:输出m行n列的星形
        public static void printStar(int row, int column) {
            for (int m = 0; m &lt; row; m++) {
                String star = &quot;&quot;;
                for (int n = 0; n &lt; column; n++) {
                    star += &quot;*&quot;;
                }
                System.out.println(star);
            }
            System.out.println(&quot;--------------&quot;);
            for (int m = 0; m &lt; row; m++) {
                String star = &quot;&quot;;
                for (int n = 0; n &lt;= m; n++) {
                    star += &quot;*&quot;;
                }
                System.out.println(star);
            }
            System.out.println(&quot;---------------&quot;);
            for (int m = row; m &gt; 0; m--) {
                String star = &quot;&quot;;
                for (int n = 0; n &lt; m; n++) {
                    star += &quot;*&quot;;
                }
                System.out.println(star);
            }
        }
    F:输出nn乘法表
        public static void chengfabiao(int n) {
            for (int i = 1; i &lt;= n; i++) {
                for (int j = 1; j &lt;= i; j++) {
                    System.out.print(j + &quot; * &quot; + i + &quot; = &quot; + (j * i) + &quot;\t&quot;);
                }
                System.out.println();
            }
        }
(6)方法的注意事项
    A:方法不调用不执行
    B:方法之间是平级关系，不能嵌套定义
    C:方法定义的时候，参数是用，隔开的
    D:方法在调用的时候，不用在传递数据类型
    E:如果方法有明确的返回值类型，就必须有return语句返回。
(7)方法重载
    在同一个类中，方法名相同，参数列表不同。与返回值无关。

    参数列表不同：
        参数的个数不同。
        参数的对应的数据类型不同。
(8)方法重载案例
    不同的类型的多个同名方法的比较。</code></pre><h2 id="2-数组-掌握"><a href="#2-数组-掌握" class="headerlink" title="2. 数组(掌握)"></a>2. 数组(掌握)</h2><pre><code>(1)数组：存储同一种数据类型的多个元素的容器。
(2)特点：每一个元素都有编号，从0开始，最大编号是长度-1。
         编号的专业叫法：索引
(3)定义格式
    A:数据类型[] 数组名;
    B:数据类型 数组名[];

    推荐是用A方式，B方法就忘了吧。
    但是要能看懂
(4)数组的初始化
    A:动态初始化
        只给长度，系统给出默认值

        举例：int[] arr = new int[3];
    B:静态初始化
        给出值，系统决定长度

        举例：int[] arr = new int[]{1,2,3};
        简化版：int[] arr = {1,2,3};
(5)Java的内存分配
    A:栈 存储局部变量
    B:堆 存储所有new出来的
    C:方法区(面向对象部分详细讲解)
    D:本地方法区(系统相关)
    E:寄存器(CPU使用)

    注意：
        a:局部变量 在方法定义中或者方法声明上定义的变量。
        b:栈内存和堆内存的区别
            栈：数据使用完毕，就消失。
            堆：每一个new出来的东西都有地址
                每一个变量都有默认值
                    byte,short,int,long 0
                    float,double 0.0
                    char &apos;\u0000&apos;
                    boolean false
                    引用类型 null
                数据使用完毕后，在垃圾回收器空闲的时候回收。
(6)数组内存图
    A:一个数组
    B:二个数组
    C:三个数组(两个栈变量指向同一个堆内存)
(7)数组的常见操作
    A:遍历
        方式1：
            public static void printArray(int[] arr) {
                for(int x=0; x&lt;arr.length; x++) {
                    System.out.println(arr[x]);
                }
            }

        方式2：
            public static void printArray(int[] arr) {
                System.out.print(&quot;[&quot;);
                for(int x=0; x&lt;arr.length; x++) {
                    if(x == arr.length-1) {
                        System.out.println(arr[x]+&quot;]&quot;);
                    }else {
                        System.out.println(arr[x]+&quot;, &quot;);
                    }
                }
            }
    B:最值
        最大值：
            public static int getMax(int[] arr) {
                int max = arr[0];

                for(int x=1; x&lt;arr.length; x++) {
                    if(arr[x] &gt; max) {
                        max = arr[x];
                    }
                }

                return max;
            }

        最小值：
            public static int getMin(int[] arr) {
                int min = arr[0];

                for(int x=1; x&lt;arr.length; x++) {
                    if(arr[x] &lt; min) {
                        min = arr[x];
                    }
                }

                return min;
            }
    C:逆序
        方式1：
            public static void reverse(int[] arr) {
                for(int x=0; x&lt;arr.length/2; x++) {
                    int temp = arr[x];
                    arr[x] = arr[arr.length-1-x];
                    arr[arr.length-1-x] = temp;
                }
            }

        方式2：
            public static void reverse(int[] arr) {
                for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) {
                    int temp = arr[start];
                    arr[start] = arr[end];
                    arr[end] = temp;
                }
            }
    D:查表
            public static String getString(String[] strArray,int index) {
                return strArray[index];
            }
    E:基本查找
        方式1：
            public static int getIndex(int[] arr,int value) {
                for(int x=0; x&lt;arr.length; x++) {
                    if(arr[x] == value) {
                        return x;
                    }
                }

                return -1;
            }

        方式2：
            public static int getIndex(int[] arr,int value) {
                int index = -1;

                for(int x=0; x&lt;arr.length; x++) {
                    if(arr[x] == value) {
                        index = x;
                        break;
                    }
                }

                return index;
            }</code></pre><h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="1-成员变量和局部变量的区别-理解"><a href="#1-成员变量和局部变量的区别-理解" class="headerlink" title="1. 成员变量和局部变量的区别(理解)"></a>1. 成员变量和局部变量的区别(理解)</h2><pre><code>(1)在类中的位置不同
    成员变量：类中方法外
    局部变量：方法定义中或者方法声明上
(2)在内存中的位置不同
    成员变量：在堆中
    局部变量：在栈中
(3)生命周期不同
    成员变量：随着对象的创建而存在，随着对象的消失而消失
    局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
(4)初始化值不同
    成员变量：有默认值
    局部变量：没有默认值，必须定义，赋值，然后才能使用</code></pre><h2 id="2-类作为形式参数的问题-理解"><a href="#2-类作为形式参数的问题-理解" class="headerlink" title="2. 类作为形式参数的问题?(理解)"></a>2. 类作为形式参数的问题?(理解)</h2><pre><code>(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。</code></pre><h2 id="3-匿名对象-理解"><a href="#3-匿名对象-理解" class="headerlink" title="3. 匿名对象(理解)"></a>3. 匿名对象(理解)</h2><pre><code>(1)没有名字的对象
(2)应用场景
    A:调用方法，仅仅只调用一次的时候。
    b:可以作为实际参数传递。</code></pre><h2 id="4-封装-理解"><a href="#4-封装-理解" class="headerlink" title="4. 封装(理解)"></a>4. 封装(理解)</h2><pre><code>(1)隐藏实现细节，提供公共的访问方式
(2)好处：
    A:隐藏实现细节，提供公共的访问方式
    B:提高代码的复用性
    C:提高代码的安全性
(3)设计原则
    把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式
(4)private是封装的一种体现。
    封装：类，方法，private修饰成员变量</code></pre><h2 id="5-private关键字-掌握"><a href="#5-private关键字-掌握" class="headerlink" title="5. private关键字(掌握)"></a>5. private关键字(掌握)</h2><pre><code>(1)私有的意义，可以修饰成员变量和成员方法
(2)特点：
    被private修饰的后的成员只能在本类中被访问
(3)private的应用：
    以后再写一个类的时候：
        把所有的成员变量给private了
        提供对应的getXxx()/setXxx()方法</code></pre><h2 id="6-this关键字-掌握"><a href="#6-this关键字-掌握" class="headerlink" title="6. this关键字(掌握)"></a>6. this关键字(掌握)</h2><pre><code>(1)代表当前类的引用对象
    记住：哪个对象调用方法，该方法内部的this就代表那个对象
(2)this的应用场景：
    A:解决了局部变量隐藏成员变量的问题
    B:其实this还有其他的应用，明天讲解。</code></pre><h2 id="7-构造方法-掌握"><a href="#7-构造方法-掌握" class="headerlink" title="7. 构造方法(掌握)"></a>7. 构造方法(掌握)</h2><pre><code>(1)作用：用于对对象的数据进行初始化
(2)格式：
    A:方法名和类名相同
    B:没有返回值类型，连void都不能有
    C:没有返回值

    思考题：构造方法中可不可以有return语句呢?
    可以。只要我们写成这个样子就OK了：return;
    其实，在任何的void类型的方法的最后你都可以写上：return;
(3)构造方法的注意事项
    A:如果我们没写构造方法，系统将提供一个默认的无参构造方法
    B:如果我们给出了构造方法，系统将不再提供默认构造方法
        如果这个时候，我们要使用无参构造方法，就必须自己给出。
        推荐：永远手动自己给出无参构造方法。
(4)给成员变量赋值的方式
    A:setXxx()
    B:带参构造方法
(5)标准案例
    class Student {
        private String name;
        private int age;

        public Student(){}

        public Student(String name,int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }

    测试：
    class StudentDemo {
        public static void main(String[] args) {
            //方式1
            Student s1 = new Student();
            s1.setName(&quot;林青霞&quot;);
            s1.setAge(27);
            System.out.println(s1.getName()+&quot;---&quot;+s1.getAge());

            //方式2
            Student s2 = new Student(&quot;刘意&quot;,30);
            System.out.println(s2.getName()+&quot;---&quot;+s2.getAge());
        }
    }</code></pre><h2 id="8-代码：Student-s-new-Student-做了哪些事情-理解"><a href="#8-代码：Student-s-new-Student-做了哪些事情-理解" class="headerlink" title="8. 代码：Student s = new Student();做了哪些事情?(理解)"></a>8. 代码：Student s = new Student();做了哪些事情?(理解)</h2><pre><code>(1)把Student.class文件加载到内存
(2)在栈内存为s开辟空间
(3)在堆内存为学生对象申请空间
(4)给学生的成员变量进行默认初始化。null,0
(5)给学生的成员变量进行显示初始化。林青霞,27
(6)通过构造方法给成员变量进行初始化。刘意,30
(7)对象构造完毕，把地址赋值给s变量</code></pre><h2 id="9-面向对象的练习题-掌握"><a href="#9-面向对象的练习题-掌握" class="headerlink" title="9. 面向对象的练习题(掌握)"></a>9. 面向对象的练习题(掌握)</h2><pre><code>(1)标准的手机类的定义和测试
(2)Demo类有求和方法，Test类进行测试。
    什么时候定义成员变量?
    当该变量是用来描述一个类的时候。
(3)长方形案例
(4)员工案例
(5)MyMath案例(自己提供加减乘除并测试)
    public class MyMath {
        public MyMath() {
        }

        public static void add(int a, int b) {
            System.out.println(&quot;add&quot; + (a + b));
        }

        public static void subtract(int a, int b) {
            System.out.println(&quot;subtract&quot; + (a - b));
        }

        public static void multiply(int a, int b) {
            System.out.println(&quot;multiply&quot; + (a * b));
        }

        public static void divide(int a, int b) {
            System.out.println(&quot;divide&quot; + (a / b));
        }
    }</code></pre><h2 id="10-static关键字-理解"><a href="#10-static关键字-理解" class="headerlink" title="10. static关键字(理解)"></a>10. static关键字(理解)</h2><pre><code>(1)静态的意思。可以修饰成员变量和成员方法。
(2)静态的特点：
    A:随着类的加载而加载
    B:优先于对象存在
    C:被类的所有对象共享
        这其实也是我们判断该不该使用静态的依据。
        举例：饮水机和水杯的问题思考
    D:可以通过类名调用
        既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。
(3)静态的内存图
    静态的内容在方法区的静态区
(4)静态的注意事项；
    A:在静态方法中没有this对象
    B:静态只能访问静态(代码测试过)
(5)静态变量和成员变量的区别
    A:所属不同
        静态变量：属于类，类变量
        成员变量：属于对象，对象变量，实例变量
    B:内存位置不同
        静态变量：方法区的静态区
        成员变量：堆内存
    C:生命周期不同
        静态变量：静态变量是随着类的加载而加载，随着类的消失而消失
        成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失
    D:调用不同
        静态变量：可以通过对象名调用，也可以通过类名调用
        成员变量：只能通过对象名调用
(6)main方法是静态的
    public:权限最大
    static:不用创建对象调用
    void:返回值给jvm没有意义
    main:就是一个常见的名称。
    String[] args:可以接收数据，提供程序的灵活性
        格式：java MainDemo hello world java
              java MainDemo 10 20 30</code></pre><h2 id="1-如何制作帮助文档-了解"><a href="#1-如何制作帮助文档-了解" class="headerlink" title="1. 如何制作帮助文档(了解)"></a>1. 如何制作帮助文档(了解)</h2><pre><code>(1)写一个类
(2)加入文档注释
(3)通过javadoc工具生成即可
    javadoc -d 目录 -author -version ArrayTool.java</code></pre><h2 id="2-通过JDK提供的API学习了Math类-掌握"><a href="#2-通过JDK提供的API学习了Math类-掌握" class="headerlink" title="2. 通过JDK提供的API学习了Math类(掌握)"></a>2. 通过JDK提供的API学习了Math类(掌握)</h2><pre><code>(1)API(Application Programming Interface)
    应用程序编程接口(帮助文档)
(2)如何使用呢?
    请参照
        day08\code\02_如何使用JDK提供的帮助文档\如何使用帮助文档.txt
(3)Math类
    A:是针对数学进行操作的类
    B:没有构造方法，因为它的成员都是静态的
    C:产生随机数
        public static double random(): [0.0,1.0)
    D:如何产生一个1-100之间的随机数
        int number = (int)(Math.random()*100)+1;
    E:猜数字小游戏</code></pre><h2 id="3-代码块-理解"><a href="#3-代码块-理解" class="headerlink" title="3. 代码块(理解)"></a>3. 代码块(理解)</h2><pre><code>(1)用{}括起来的代码。
(2)分类：
    A:局部代码块
        用于限定变量的生命周期，及早释放，提高内存利用率。
    B:构造代码块
        把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。
    C:静态代码块
        对类的数据进行初始化，仅仅只执行一次。
(3)静态代码块,构造代码块,构造方法的顺序问题?
    静态代码块 &gt; 构造代码块 &gt; 构造方法</code></pre><h2 id="4-继承-掌握"><a href="#4-继承-掌握" class="headerlink" title="4. 继承(掌握)"></a>4. 继承(掌握)</h2><pre><code>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，
   这多个类就具备了这些内容。这个关系叫继承。
(2)Java中如何表示继承呢?格式是什么呢?
    A:用关键字extends表示
    B:格式：
        class 子类名 extends 父类名 {}
(3)继承的好处：
    A:提高了代码的复用性
    B:提高了代码的维护性
    C:让类与类产生了一个关系，是多态的前提
(4)继承的弊端：
    A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。
        原则：低耦合，高内聚。
        耦合：类与类的关系
        内聚：自己完成某件事情的能力
    B:打破了封装性
(5)Java中继承的特点
    A:Java中类只支持单继承
    B:Java中可以多层(重)继承(继承体系)
(6)继承的注意事项：
    A:子类不能继承父类的私有成员
    B:子类不能继承父类的构造方法，但是可以通过super去访问
    C:不要为了部分功能而去继承
(7)什么时候使用继承呢?
    A:继承体现的是：is a的关系。
    B:采用假设法
(8)Java继承中的成员关系
    A:成员变量
        a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单
        b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
            子类的方法访问变量的查找顺序：
                在子类方法的局部范围找，有就使用。
                在子类的成员范围找，有就使用。
                在父类的成员范围找，有就使用。
                找不到，就报错。
    B:构造方法
        a:子类的构造方法默认会去访问父类的无参构造方法
            是为了子类访问父类数据的初始化
        b:父类中如果没有无参构造方法，怎么办?
            子类通过super去明确调用带参构造
            子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造
            让父类提供无参构造
    C:成员方法
        a:子类的成员方法和父类中的成员方法名称不一样，这个太简单
        b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?
            通过子类对象访问一个方法的查找顺序：
                在子类中找，有就使用
                在父类中找，有就使用
                找不到，就报错
(9)两个面试题：
    A:Override和Overload的区别?Overload是否可以改变返回值类型?
    B:this和super的区别和各自的作用?
(10)数据初始化的面试题
    A:一个类的初始化过程
    B:子父类的构造执行过程
    C:分层初始化
(11)案例：
    A:学生和老师案例
        继承前
        继承后
    B:猫狗案例的分析和实现</code></pre><h2 id="1-final关键字-掌握"><a href="#1-final关键字-掌握" class="headerlink" title="1. final关键字(掌握)"></a>1. final关键字(掌握)</h2><pre><code>(1)是最终的意思，可以修饰类，方法，变量。
(2)特点：
    A:它修饰的类，不能被继承。
    B:它修饰的方法，不能被重写。
    C:它修饰的变量，是一个常量。
(3)面试相关：
    A:局部变量
        a:基本类型 值不能发生改变
        b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的
    B:初始化时机
        a:只能初始化一次。
        b:常见的给值
            定义的时候。(推荐)
            构造方法中。</code></pre><h2 id="2-多态-掌握"><a href="#2-多态-掌握" class="headerlink" title="2. 多态(掌握)"></a>2. 多态(掌握)</h2><pre><code>(1)同一个对象在不同时刻体现出来的不同状态。
(2)多态的前提：
    A:有继承或者实现关系。
    B:有方法重写。
    C:有父类或者父接口引用指向子类对象。

    多态的分类：
        a:具体类多态
            class Fu {}
            class Zi extends Fu {}

            Fu f = new Zi();
        b:抽象类多态
            abstract class Fu {}
            class Zi extends Fu {}

            Fu f = new Zi();
        c:接口多态
            interface Fu {}
            class Zi implements Fu {}

            Fu f = new Zi();
(3)多态中的成员访问特点
    A:成员变量
        编译看左边，运行看左边
    B:构造方法
        子类的构造都会默认访问父类构造
    C:成员方法
        编译看左边，运行看右边
    D:静态方法
        编译看左边，运行看左边

    为什么?
        因为成员方法有重写。
(4)多态的好处：
    A:提高代码的维护性(继承体现)
    B:提高代码的扩展性(多态体现)
(5)多态的弊端：
    父不能使用子的特有功能。

    现象：
        子可以当作父使用，父不能当作子使用。
(6)多态中的转型
    A:向上转型
        从子到父
    B:向下转型
        从父到子
(7)孔子装爹的案例帮助大家理解多态
(8)多态的练习
    A:猫狗案例
    B:老师和学生案例</code></pre><h2 id="3-抽象类-掌握"><a href="#3-抽象类-掌握" class="headerlink" title="3. 抽象类(掌握)"></a>3. 抽象类(掌握)</h2><pre><code>(1)把多个共性的东西提取到一个类中，这是继承的做法。
   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。
   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。
   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。
   而一个没有具体的方法体的方法是抽象的方法。
   在一个类中如果有抽象方法，该类必须定义为抽象类。
(2)抽象类的特点
    A:抽象类和抽象方法必须用关键字abstract修饰
    B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类
    C:抽象类不能实例化
    D:抽象类的子类
        a:是一个抽象类。
        b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。
(3)抽象类的成员特点：
    A:成员变量
        有变量，有常量
    B:构造方法
        有构造方法
    C:成员方法
        有抽象，有非抽象
(4)抽象类的练习
    A:猫狗案例练习
    B:老师案例练习
    C:学生案例练习
    D:员工案例练习
(5)抽象类的几个小问题
    A:抽象类有构造方法，不能实例化，那么构造方法有什么用?
        用于子类访问父类数据的初始化
    B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?
        为了不让创建对象
    C:abstract不能和哪些关键字共存
        a:final    冲突
        b:private 冲突
        c:static 无意义</code></pre><h2 id="4-接口-掌握"><a href="#4-接口-掌握" class="headerlink" title="4. 接口(掌握)"></a>4. 接口(掌握)</h2><pre><code>(1)回顾猫狗案例，它们仅仅提供一些基本功能。
   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，
   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。
(2)接口的特点：
    A:接口用关键字interface修饰
        interface 接口名 {}
    B:类实现接口用implements修饰
        class 类名 implements 接口名 {}
    C:接口不能实例化
    D:接口的实现类
        a:是一个抽象类。
        b:是一个具体类，这个类必须重写接口中的所有抽象方法。
(3)接口的成员特点：
    A:成员变量
        只能是常量
        默认修饰符：public static final
    B:构造方法
        没有构造方法
    C:成员方法
        只能是抽象的
        默认修饰符：public abstract
(4)类与类,类与接口,接口与接口
    A:类与类
        继承关系，只能单继承，可以多层继承
    B:类与接口
        实现关系，可以单实现，也可以多实现。
        还可以在继承一个类的同时，实现多个接口
    C:接口与接口
        继承关系，可以单继承，也可以多继承
(5)抽象类和接口的区别(自己补齐)?
    A:成员区别
        抽象类：可以是变量可以是常量
        接口：只能是常量
    B:关系区别:
        类与类：继承
        类与接口：实现
        接口与接口：继承
    C:设计理念不同
        抽象类：is a，抽象类中定义的是共性功能。
        接口：like a，接口中定义的是扩展功能。
(6)练习：
    A:猫狗案例，加入跳高功能
    B:老师和学生案例，加入抽烟功能0</code></pre><h2 id="1-形式参数和返回值的问题-理解"><a href="#1-形式参数和返回值的问题-理解" class="headerlink" title="1. 形式参数和返回值的问题(理解)"></a>1. 形式参数和返回值的问题(理解)</h2><pre><code>(1)形式参数：
    类名：需要该类的对象
    抽象类名：需要该类的子类对象
    接口名：需要该接口的实现类对象
(2)返回值类型：
    类名：返回的是该类的对象
    抽象类名：返回的是该类的子类对象
    接口名：返回的是该接口的实现类的对象
(3)链式编程
    对象.方法1().方法2().......方法n();

    这种用法：其实在方法1()调用完毕后，应该一个对象；
              方法2()调用完毕后，应该返回一个对象。
              方法n()调用完毕后，可能是对象，也可以不是对象。</code></pre><h2 id="2-包-理解"><a href="#2-包-理解" class="headerlink" title="2. 包(理解)"></a>2. 包(理解)</h2><pre><code>(1)其实就是文件夹
(2)作用：
    A:区分同名的类
    B:对类进行分类管理
        a:按照功能分
        b:按照模块分
(3)包的定义(掌握)
    package 包名;
    多级包用.分开。
(4)注意事项：(掌握)
    A:package语句必须在文件中的第一条有效语句
    B:在一个java文件中，只能有一个package
    C:如果没有package，默认就是无包名
(5)带包的编译和运行
    A:手动式
    B:自动式(掌握)
        javac -d . HelloWorld.java</code></pre><h2 id="3-导包-掌握"><a href="#3-导包-掌握" class="headerlink" title="3. 导包(掌握)"></a>3. 导包(掌握)</h2><pre><code>(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。
(2)格式：
    import 包名...类名;
    另一种：
        import 包名...*;(不建议)
(3)package,import,class的顺序
    package &gt; import &gt; class</code></pre><h2 id="4-权限修饰符-掌握"><a href="#4-权限修饰符-掌握" class="headerlink" title="4. 权限修饰符(掌握)"></a>4. 权限修饰符(掌握)</h2><pre><code>(1)权限修饰符
                本类    同一个包下    不同包下的子类    不同包下的无关类
    private        Y
        默认        Y        Y
    protected    Y        Y             Y
    public        Y        Y             Y                  Y
(2)这四种权限修饰符在任意时刻只能出现一种。
    public class Demo {}        </code></pre><h2 id="5-常见的修饰符-理解"><a href="#5-常见的修饰符-理解" class="headerlink" title="5. 常见的修饰符(理解)"></a>5. 常见的修饰符(理解)</h2><pre><code>(1)分类：
    权限修饰符：private,默认,protected,public
    状态修饰符：static,final
    抽象修饰符：abstract
(2)常见的类及其组成的修饰
    类：
        默认,public,final,abstract
        常用的：public
    成员变量：
        private,默认,protected,public,static,final
        常用的：private
    构造方法：
        private,默认,protected,public
        常用的：public
    成员方法：
        private,默认,protected,public,static,final,abstract
        常用的：public
(3)另外比较常见的：
    public static final int X = 10;
    public static void show() {}
    public final void show() {}
    public abstract void show();</code></pre><h2 id="6-内部类-理解"><a href="#6-内部类-理解" class="headerlink" title="6. 内部类(理解)"></a>6. 内部类(理解)</h2><pre><code>(1)把类定义在另一个类的内部，该类就被称为内部类。
    举例：把类B定义在类A中，类B就被称为内部类。
(2)内部类的访问规则
    A:可以直接访问外部类的成员，包括私有
    B:外部类要想访问内部类成员，必须创建对象
(3)内部类的分类
    A:成员内部类
    B:局部内部类
(4)成员内部类
    A:private 为了数据的安全性
    B:static 为了访问的方便性        
成员内部类不是静态的：
    外部类名.内部类名 对象名 = new 外部类名.new 内部类名();
成员内部类是静态的：
    外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre><p>(5)成员内部类的面试题(填空)</p>
<pre><code>30,20,10
class Outer {
    public int num = 10;
        class Inner {
            public int num = 20;
            public viod show() {
            int num  = 30;
            System.out.println(num);
            System.out.println(this.num);
            System.out.println(Outer.this.num);
            }
        }
    }</code></pre><p>(6)局部内部类</p>
<pre><code>A:局部内部类访问局部变量必须加final修饰。
B:为什么呢?
    因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。
    所以，堆内存还是用该变量，而改变量已经没有了。
    为了让该值还存在，就加final修饰。
    通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。</code></pre><p>(7)匿名内部类(掌握)</p>
<pre><code>A:是局部内部类的简化形式
B:前提
    存在一个类或者接口
C:格式:
    new 类名或者接口名() {
        重写方法;
    }
D:本质：
    其实是继承该类或者实现接口的子类匿名对象</code></pre><p>(8)匿名内部类在开发中的使用</p>
<pre><code>我们在开发的时候，会看到抽象类，或者接口作为参数。
而这个时候，我们知道实际需要的是一个子类对象。
如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。

interface Person {
    public abstract void study();
}

class PersonDemo {
    public void method(Person p) {
        p.study();
    }
}

class PersonTest {
    public static void main(String[] args) {
        PersonDemo pd = new PersonDemo();
        pd.method(new Person() {
            public void study() {
                System.out.println(&quot;好好学习，天天向上&quot;);
            }
        });
    }
}</code></pre><p>(9)匿名内部类的面试题(补齐代码)</p>
<pre><code>interface Inter {
    void show();
}

class Outer {
    public static Inter method() {
        return new Inter() {
            public void show() {
                System.out.println(&quot;HelloWorld&quot;);
            }    
        };
    }
}

class OuterDemo {
    public static void main(String[] args) {
        Outer.method().show(); //&quot;HelloWorld&quot;
    }

}</code></pre><p>Java开发工具</p>
<pre><code>## 1. Eclipse的概述使用(掌握)
    请参照ppt和课堂练习.txt

## 2. API的概述(了解)
    (1)应用程序编程接口。
    (2)就是JDK提供给我们的一些提高编程效率的java类。</code></pre><p>​<br>    ## 3. Object类(掌握)<br>        (1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。<br>        (2)Object类的构造方法有一个，并且是无参构造<br>            这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造<br>        (3)要掌握的方法：<br>            A:toString()<br>                返回对象的字符串表示，默认是由类的全路径+’@’+哈希值的十六进制表示。<br>                这个表示其实是没有意义的，一般子类都会重写该方法。<br>                如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。<br>                但是最终还是自动生成。<br>            B:equals()<br>                比较两个对象是否相同。默认情况下，比较的是地址值是否相同。<br>                而比较地址值是没有意义的，所以，一般子类也会重写该方法。<br>                重写过程，我也详细的讲解和分析了。<br>                但是最终还是自动生成。<br>        (4)要了解的方法：<br>            A:hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。<br>            B:getClass() 返回对象的字节码文件对象，反射中我们会详细讲解<br>            C:finalize() 用于垃圾回收，在不确定的时间<br>            D:clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。<br>        (5)两个注意问题；<br>            A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。<br>            B:面试题<br>                ==和equals()的区别?<br>                A:==<br>                    基本类型：比较的是值是否相同<br>                    引用类型：比较的是地址值是否相同<br>                B:equals()<br>                    只能比较引用类型。默认情况下，比较的是地址值是否相同。<br><br>                但是，我们可以根据自己的需要重写该方法。</p>
<h1 id="Java常见对象"><a href="#Java常见对象" class="headerlink" title="Java常见对象"></a>Java常见对象</h1><h2 id="1-Scanner的使用-了解"><a href="#1-Scanner的使用-了解" class="headerlink" title="1. Scanner的使用(了解)"></a>1. Scanner的使用(了解)</h2><pre><code>    (1)在JDK5以后出现的用于键盘录入数据的类。
    (2)构造方法：
        A:讲解了System.in这个东西。
            它其实是标准的输入流,对应于键盘录入
        B:构造方法
            InputStream is = System.in;
            Scanner(InputStream is)
        C:常用的格式
            Scanner sc = new Scanner(System.in);
(3)基本方法格式：
    A:hasNextXxx() 判断是否是某种类型的
    B:nextXxx()    返回某种类型的元素
(4)要掌握的两个方法
    A:public int nextInt()
    B:public String nextLine()
(5)需要注意的小问题
    A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。
    B:解决方案：
        a:重新定义一个Scanner对象
        b:把所有的数据都用字符串获取，然后再进行相应的转换</code></pre><h2 id="2-String类的概述和使用-掌握"><a href="#2-String类的概述和使用-掌握" class="headerlink" title="2. String类的概述和使用(掌握)"></a>2. String类的概述和使用(掌握)</h2><pre><code>(1)多个字符组成的一串数据。
    其实它可以和字符数组进行相互转换。
(2)构造方法：
    A:public String()
    B:public String(byte[] bytes)
    C:public String(byte[] bytes,int offset,int length)
    D:public String(char[] value)
    E:public String(char[] value,int offset,int count)
    F:public String(String original)
    下面的这一个虽然不是构造方法，但是结果也是一个字符串对象
    G:String s = &quot;hello&quot;;
(3)字符串的特点
    A:字符串一旦被赋值，就不能改变。
        注意：这里指的是字符串的内容不能改变，而不是引用不能改变。
    B:字面值作为字符串对象和通过构造方法创建对象的不同
        String s = new String(&quot;hello&quot;);和String s = &quot;hello&quot;的区别?
        new String(&quot;hello&quot;)会在堆内存开辟空间,另一种不会,但是最终的值都在字符串缓存区.
(4)字符串的面试题(看程序写结果)
    A:==和equals()
        String s1 = new String(&quot;hello&quot;);
        String s2 = new String(&quot;hello&quot;);
        System.out.println(s1 == s2);// false
        System.out.println(s1.equals(s2));// true


        String s3 = new String(&quot;hello&quot;);
        String s4 = &quot;hello&quot;;
        System.out.println(s3 == s4);// false
        System.out.println(s3.equals(s4));// true


        String s5 = &quot;hello&quot;;
        String s6 = &quot;hello&quot;;
        System.out.println(s5 == s6);// true(常量会先去缓存区找,存在就不创建新的对象)
        System.out.println(s5.equals(s6));// true
    B:字符串的拼接
        String s1 = &quot;hello&quot;;
        String s2 = &quot;world&quot;;
        String s3 = &quot;helloworld&quot;;
        System.out.println(s3 == s1 + s2);// false
        System.out.println(s3.equals((s1 + s2)));// true


        System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// false 这个我们错了，应该是true
        System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true
(5)字符串的功能(自己补齐方法中文意思)
    A:判断功能
        boolean equals(Object obj)
        boolean equalsIgnoreCase(String str)
        boolean contains(String str)
        boolean startsWith(String str)
        boolean endsWith(String str)
        boolean isEmpty()
    B:获取功能
        int length()
        char charAt(int index)
        int indexOf(int ch)
        int indexOf(String str)
        int indexOf(int ch,int fromIndex)
        int indexOf(String str,int fromIndex)
        String substring(int start)
        String substring(int start,int end)
    C:转换功能
        byte[] getBytes()
        char[] toCharArray()
        static String valueOf(char[] chs)
        static String valueOf(int i)
        String toLowerCase()
        String toUpperCase()
        String concat(String str)
    D:其他功能
        a:替换功能 
            String replace(char old,char new)
            String replace(String old,String new)
        b:去空格功能
            String trim()
        c:按字典比较功能
            int compareTo(String str)
            int compareToIgnoreCase(String str) 
(6)字符串的案例
    A:模拟用户登录
        public static void login(String userName, String passwd) {
            if (userName == &quot;Xmos&quot; &amp;&amp; passwd == &quot;123&quot;) {
                System.out.println(&quot;login success&quot;);
            }
        }
    B:字符串遍历
        public static void printString(String s) {
            char[] c = s.toCharArray();
            for (int i = 0; i &lt; c.length; i++) {
                System.out.print(c[i]);
            }
        }
    C:统计字符串中大写，小写及数字字符的个数
        public static void method(String s) {
            char[] c = s.toCharArray();
            int lowerCaseNum = 0;
            int upperCaseNum = 0;
            int num = 0;
            for (char c1 : c) {
                if (c1 &gt;= &apos;a&apos; &amp;&amp; c1 &lt;= &apos;z&apos;) {
                    lowerCaseNum++;
                } else if (c1 &gt;= &apos;A&apos; &amp;&amp; c1 &lt;= &apos;Z&apos;) {
                    upperCaseNum++;
                } else if (c1 &gt;= &apos;0&apos; &amp;&amp; c1 &lt;= &apos;9&apos;) {
                    num++;
                }
            }

    D:把字符串的首字母转成大写，其他小写
        public static void method1(String s) {
            String s1 = s.substring(0, 1);
            String s2 = s.substring(1, s.length());
            String s3 = s1.toUpperCase() + s2.toLowerCase();

            System.out.println(s3);
        }        
    E:把int数组拼接成一个指定格式的字符串
        //方法一
        public static void method3(int[] i) {
            String s = Arrays.toString(i);
            System.out.println(s);
        }
        //方法二
        public static void method3(int[] i) {
                String s = &quot;&quot;;
                for (int i1 : i) {
                    s += String.valueOf(i1);
                }
                System.out.println(s);
            }
    F:字符串反转
        public static void revers(String s) {
            char[] c = s.toCharArray();
            for (int i = 0; i &lt; c.length / 2; i++) {
                char tmp = c[i];
                c[i] = c[c.length - 1 - i];
                c[c.length - 1 - i] = tmp;
            }
            System.out.println(String.valueOf(c));
        }        
    G:统计大串中小串出现的次数</code></pre><h2 id="1-StringBuffer-掌握"><a href="#1-StringBuffer-掌握" class="headerlink" title="1. StringBuffer(掌握)"></a>1. StringBuffer(掌握)</h2><pre><code>(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了
   一个字符串缓冲区类。StringBuffer供我们使用。
(2)StringBuffer的构造方法
    A:StringBuffer()
    B:StringBuffer(int size)
    C:StringBuffer(String str)
(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)
    A:添加功能
        appen();
    B:删除功能
        delete();
    C:替换功能
        replace()
    D:反转功能
        reverse()
    E:截取功能(注意这个返回值)
        String substring()
(4)StringBuffer的练习(做一遍)
    A:String和StringBuffer相互转换
        String -- StringBuffer
            构造方法
        StringBuffer -- String
            toString()方法
    B:字符串的拼接
        StringBuffer sb = new StringBuffer(&quot;hello&quot;);
        StringBuffer sb2 = new StringBuffer(&quot;world&quot;);

        StringBuffer sb3 = sb.append(sb2);
    C:把字符串反转
        StringBuffer sb = new StringBuffer(&quot;abc&quot;);
        StringBuffer sb1 = sb.reverse();
    D:判断一个字符串是否对称
        public static void method(StringBuffer sb) {
            if (sb.toString().equals(sb.reverse().toString())) {
                System.out.println(true);
            } else {
                System.out.println(false);
            }
        }

(5)面试题
    小细节：
        StringBuffer：同步的，数据安全，效率低。
        StringBuilder：不同步的，数据不安全，效率高。
    A:String,StringBuffer,StringBuilder的区别
        String 字符串常量
        StringBuffer 字符串变量（线程安全）
        StringBuilder 字符串变量（非线程安全）
    B:StringBuffer和数组的区别?
        StringBuffer : 可以存放任意类型的数据
        数组 : 只能存放同类型的数据
(6)注意的问题：
    String作为形式参数，StringBuffer作为形式参数。
        String : 不会受影响
        StringBuffer : 除了=操作，其他操作会受影响</code></pre><h2 id="2-数组高级以及Arrays-掌握"><a href="#2-数组高级以及Arrays-掌握" class="headerlink" title="2. 数组高级以及Arrays(掌握)"></a>2. 数组高级以及Arrays(掌握)</h2><pre><code>(1)排序
    A:冒泡排序
        相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。

        public static void bubbleSort(int[] arr) {
            for(int x=0; x&lt;arr.length-1; x++) {
                for(int y=0; y&lt;arr.length-1-x; y++) {
                    if(arr[y] &gt; arr[y+1]) {
                        int temp = arr[y];
                        arr[y] = arr[y+1];
                        arr[y+1] = temp;
                    }
                }
            }
        }

    B:选择排序
        把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。

        public static void selectSort(int[] arr) {
            for(int x=0; x&lt;arr.length-1; x++) {
                for(int y=x+1; y&lt;arr.length; y++) {
                    if(arr[y] &lt; arr[x]) {
                        int temp = arr[x];
                        arr[x] = arr[y];
                        arr[y] = temp;
                    }
                }
            }
        }
(2)查找
    A:基本查找
        针对数组无序的情况

        public static int getIndex(int[] arr,int value) {
            int index = -1;

            for(int x=0; x&lt;arr.length; x++) {
                if(arr[x] == value) {
                    index = x;
                    break;
                }
            }

            return index;
        }
    B:二分查找(折半查找)
        针对数组有序的情况(千万不要先排序，在查找)

        public static int binarySearch(int[] arr,int value) {
            int min = 0;
            int max = arr.length-1;
            int mid = (min+max)/2;

            while(arr[mid] != value) {
                if(arr[mid] &gt; value) {
                    max = mid - 1;
                }else if(arr[mid] &lt; value) {
                    min = mid + 1;
                }

                if(min &gt; max) {
                    return -1;
                }

                mid = (min+max)/2;
            }

            return mid;
        }
(3)Arrays工具类
    A:是针对数组进行操作的工具类。包括排序和查找等功能。
    B:要掌握的方法(自己补齐方法)
        把数组转成字符串：
            Arrays.toString();
        排序：
            Arrays.sort();
        二分查找：
            Arrays.binarySearch();
(4)Arrays工具类的源码解析
(5)把字符串中的字符进行排序
    举例：
        &quot;edacbgf&quot;
        得到结果
        &quot;abcdefg&quot;
        String s = &quot;edacbgf&quot;;
        char[] c = s.toCharArray();
        Arrays.sort(c);
        System.out.println(Arrays.toString(c));</code></pre><h2 id="3-Integer-掌握"><a href="#3-Integer-掌握" class="headerlink" title="3. Integer(掌握)"></a>3. Integer(掌握)</h2><pre><code>(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型
    byte         Byte
    short        Short
    int            Integer
    long        Long
    float        Float
    double        Double
    char        Character
    boolean        Boolean
(2)Integer的构造方法
    A:Integer i = new Integer(100);
    B:Integer i = new Integer(&quot;100&quot;);
        注意：这里的字符串必须是由数字字符组成
(3)String和int的相互转换
    A:String -- int
        Integer.parseInt(&quot;100&quot;);
    B:int -- String
        String.valueOf(100);
(4)其他的功能(了解)
    进制转换
        Integer.toBinaryString();
        Integer.toHexString();
        Integer.toOctalString();
(5)JDK5的新特性
    自动装箱    基本类型--引用类型
    自动拆箱    引用类型--基本类型

    把下面的这个代码理解即可：
        Integer i = 100;
        i += 200;
(6)面试题
    -128到127之间的数据缓冲池问题</code></pre><h2 id="4-Character-了解"><a href="#4-Character-了解" class="headerlink" title="4. Character(了解)"></a>4. Character(了解)</h2><pre><code>(1)Character构造方法    
    Character ch = new Character(&apos;a&apos;);
(2)要掌握的方法：(自己补齐)
    A:判断给定的字符是否是大写
        isUpperCase();
    B:判断给定的字符是否是小写
        isLowerCase();
    C:判断给定的字符是否是数字字符
        isDigit();
    D:把给定的字符转成大写
        toUpperCase();
    E:把给定的字符转成小写
        toLowerCase();
(3)案例：

    统计字符串中大写，小写及数字字符出现的次数
        String s = &quot;abcDEF123&quot;;
        char[] c = s.toCharArray();
        int lowerCaseNum = 0;
        int upperCaseNum = 0;
        int digitNum = 0;

        for (char c1 : c) {
            if (Character.isLowerCase(c1)) {
                lowerCaseNum++;
            } else if (Character.isUpperCase(c1)) {
                upperCaseNum++;
            } else if (Character.isDigit(c1)) {
                digitNum++;
            }
        }

        System.out.println(&quot;lowerCase:&quot; + lowerCaseNum + &quot;\t&quot; + &quot;upperCase:&quot; + upperCaseNum + &quot;\t&quot; + &quot;digit:&quot; + digitNum);</code></pre><h2 id="1-正则表达式-理解"><a href="#1-正则表达式-理解" class="headerlink" title="1. 正则表达式(理解)"></a>1. 正则表达式(理解)</h2><pre><code>(1)就是符合一定规则的字符串
(2)常见规则
    A:字符
        x 字符 x。举例：&apos;a&apos;表示字符a
        \\ 反斜线字符。
        \n 新行（换行）符 (&apos;\u000A&apos;) 
        \r 回车符 (&apos;\u000D&apos;)

    B:字符类
        [abc] a、b 或 c（简单类） 
        [^abc] 任何字符，除了 a、b 或 c（否定） 
        [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） 
        [0-9] 0到9的字符都包括

    C:预定义字符类
        . 任何字符。我的就是.字符本身，怎么表示呢? \.
        \d 数字：[0-9]
        \w 单词字符：[a-zA-Z_0-9]
            在正则表达式里面组成单词的东西必须有这些东西组成

    D:边界匹配器
        ^ 行的开头 
        $ 行的结尾 
        \b 单词边界
            就是不是单词字符的地方。
            举例：hello world?haha;xixi

    E:Greedy 数量词 
        X? X，一次或一次也没有
        X* X，零次或多次
        X+ X，一次或多次
        X{n} X，恰好 n 次 
        X{n,} X，至少 n 次 
        X{n,m} X，至少 n 次，但是不超过 m 次 
(3)常见功能：(分别用的是谁呢?)
    A:判断功能
        String类的public boolean matches(String regex)
    B:分割功能
        String类的public String[] split(String regex)
    C:替换功能
        String类的public String replaceAll(String regex,String replacement)
    D:获取功能
        Pattern和Matcher
            Pattern p = Pattern.compile(&quot;a*b&quot;);
            Matcher m = p.matcher(&quot;aaaaab&quot;);

            find():查找存不存在
            group():获取刚才查找过的数据
(4)案例
    A:判断电话号码和邮箱
        //普安段邮箱
        public static boolean checkMail(String s){
            String regex = &quot;\\d*\\w*@sina\\.com&quot;;
            return s.matches(regex);
        }
        //判断电话号码
        public static boolean checkPhoneNum(String s) {
            String regex = &quot;\\d{11}&quot;;
            return s.matches(regex);
        }
    B:按照不同的规则分割数据
        public static String[] split(String s) {
            String regex = &quot;,&quot;;
            String[] result = s.split(regex);
            return result;
        }
    C:把论坛中的数字替换为*
        //替换为和数字等量的*
        public static String replaceStar(String s) {
            String regex = &quot;\\d&quot;;
            return s.replaceAll(regex, &quot;*&quot;);
        }
        //所有相连数字替换为一个*
        public static String replaceStar(String s) {
            String regex = &quot;\\d+&quot;;
            return s.replaceAll(regex, &quot;*&quot;);
        }
    D:获取字符串中由3个字符组成的单词
        public static List&lt;String&gt; method(String s) {
            Pattern p = Pattern.compile(&quot;a\\d{3}b&quot;);
            Matcher m = p.matcher(s);
            List&lt;String&gt; result = new ArrayList&lt;String&gt;();

            while (m.find()) {
                result.add(m.group());
            }
            return  result;
        }</code></pre><h2 id="2-Math-掌握"><a href="#2-Math-掌握" class="headerlink" title="2. Math(掌握)"></a>2. Math(掌握)</h2><pre><code>(1)针对数学运算进行操作的类
(2)常见方法(自己补齐)
    A:绝对值
        Math.abs();
    B:向上取整
        Math.ceil();
    C:向下取整
        Math.floor();
    D:两个数据中的大值
        Math.max();
    E:a的b次幂
        Math.pow(a, b);
    F:随机数
        Math.random();
    G:四舍五入
        Math.round();
    H:正平方根
        Math.sqrt();
(3)案例：
    A:猜数字小游戏
        Scanner sc = new Scanner(System.in);
        int i = (int)(Math.random() * 100) + 1;
        int answer;
        while ((answer = sc.nextInt()) != i) {
            if (answer &gt; i) {
                System.out.println(&quot;bigger than result,go on&quot;);
            } else if (answer &lt; i) {
                System.out.println(&quot;smaller than result,go on&quot;);
            }
        }
        System.out.println(&quot;you are right&quot;);
    B:获取任意范围的随机数
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入起始:&quot;);
        int start = sc.nextInt();
        System.out.println(&quot;请输入结束:&quot;);
        int end = sc.nextInt();

        int i = (int)(Math.random() * (end - start)) + start;
        System.out.println(i);</code></pre><h2 id="3-Random-理解"><a href="#3-Random-理解" class="headerlink" title="3. Random(理解)"></a>3. Random(理解)</h2><pre><code>(1)用于产生随机数的类
(2)构造方法:
    A:Random() 默认种子，每次产生的随机数不同
    B:Random(long seed) 指定种子，每次种子相同，随机数就相同
(3)成员方法:
    A:int nextInt() 返回int范围内的随机数
    B:int nextInt(int n) 返回[0,n)范围内的随机数</code></pre><h2 id="4-System-掌握"><a href="#4-System-掌握" class="headerlink" title="4. System(掌握)"></a>4. System(掌握)</h2><pre><code>(1)系统类,提供了一些有用的字段和方法
(2)成员方法(自己补齐)
    A:运行垃圾回收器
        System.gc();
    B:退出jvm
        System.exit(0);
    C:获取当前时间的毫秒值
        System.currentTimemillis();
    D:数组复制
        System.arraycopy();</code></pre><h2 id="5-BigInteger-理解"><a href="#5-BigInteger-理解" class="headerlink" title="5. BigInteger(理解)"></a>5. BigInteger(理解)</h2><pre><code>(1)针对大整数的运算
(2)构造方法    
    A:BigInteger(String s)
(3)成员方法(自己补齐)
    A:加
        add();
    B:减
        subtract();
    C:乘
        multiply();
    D:除
        divide();
    E:商和余数
        divideAndRemainder();</code></pre><h2 id="6-BigDecimal-理解"><a href="#6-BigDecimal-理解" class="headerlink" title="6. BigDecimal(理解)"></a>6. BigDecimal(理解)</h2><pre><code>(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)
(2)构造方法
    A:BigDecimal(String s)
(3)成员方法：
    A:加
        add();
    B:减
        subtract();
    C:乘
        multiply();
    D:除
        divide();
    E:自己保留小数几位
        setScale();</code></pre><h2 id="7-Date-DateFormat-掌握"><a href="#7-Date-DateFormat-掌握" class="headerlink" title="7. Date/DateFormat(掌握)"></a>7. Date/DateFormat(掌握)</h2><pre><code>(1)Date是日期类，可以精确到毫秒。
    A:构造方法
        Date()
        Date(long time)
    B:成员方法
        getTime()
        setTime(long time)
    C:日期和毫秒值的相互转换
    案例：你来到这个世界多少天了?
(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat
    A:SimpleDateFormat(String pattern) 给定模式
        yyyy-MM-dd HH:mm:ss
    B:日期和字符串的转换
        a:Date -- String
            format()

        b:String -- Date
            parse()
    C:案例：
        制作了一个针对日期操作的工具类。
            Date d = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            System.out.println(sdf.format(d));</code></pre><h2 id="8-Calendar-掌握"><a href="#8-Calendar-掌握" class="headerlink" title="8. Calendar(掌握)"></a>8. Calendar(掌握)</h2><pre><code>(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。
(2)如何得到一个日历对象呢?
    Calendar rightNow = Calendar.getInstance();
    本质返回的是子类对象
(3)成员方法
    A:根据日历字段得到对应的值
        Calendar c =Calendar.getInstance();
        System.out.println(c.get(Calendar.YEAR));
        System.out.println(c.get(Calendar.MONTH));
        System.out.println(c.get(Calendar.DAY_OF_MONTH));
    B:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值
        add(Calendar.DAY_OF_MONTH, +3);
    C:设置日历对象的年月日
        set(2018,5,30);
        set(Calendar.YEAR, 2018);
        set(Calendar.MONTH, 2018);
        set(Calendar.DAY_OF_MONTH, 2018);
(4)案例：
    计算任意一年的2月份有多少天?
        Scanner sc = new Scanner(System.in);
        Calendar c =Calendar.getInstance();

        c.set(Calendar.YEAR, sc.nextInt());
        System.out.println(c.get(Calendar.DAY_OF_MONTH));</code></pre><h1 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h1><h1 id="JavaIO流"><a href="#JavaIO流" class="headerlink" title="JavaIO流"></a>JavaIO流</h1><h2 id="1-异常-理解"><a href="#1-异常-理解" class="headerlink" title="1. 异常(理解)"></a>1. 异常(理解)</h2><pre><code>(1)程序出现的不正常的情况。
(2)异常的体系
    Throwable
        |--Error    严重问题，我们不处理。
        |--Exception
            |--RuntimeException    运行期异常，我们需要修正代码
            |--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过
(3)异常的处理：
    A:JVM的默认处理
        把异常的名称,原因,位置等信息输出在控制台，但是程序不能继续执行了。
    B:自己处理
        a:try...catch...finally
            自己编写处理代码,后面的程序可以继续执行
        b:throws
            把自己处理不了的，在方法上声明，告诉调用者，这里有问题
(4)面试题
    A:编译期异常和运行期异常的区别?
        编译期异常 必须要处理的，否则编译不通过
        运行期异常 可以不处理，也可以处理
    B:throw和throws是的区别
        throw:
            在方法体中,后面跟的是异常对象名,并且只能是一个
            throw抛出的是一个异常对象，说明这里肯定有一个异常产生了
        throws:
            在方法声明上,后面跟的是异常的类名,可以是多个
            throws是声明方法有异常，是一种可能性，这个异常并不一定会产生
(5)finally关键字及其面试题
    A:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了
    B:面试题
        a:final,finally,finalize的区别?
            final : 关键字,修饰类、方法、变量,被修饰的类无法被继承,方法无法重写,变量值不能改变.
            finally : try...catch...finally,一定会执行.
            finalize : 对象被垃圾回收器回收时执行的方法.
        b:如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后
            会，前。

            实际上在中间。这个上课我们讲过
    C:异常处理的变形
        try...catch...finally
        try...catch...
        try...catch...catch...
        try...catch...catch...fianlly
        try...finally
(6)自定义异常
    继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可
        public class MyException extends RuntimeException {
            public MyException(String message) {
                super(message);
            }

            public MyException() {
                super();
            }
        }
(7)异常的注意实现
    A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 
    B:父的方法没有异常抛出,子的重写方法不能有异常抛出
    C:父的方法抛出多个异常,子的重写方法必须比父少或者小</code></pre><h2 id="2-File-掌握"><a href="#2-File-掌握" class="headerlink" title="2. File(掌握)"></a>2. File(掌握)</h2><pre><code>(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件
(2)构造方法
    A:File file = new File(&quot;e:\\demo\\a.txt&quot;);
    B:File file = new File(&quot;e:\\demo&quot;,&quot;a.txt&quot;);
    C:File file = new File(&quot;e:\\demo&quot;);
      File file2 = new File(file,&quot;a.txt&quot;);
(3)File类的功能(自己补齐)
    A:创建功能
        createNewFile();
        mkdir();
        mkdirs();
    B:删除功能
        delete();
    C:重命名功能
        renameTo();
    D:判断功能
        isFile();
        isDirectory();
        exists();
        canRea();
        canWrite();
        isAbsolute();
        isHidden();
    E:获取功能
        getAbsoluteFile();
        getAbsolutePath();
        getPath();
        getParent();
        getParentFile();
        getName();
        length();
        lastModified();
    F:高级获取功能
        list();
        listFiles();
    G:过滤器功能
        list(FilenameFilter filter);
            String[] s = file1.list(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return new File(dir, name).isFile() &amp;&amp; name.endsWith(&quot;.jpg&quot;);
            }
        });
        listFiles(FilenameFilter filter);
(4)案例：
    A:输出指定目录下指定后缀名的文件名称
        a:先获取所有的，在遍历的时候判断，再输出
            File file = new File(&quot;D:\\Movie\\M&quot;);
            String[] s = file.list();

            for (String result : s) {
                if (result.endsWith(&quot;.mp4&quot;)) {
                    System.out.println(result);
                }
            }
        b:先判断，再获取，最后直接遍历输出即可
            String[] s1 = file.list(new FilenameFilter() {
                @Override
                public boolean accept(File dir, String name) {
                    return name.endsWith(&quot;.mp4&quot;);
                }
            });
            for (String result : s1) {
                System.out.println(result);
            }
    B:批量修改文件名称
        File file = new File(&quot;D:\\Movie&quot;);
        String[] s = file.list(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.startsWith(&quot;相对宇宙&quot;);
            }
        });
        for (String result : s) {
            System.out.println(&quot;beforeRename : &quot; + result);
            File file1 = new File(file,result.replaceAll(&quot;WEB.*影视\\.&quot;, &quot;&quot;));
            File file2 = new File(file, result);
            file2.renameTo(file1);
            System.out.println(&quot;afterRename : &quot; + file1.exists() + &quot;, &quot; + file1.getName());
        }
        ## 1. 递归(理解)

(1)方法定义中调用方法本身的现象
    举例：老和尚给小和尚讲故事，我们学编程
(2)递归的注意事项；
    A:要有出口，否则就是死递归
    B:次数不能过多，否则内存溢出
    C:构造方法不能递归使用
(3)递归的案例：
    A:递归求阶乘
        public static int method(int i) {
            while (i &gt; 1) {
                return i * method(--i);
            }
            return 1;
        }
    B:兔子问题
    C:递归输出指定目录下所有指定后缀名的文件绝对路径
        public static void method(File filePath, String suffix) {
            File[] files = filePath.listFiles();
            for (File file : files) {
                if (file.isDirectory()) {
                    method(file, suffix);
                } else if (file.getName().endsWith(suffix)){
                    System.out.println(file.getName());
                }
            }
        }
    D:递归删除带内容的目录(小心使用)
        public static void method(File filePath) {
            File[] files = filePath.listFiles();
            for (File file : files) {
                if (file.isDirectory()) {
                    method(file);
                } else {
                    file.delete();
                }
            }
            filePath.delete();
        }</code></pre><h2 id="2-IO流-掌握"><a href="#2-IO流-掌握" class="headerlink" title="2. IO流(掌握)"></a>2. IO流(掌握)</h2><pre><code>(1)IO用于在设备间进行数据传输的操作    
(2)分类：
    A:流向
        输入流    读取数据
        输出流    写出数据
    B:数据类型
        字节流    
                字节输入流
                字节输出流
        字符流
                字符输入流
                字符输出流
    注意：
        a:如果我们没有明确说明按照什么分，默认按照数据类型分。
        b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。
(3)FileOutputStream写出数据
    A:操作步骤
        a:创建字节输出流对象
        b:调用write()方法
        c:释放资源

    B:代码体现：
        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);

        fos.write(&quot;hello&quot;.getBytes());

        fos.close();

    C:要注意的问题?
        a:创建字节输出流对象做了几件事情?
            调用系统功能去创建文件
            创建fos对象
            把fos对象指向这个文件
        b:为什么要close()?
            关闭此文件输出流并释放与此流有关的所有系统资源。
        c:如何实现数据的换行?
            windows:\r\n
            linux:\n
            Mac:\r
        d:如何实现数据的追加写入?
            FileOutputStream fos = new FileOutputStream(&quot;F:\\&quot;, true);
(4)FileInputStream读取数据
    A:操作步骤
        a:创建字节输入流对象
        b:调用read()方法
        c:释放资源

    B:代码体现：
        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);

        //方式1
        int by = 0;
        while((by=fis.read())!=-1) {
            System.out.print((char)by);
        }

        //方式2
        byte[] bys = new byte[1024];
        int len = 0;
        while((len=fis.read(bys))!=-1) {
            System.out.print(new String(bys,0,len));
        }

        fis.close();
(5)案例：2种实现
    A:复制文本文件
        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;);
        //方式一
        int i = 0;
        while ((i = fis.read()) != -1) {
            fos.write(i);
        }
        fis.close();
        fos.close();
        //方式二
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fis.read(bytes)) != -1) {
            fos.write(bytes, 0, len);
        }
        fis.close();
        fos.close();
    B:复制图片
        FileInputStream fis = new FileInputStream(&quot;a.jpg&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;b.jpg&quot;);
        //方式一
        int i = 0;
        while ((i = fis.read()) != -1) {
            fos.write(i);
        }
        fis.close();
        fos.close();
        //方式二
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fis.read(bytes)) != -1) {
            fos.write(bytes, 0, len);
        }
        fis.close();
        fos.close();
    C:复制视频
        FileInputStream fis = new FileInputStream(&quot;a.mp4&quot;);
        FileOutputStream fos = new FileOutputStream(&quot;b.mp4&quot;);
        //方式一
        int i = 0;
        while ((i = fis.read()) != -1) {
            fos.write(i);
        }
        fis.close();
        fos.close();
        //方式二
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fis.read(bytes)) != -1) {
            fos.write(bytes, 0, len);
        }
        fis.close();
        fos.close();
(6)字节缓冲区流
    A:BufferedOutputStream
    B:BufferedInputStream
(7)案例：4种实现
    A:复制文本文件
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.txt&quot;));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;));

        //方式三
        int i = 0;
        while ((i = bis.read()) != -1) {
            bos.write(i);
        }
        fis.close();
        fos.close();
        //方式四
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = bis.read()) != -1) {
            bos.write(bytes, 0, len);
        }
        fis.close();
        fos.close();
    B:复制图片
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.jpg&quot;));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.jpg&quot;));

        //方式三
        int i = 0;
        while ((i = bis.read()) != -1) {
            bos.write(i);
        }
        fis.close();
        fos.close();
        //方式四
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = bis.read()) != -1) {
            bos.write(bytes, 0, len);
        }
        fis.close();
        fos.close();
    C:复制视频
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.mp4&quot;));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.mp4&quot;));

        //方式三
        int i = 0;
        while ((i = bis.read()) != -1) {
            bos.write(i);
        }
        fis.close();
        fos.close();
        //方式四
        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = bis.read()) != -1) {
            bos.write(bytes, 0, len);
        }
        fis.close();
        fos.close();</code></pre><h2 id="3-自学字符流"><a href="#3-自学字符流" class="headerlink" title="3. 自学字符流"></a>3. 自学字符流</h2><pre><code>IO流分类
    字节流：
        InputStream
            FileInputStream
            BufferedInputStream
        OutputStream
            FileOutputStream
            BufferedOutputStream

    字符流：
        Reader
            FileReader
            BufferedReader
        Writer
            FileWriter
            BufferedWriter</code></pre><h2 id="1-字符流-掌握"><a href="#1-字符流-掌握" class="headerlink" title="1. 字符流(掌握)"></a>1. 字符流(掌握)</h2><pre><code>(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。
   转换流的作用就是把字节流转换字符流来使用。
(2)转换流其实是一个字符流
    字符流 = 字节流 + 编码表
(3)编码表
    A:就是由字符和对应的数值组成的一张表
    B:常见的编码表
        ASCII
        ISO-8859-1
        GB2312
        GBK
        GB18030
        UTF-8
    C:字符串中的编码问题
        编码
            String -- byte[]
        解码
            byte[] -- String
(4)IO流中的编码问题
    A:OutputStreamWriter
        OutputStreamWriter(OutputStream os):默认编码，GBK
        OutputStreamWriter(OutputStream os,String charsetName):指定编码。
    B:InputStreamReader
        InputStreamReader(InputStream is):默认编码，GBK
        InputStreamReader(InputStream is,String charsetName):指定编码
    C:编码问题其实很简单
        编码只要一致即可
(5)字符流
    Reader
        |--InputStreamReader
            |--FileReader
        |--BufferedReader
    Writer
        |--OutputStreamWriter
            |--FileWriter
        |--BufferedWriter
(6)复制文本文件(5种方式)
    public class CopyDemo {
    public static void main(String[] args) throws IOException {
        File srcFile = new File(&quot;a.txt&quot;);
        File destFile = new File(&quot;b.txt&quot;);

        method1(srcFile, destFile);
        method2(srcFile, destFile);
        method3(srcFile, destFile);
        method4(srcFile, destFile);
        method5(srcFile, destFile);
    }

    private static void method5(File srcFile, File destFile) throws IOException{
        BufferedReader br = new BufferedReader(new FileReader(srcFile));
        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));

        String s = null;
        while ((s = br.readLine()) != null) {
            bw.write(s);
        }
        br.close();
        bw.close();
    }

    private static void method4(File srcFile, File destFile) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(srcFile));
        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));

        int len = 0;
        char[] chars = new char[1024];
        while ((len = br.read(chars)) != -1) {
            bw.write(chars, 0, len);
        }
        br.close();
        bw.close();
    }

    private static void method3(File srcFile, File destFile) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(srcFile));
        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));

        int by = 0;
        while ((by = br.read()) != -1) {
            bw.write(by);
        }
        br.close();
        bw.close();
    }

    private static void method2(File srcFile, File destFile) throws IOException {
        FileReader fr = new FileReader(srcFile);
        FileWriter fw = new FileWriter(destFile);

        int len = 0;
        char[] bytes = new char[1024];
        while ((len = fr.read(bytes)) != -1) {
            fw.write(bytes, 0, len);
        }
        fr.close();
        fw.close();
    }

    private static void method1(File srcFile, File destFile) throws IOException {
        FileReader fr = new FileReader(srcFile);
        FileWriter fw = new FileWriter(destFile);

        int by = 0;
        while ((by = fr.read()) != -1) {
            fw.write(by);
        }
        fr.close();
        fw.close();
    }
}                                                </code></pre><h2 id="2-IO流小结-掌握"><a href="#2-IO流小结-掌握" class="headerlink" title="2. IO流小结(掌握)"></a>2. IO流小结(掌握)</h2><pre><code>IO流
    |--字节流
        |--字节输入流
            InputStream
                int read():一次读取一个字节
                int read(byte[] bys):一次读取一个字节数组

                |--FileInputStream
                |--BufferedInputStream
        |--字节输出流
            OutputStream
                void write(int by):一次写一个字节
                void write(byte[] bys,int index,int len):一次写一个字节数组的一部分

                |--FileOutputStream
                |--BufferedOutputStream
    |--字符流
        |--字符输入流
            Reader
                int read():一次读取一个字符
                int read(char[] chs):一次读取一个字符数组

                |--InputStreamReader
                    |--FileReader
                |--BufferedReader
                    String readLine():一次读取一个字符串
        |--字符输出流
            Writer
                void write(int ch):一次写一个字符
                void write(char[] chs,int index,int len):一次写一个字符数组的一部分

                |--OutputStreamWriter
                    |--FileWriter
                |--BufferedWriter
                    void newLine():写一个换行符

                    void write(String line):一次写一个字符串</code></pre><h2 id="3-案例-理解-练习一遍"><a href="#3-案例-理解-练习一遍" class="headerlink" title="3. 案例(理解 练习一遍)"></a>3. 案例(理解 练习一遍)</h2><pre><code>A:复制文本文件 5种方式(掌握)
    private static void method5(File srcFile, File destFile) throws IOException{
        BufferedReader br = new BufferedReader(new FileReader(srcFile));
        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));

        String s = null;
        while ((s = br.readLine()) != null) {
            bw.write(s);
        }
        br.close();
        bw.close();
    }

    private static void method4(File srcFile, File destFile) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(srcFile));
        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));

        int len = 0;
        char[] chars = new char[1024];
        while ((len = br.read(chars)) != -1) {
            bw.write(chars, 0, len);
        }
        br.close();
        bw.close();
    }

    private static void method3(File srcFile, File destFile) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(srcFile));
        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));

        int by = 0;
        while ((by = br.read()) != -1) {
            bw.write(by);
        }
        br.close();
        bw.close();
    }

    private static void method2(File srcFile, File destFile) throws IOException {
        FileReader fr = new FileReader(srcFile);
        FileWriter fw = new FileWriter(destFile);

        int len = 0;
        char[] bytes = new char[1024];
        while ((len = fr.read(bytes)) != -1) {
            fw.write(bytes, 0, len);
        }
        fr.close();
        fw.close();
    }

    private static void method1(File srcFile, File destFile) throws IOException {
        FileReader fr = new FileReader(srcFile);
        FileWriter fw = new FileWriter(destFile);

        int by = 0;
        while ((by = fr.read()) != -1) {
            fw.write(by);
        }
        fr.close();
        fw.close();
    }
B:复制图片(二进制流数据) 4种方式(掌握)
    private static void method4(File srcFile, File destFile) throws IOException{
        BufferedInputStream bis = new BufferedInputStream(
            new FileInputStream(srcFile));
        BufferedOutputStream bos = new BufferedOutputStream(
            new FileOutputStream(destFile));

        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = bis.read()) != -1) {
            bos.write(bytes, 0, len);
        }
        bis.close();
        bos.close();
    }

    private static void method3(File srcFile, File destFile) throws IOException{
        BufferedInputStream bis = new BufferedInputStream(
            new FileInputStream(srcFile));
        BufferedOutputStream bos = new BufferedOutputStream(
            new FileOutputStream(destFile));

        int by = 0;
        while ((by = bis.read()) != -1) {
            bos.write(by);
        }
        bis.close();
        bos.close();
    }

    private static void method2(File srcFile, File destFile) throws IOException{
        FileInputStream fis = new FileInputStream(srcFile);
        FileOutputStream fos = new FileOutputStream(destFile);

        int len = 0;
        byte[] bytes = new byte[1024];
        while ((len = fis.read(bytes)) != -1) {
            fos.write(bytes,0,len);
        }
        fis.close();
        fos.close();
    }

    private static void method1(File srcFile, File destFile) throws IOException{
        FileInputStream fis = new FileInputStream(srcFile);
        FileOutputStream fos = new FileOutputStream(destFile);

        int by = 0;
        while ((by = fis.read()) != -1) {
            fos.write(by);
        }
        fis.close();
        fos.close();
    }
C:把集合中的数据存储到文本文件
    File srcFile = new File(&quot;a.txt&quot;);
    List&lt;String&gt; list = new ArrayList&lt;String&gt;();

    list.add(&quot;hello&quot;);
    list.add(&quot;world&quot;);
    list.add(&quot;java&quot;);
    //方式一
    FileOutputStream fos = new FileOutputStream(srcFile);
    for (String s : list) {
        fos.write((s).getBytes());
    }
    fos.close();
    //方式二
    FileWriter fw = new FileWriter(srcFile);
    for (String s : list) {
        fw.write(s.toCharArray());
        fw.flush();
    }
    fw.close();
    //方式三
    BufferedWriter bw = new BufferedWriter(new FileWriter(srcFile));
    for (String s : list) {
        bw.write(s);
        bw.flush();
    }
    bw.close();
D:把文本文件中的数据读取到集合并遍历集合
    File srcFile = new File(&quot;a.txt&quot;);
    List&lt;String&gt; list = new ArrayList&lt;String&gt;();

    BufferedReader br = new BufferedReader(new FileReader(srcFile));
    String s = null;
    while ((s = br.readLine()) != null) {
        list.add(s);
    }
    br.close();
E:复制单级文件夹
    File srcPath = new File(&quot;F:\\struts-1.2.7&quot;);
    File destPath = new File(&quot;F:\\test1&quot;);

    File[] srcFiles = srcPath.listFiles();
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    if (!destPath.exists()) {
        destPath.mkdir();
    }
    for (File srcFile : srcFiles) {
        if (srcFile.isFile()) {
             bis = new BufferedInputStream(new FileInputStream(srcFile));
             bos = new BufferedOutputStream(
                 new FileOutputStream(new File(destPath,srcFile.getName())));
            int len = 0;
            byte[] bytes = new byte[1024];
            while ((len = bis.read(bytes)) != -1) {
                bos.write(bytes, 0, len);
                bos.flush();
            }
        }
    }
    bis.close();
    bos.close();
F:复制单级文件夹中指定的文件
    File srcPath = new File(&quot;F:\\test&quot;);
    File destPath = new File(&quot;F:\\test1&quot;);

    File[] srcFiles = srcPath.listFiles(new FilenameFilter(){

        @Override
        public boolean accept(File dir, String name) {
            return dir.isFile()&amp;&amp;name.endsWith(&quot;.java&quot;);
        }
    });
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    if (!destPath.exists()) {
        destPath.mkdir();
    }
    for (File srcFile : srcFiles) {
        if (srcFile.isFile()) {
             bis = new BufferedInputStream(new FileInputStream(srcFile));
             bos = new BufferedOutputStream(
                 new FileOutputStream(new File(destPath,srcFile.getName())));
            int len = 0;
            byte[] bytes = new byte[1024];
            while ((len = bis.read(bytes)) != -1) {
                bos.write(bytes, 0, len);
                bos.flush();
            }
        }
    }
    bis.close();
    bos.close();
G:复制多级文件夹
    public class CopyDemo {
    public static void main(String[] args) throws IOException {
        File srcPath = new File(&quot;F:\\test&quot;);
        File destPath = new File(&quot;F:\\test1&quot;);

        copyFolder(srcPath,destPath);

    }

    public static void copyFolder(File srcPath, File destPath) throws IOException{
        if (!destPath.exists()) {
            destPath.mkdir();
        }
        File[] files = srcPath.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {

                copyFolder(file,new File(destPath,file.getName()));
            } else if (file.isFile()) {
                BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));
                BufferedOutputStream bos = new BufferedOutputStream(
                    new FileOutputStream(new File(destPath,file.getName())));
                int len = 0;
                byte[] bytes = new byte[1024];
                while ((len = bis.read(bytes)) != -1) {
                    bos.write(bytes,0,len);
                    bos.flush();
                }
                bis.close();
                bos.close();
            }
        }

    }

}
H:键盘录入学生信息按照总分从高到低存储到文本文件
    public class CopyDemo {
        public static void main(String[] args) throws IOException {
            Scanner sc = new Scanner(System.in);
            //比较器返回-1降序，返回1升序
            TreeSet&lt;Student&gt; studentList = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() {
                @Override
                public int compare(Student o1, Student o2) {
                    int sum1 = o1.getChinese() + o1.getEnglish() + o1.getMath();
                    int sum2 = o2.getChinese() + o2.getEnglish() + o2.getMath();
                    if (sum1 &gt; sum2) {
                        return -1;
                    } else if (sum1 == sum2) {
                        if (o1.getName().compareTo(o2.getName()) &gt;=0 ) {
                            return -1;
                        } else {
                            return 1;
                        }
                    } else {
                        return 1;
                    }
                }
            });
            for (int i = 0; i &lt; 3; i++) {
                Student st = new Student();
                System.out.println(&quot;请输入学生信息:&quot;);
                System.out.println(&quot;姓名: &quot;);
                st.setName(sc.nextLine());
                System.out.println(&quot;语文: &quot;);
                st.setChinese(Integer.valueOf(sc.nextLine()));
                System.out.println(&quot;数学: &quot;);
                st.setEnglish(Integer.valueOf(sc.nextLine()));
                System.out.println(&quot;英语: &quot;);
                st.setMath(Integer.valueOf(sc.nextLine()));
                studentList.add(st);
            }
            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;a.txt&quot;)));
            for (Student student : studentList) {
                bw.write(&quot;name: &quot; + student.getName());
                bw.newLine();
                bw.write(&quot;chinese: &quot;+student.getChinese());
                bw.newLine();
                bw.write(&quot;english: &quot; + student.getEnglish());
                bw.newLine();
                bw.write(&quot;math: &quot;+student.getMath());
                bw.newLine();
                bw.write(&quot;---------------------&quot;);
                bw.newLine();
                bw.flush();
            }
            bw.close();
        }
}

class Student {
    private String name;
    private int chinese;
    private int math;
    private int english;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getChinese() {
        return chinese;
    }

    public void setChinese(int chinese) {
        this.chinese = chinese;
    }

    public int getMath() {
        return math;
    }

    public void setMath(int math) {
        this.math = math;
    }

    public int getEnglish() {
        return english;
    }

    public void setEnglish(int english) {
        this.english = english;
    }
}
I:把某个文件中的字符串排序后输出到另一个文本文件中
    File srcFile = new File(&quot;a.txt&quot;);
    File destFile = new File(&quot;b.txt&quot;);

    BufferedReader br = new BufferedReader(new FileReader(srcFile));
    BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));

    StringBuilder sb = new StringBuilder();
    String s = null;
    while ((s = br.readLine()) != null) {
        sb.append(s);
    }
    char[] ch = sb.toString().toCharArray();
    Arrays.sort(ch);
    bw.write(ch);
    bw.close();
    br.close();
J:用Reader模拟BufferedReader的特有功能
K:模拟LineNumberReader的特有功能</code></pre><h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-多线程-理解"><a href="#1-多线程-理解" class="headerlink" title="1. 多线程(理解)"></a>1. 多线程(理解)</h2><pre><code>(1)多线程：一个应用程序有多条执行路径
    进程：正在执行的应用程序
    线程：进程的执行单元，执行路径
    单线程：一个应用程序只有一条执行路径
    多线程：一个应用程序有多条执行路径

    多进程的意义?
        提高CPU的使用率
    多线程的意义?
        提高应用程序的使用率
(2)Java程序的运行原理及JVM的启动是多线程的吗?
    A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。
    B:JVM的启动是多线程的，因为它至少有两个线程启动了，主线程和垃圾回收线程。
(3)多线程的实现方案(自己补齐步骤及代码    掌握)
    A:继承Thread类
    public class MyThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(getName() + &quot;:&quot; + i);
            }
        }

        public static class MyThreadTest {
            public static void main(String[] args) {
                MyThread mt = new MyThread();
                mt.start();
            }
        }
    }
    B:实现Runnable接口
    public class MyRunnable implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i &lt; 10; i++) {
                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);
            }
        }

        public static class MyRunnableTest {
            public static void main(String[] args) {
                MyRunnable mr = new MyRunnable();
                Thread td = new Thread(mr);

                td.start();
            }
        }
    }
(4)线程的调度和优先级问题
    A:线程的调度
        a:分时调度
        b:抢占式调度 (Java采用的是该调度方式)
    B:获取和设置线程优先级
        a:默认是5
        b:范围是1-10（Thread.MIN_PRIORITY，Thread.MAX_PRIORITY）
(5)线程的控制(常见方法)
    A:休眠线程：sleep()
    B:加入线程：join()
    C:礼让线程：yield()
    D:后台线程：setDaemon()
    E:终止线程(掌握)：interrupt()
(6)线程的生命周期(参照    线程生命周期图解.bmp)
    A:新建
    B:就绪
    C:运行
    D:阻塞
    E:死亡</code></pre><p><img src="https://img-blog.csdn.net/20181003115703845?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="线程生命周期图解"></p>
<pre><code>(7)电影院卖票程序的实现
    A:继承Thread类
    public class ThreadTicket extends Thread {
        private static int ticket = 100;

        @Override
        public void run() {
           while (true) {
                if (ticket &gt; 0) {
                    System.out.println(getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);
                }
            }
        }

        public static class ThreadTicketTest {
            public static void main(String[] args) {
                ThreadTicket threadTicket = new ThreadTicket();
                ThreadTicket threadTicket1 = new ThreadTicket();
                ThreadTicket threadTicket2 = new ThreadTicket();

                threadTicket.start();
                threadTicket1.start();
                threadTicket2.start();
            }
        }
    }
    B:实现Runnable接口
    public class RunnableTicket implements Runnable {
        private int ticket = 100;

        @Override
        public void run() {
            while (true) {
                if (ticket &gt; 0) {
                    System.out.println(getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);
                }
            }
        }

        public static class RunnableTicketTest {
            public static void main(String[] args) {
                RunnableTicket rt = new RunnableTicket();
                Thread thread = new Thread(rt);
                Thread thread1 = new Thread(rt);
                Thread thread2 = new Thread(rt);

                thread.start();
                thread1.start();
                thread2.start();
            }
        }
    }
(8)电影院卖票程序出问题
    A:为了更符合真实的场景，加入了休眠100毫秒。
    B:卖票问题
        a:同票多次
        b:负数票
(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)
    A:是否有多线程环境
    B:是否有共享数据
    C:是否有多条语句操作共享数据
(10)同步解决线程安全问题
    A:同步代码块
        synchronized(对象) {
            需要被同步的代码;
        }

        这里的锁对象可以是任意对象。

    B:同步方法
        把同步加在方法上。

        这里的锁对象是this

    C:静态同步方法
        把同步加在方法上。

        这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)
(11)回顾以前的线程安全的类
    A:StringBuffer
    B:Vector
    C:Hashtable
    D:如何把一个线程不安全的集合类变成一个线程安全的集合类
        用Collections工具类的方法即可。
        List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></pre><h2 id="1-多线程-理解-1"><a href="#1-多线程-理解-1" class="headerlink" title="1. 多线程(理解)"></a>1. 多线程(理解)</h2><pre><code>(1)JDK5以后的针对线程的锁定操作和释放操作
    Lock锁
    public class RunnableTicket implements Runnable {
        private int ticket = 100;
        private ReentrantLock lock = new ReentrantLock();

        @Override
        public void run() {
            while (true) {
                lock.lock();
                if (ticket &gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                lock.unlock();
            }
        }

        public static class RunnableTicketTest {
            public static void main(String[] args) {
                RunnableTicket rt = new RunnableTicket();
                Thread thread = new Thread(rt);
                Thread thread1 = new Thread(rt);
                Thread thread2 = new Thread(rt);

                thread.start();
                thread1.start();
                thread2.start();
            }
        }
    }
(2)死锁问题的描述和代码体现
public class DeadLockDemo implements Runnable {
        boolean flag;

        @Override
        public void run() {
            if (flag) {
                synchronized (Lock.object1) {
                    System.out.println(Thread.currentThread().getName() + &quot;获取了锁object1&quot;);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (Lock.object2) {
                        System.out.println(Thread.currentThread().getName() + &quot;获取了锁object2&quot;);
                    }
                }
            } else {
                synchronized (Lock.object2) {
                    System.out.println(Thread.currentThread().getName() + &quot;获取了锁object2&quot;);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (Lock.object1) {
                        System.out.println(Thread.currentThread().getName() + &quot;获取了锁object1&quot;);
                    }
                }
            }
        }

        public static void main(String[] args) {
            DeadLockDemo lockDemo = new DeadLockDemo();
            DeadLockDemo lockDemo1 = new DeadLockDemo();
            lockDemo.flag = true;
            Thread td1 = new Thread(lockDemo);
            Thread td2 = new Thread(lockDemo1);

            td1.start();
            td2.start();
        }
    }

    class Lock {
        public static Object object1 = new Object();
        public static Object object2 = new Object();
    }
(3)生产者和消费者多线程体现(线程间通信问题)
    以学生作为资源来实现的

    资源类：Student
    设置数据类：SetThread(生产者)
    获取数据类：GetThread(消费者)
    测试类：StudentDemo

    代码：
        A:最基本的版本，只有一个数据。

            public class ThreadDemo {
                public static void main(String[] args) {
                    Student student = new Student();
                    SetThread st = new SetThread(student);
                    GetThread gt = new GetThread(student);

                    new Thread(st).start();
                    new Thread(gt).start();
                }
            }

            class Student {
                String name;
                int age;
            }

            class SetThread implements Runnable {
                private Student student;

                public SetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    student.name = &quot;xmos&quot;;
                    student.age = 23;
                }
            }

            class GetThread implements Runnable {
                private Student student;

                public GetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    for (int i = 0; i &lt; 100; i++) {
                        System.out.println(student.name + &quot;:&quot; + student.age);
                    }
                }
            }
        B:改进版本，给出了不同的数据，并加入了同步机制
            public class ThreadDemo {
                public static void main(String[] args) {
                    Student student = new Student();
                    GetThread gt = new GetThread(student);
                    SetThread st = new SetThread(student);

                    new Thread(gt).start();
                    new Thread(st).start();
                }
            }

            class Student {
                String name;
                int age;
            }

            class SetThread implements Runnable {
                private Student student;
                private int x;

                public SetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    while (true) {
                        synchronized (student) {
                            if (x % 2 == 0) {
                                student.name = &quot;xmos&quot;;
                                student.age = 23;
                            } else {
                                student.name = &quot;tmos&quot;;
                                student.age = 22;
                            }

                            x++;
                        }
                    }
                }
            }

            class GetThread implements Runnable {
                private Student student;

                public GetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    for (int i = 0; i &lt; 100; i++) {
                        synchronized (student) {
                            System.out.println(student.name + &quot;:&quot; + student.age);
                        }

                    }
                }
            }
        C:等待唤醒机制改进该程序，让数据能够实现依次的出现
            wait()
            notify()
            notifyAll() (多生产多消费)

            public class ThreadDemo {
                public static void main(String[] args) {
                    Student student = new Student();
                    GetThread gt = new GetThread(student);
                    SetThread st = new SetThread(student);

                    new Thread(gt).start();
                    new Thread(st).start();
                }
            }

            class Student {
                String name;
                int age;
                boolean flag;
            }

            class SetThread implements Runnable {
                private Student student;
                private int x;

                public SetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    while (true) {
                        synchronized (student) {
                            if (student.flag) {
                                try {
                                    student.wait();
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }
                            if (x % 2 == 0) {
                                student.name = &quot;xmos&quot;;
                                student.age = 23;
                            } else {
                                student.name = &quot;tmos&quot;;
                                student.age = 22;
                            }
                            x++;
                            student.flag = true;
                            student.notify();
                        }
                    }
                }
            }

            class GetThread implements Runnable {
                private Student student;

                public GetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    for (int i = 0; i &lt; 100; i++) {
                        synchronized (student) {
                            if (!student.flag) {
                                try {
                                    student.wait();
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }
                            System.out.println(student.name + &quot;:&quot; + student.age);
                            student.flag = false;
                            student.notify();
                        }
                    }
                }
            }
        D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中
            public class ThreadDemo {
                public static void main(String[] args) {
                    Student student = new Student();
                    GetThread gt = new GetThread(student);
                    SetThread st = new SetThread(student);

                    new Thread(gt).start();
                    new Thread(st).start();
                }
            }

            class Student {
                private String name;
                private int age;
                private int x;
                private boolean flag;

                synchronized void setStudent() {
                    while (true) {
                        if (flag) {
                            try {
                                wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        if (x % 2 == 0) {
                            name = &quot;xmos&quot;;
                            age = 23;
                        } else {
                            name = &quot;tmos&quot;;
                            age = 22;
                        }
                        x++;
                        flag = true;
                        notify();
                    }
                }

                synchronized void getStudent() {
                    for (int i = 0; i &lt; 100; i++) {
                        if (!flag) {
                            try {
                                wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        System.out.println(name + &quot;:&quot; + age);
                        flag = false;
                        notify();
                    }
                }
            }

            class SetThread implements Runnable {
                private Student student;

                public SetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    student.setStudent();
                }
            }

            class GetThread implements Runnable {
                private Student student;

                public GetThread(Student student) {
                    this.student = student;
                }

                @Override
                public void run() {
                    student.getStudent();
                }
            }
(4)线程组
    public class ThreadGroupDemo {
       public static void main(String[] args) {
            ThreadGroup tg = new ThreadGroup(&quot;MyThreadGroup&quot;);
            MyRunnable mr = new MyRunnable();
            Thread th1 = new Thread(tg, mr, &quot;xmos&quot;);
            Thread th2 = new Thread(tg, mr, &quot;tmos&quot;);

            th1.start();
            th2.start();

        }
    }

    class MyRunnable implements Runnable {

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getThreadGroup().getName() + &quot;:&quot; 
                + Thread.currentThread().getName());
        }
    }
    (5)线程池
        public class ThreadPoolDemo {
            public static void main(String[] args) {
                ExecutorService pool = Executors.newFixedThreadPool(3);
                MyRunnable mr = new MyRunnable();
                pool.submit(mr);
                pool.submit(mr);

                pool.shutdown();
            }
        }

        class MyRunnable implements Runnable{

            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        }
(6)多线程实现的第三种方案
    public class ThreadPoolDemo {
        public static void main(String[] args) {
            ExecutorService pool = Executors.newFixedThreadPool(3);
            MyCallable mc = new MyCallable();
            pool.submit(mc);
            pool.submit(mc);

            pool.shutdown();
        }
    }

    class MyCallable implements Callable {
        @Override
        public Object call() throws Exception {
            System.out.println(Thread.currentThread().getName());
            return null;
        }
    }
(7)定时器
    案例1：
        public class TimerDemo {
            public static void main(String[] args) throws ParseException {
                Timer t = new Timer();
                String s = new String(&quot;2018-10-03 12:46:00&quot;);
                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
                Date date = sdf.parse(s);
                t.schedule(new Boom(), date, 100);

                t.cancel();</code></pre><p>​<br>                }<br>            }</p>
<pre><code>    class Boom extends TimerTask {

        @Override
        public void run() {
            System.out.println(&quot;Boom!&quot;);
        }
    }
    案例2：
        public class TimerDemo {
            public static void main(String[] args) throws ParseException {
                Timer t = new Timer();
                t.schedule(new Boom(t), 300, 100);
            }
        }

        class Boom extends TimerTask {
            private Timer t;
            int i = 0;

            public Boom(Timer t) {
                this.t = t;
            }

            @Override
            public void run() {
                System.out.println(&quot;Boom---&quot; + ++i);

                if (i == 30) {
                    t.cancel();
                }
            }
        }
(8)多线程的面试题
    ## 1. 多线程有几种实现方案，分别是哪几种?
    两种。

    继承Thread类
    实现Runnable接口

    扩展一种：实现Callable接口。这个得和线程池结合。

    ## 2. 同步有几种方式，分别是什么?
        两种。

        同步代码块
        同步方法

    ## 3. 启动一个线程是run()还是start()?它们的区别?
        start();

        run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用
        start():启动线程，并由JVM自动调用run()方法

    ## 4. sleep()和wait()方法的区别
        sleep():必须指时间;不释放锁。
        wait():可以不指定时间，也可以指定时间;释放锁。

    ## 5. 为什么wait(),notify(),notifyAll()等方法都定义在Object类中
        因为这些方法的调用是依赖于锁对象的，而同步代码块的锁对象是任意锁。
        而Object代码任意的对象，所以，定义在这里面。

    ## 6. 线程的生命周期图
        新建 -- 就绪 -- 运行 -- 死亡
        新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡
        建议：画图解释。</code></pre><h2 id="2-设计模式-理解"><a href="#2-设计模式-理解" class="headerlink" title="2. 设计模式(理解)"></a>2. 设计模式(理解)</h2><pre><code>(1)面试对象的常见设计原则
    单一
    开闭
    里氏
    依赖注入
    接口
    迪米特
(2)设计模式概述和分类
    A:经验的总结
    B:三类
        创建型
        结构型
        行为型
(3)改进的设计模式
    A:简单工厂模式（Simple Factory Pattern）
        public abstract class Animal {
            public abstract void eat();

            public static Animal getDog() {
                return new Dog();
            }

            public static Animal getCat() {
                return new Cat();
            }

            public static void main(String[] args) {
                Animal dog = Animal.getDog();
                Animal cat = Animal.getCat();

                dog.eat();
                cat.eat();
            }
        }

        class Dog extends Animal{

            @Override
            public void eat(){
                System.out.println(&quot;eat bone&quot;);
            }
        }

        class Cat extends Animal{

            @Override
            public void eat() {
                System.out.println(&quot;eat fish&quot;);
            }
        }
    B:工厂方法模式（Factory Method Pattern）
        public abstract class Animal {
            public abstract void eat();

            public static Animal getDog() {
                return new Dog();
            }

            public static Animal getCat() {
                return new Cat();
            }

            public static void main(String[] args) {
                Animal dog = new DogFactory().getAnimal();
                Animal cat = new CatFactory().getAnimal();

                dog.eat();
                cat.eat();
            }
        }

        interface AnimalFactory {
            Animal getAnimal();
        }

        class DogFactory implements AnimalFactory {

            @Override
            public Animal getAnimal() {
                return new Dog();
            }
        }

        class CatFactory implements AnimalFactory {

            @Override
            public Animal getAnimal() {
                return new Cat();
            }
        }

        class Dog extends Animal {

            @Override
            public void eat() {
                System.out.println(&quot;eat bone&quot;);
            }
        }

        class Cat extends Animal {

            @Override
            public void eat() {
                System.out.println(&quot;eat fish&quot;);
            }
        }
    C:单例模式(Singleton Pattern掌握)
        a:饿汉式（开发常用）
            public class TeacherDemo {
                public static void main(String[] args) {
                    Teacher t1 = Teacher.getTeacher();
                    Teacher t2 = Teacher.getTeacher();

                    System.out.println(t1 == t2);
                }
            }

            class Teacher {
                private static Teacher teacher = new Teacher();

                private Teacher() {
                }

                public static Teacher getTeacher() {
                    return teacher;
                }
            }
        b:懒汉式（面试常用，容易有线程安全问题，需要线程同步）
            public class StudentDemo {
                public static void main(String[] args) {
                    Student s1 = Student.getStudent();
                    Student s2 = Student.getStudent();

                    System.out.println(s1 == s2);
                }
            }

            class Student {
                private static Student student = null;

                private Student() {
                }

                public synchronized static Student getStudent() {
                    if (Objects.isNull(student)) {
                        student = new Student();
                    }
                    return student;
                }
            }
(4)Runtime
    JDK提供的一个单例模式应用的类。
    还可以调用系统命令。
    public class RuntimeDemo {
        public static void main(String[] args) throws IOException {
            Runtime r = Runtime.getRuntime();
            r.exec(&quot;touch 1.txt&quot;);
        }
    }</code></pre><h1 id="JavaGUI"><a href="#JavaGUI" class="headerlink" title="JavaGUI"></a>JavaGUI</h1><h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><h2 id="1-网络编程-理解"><a href="#1-网络编程-理解" class="headerlink" title="1. 网络编程(理解)"></a>1. 网络编程(理解)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)网络编程：用Java语言实现计算机间数据的信息传递和资源共享</span><br><span class="line">(<span class="number">2</span>)网络编程模型</span><br><span class="line">	应用层-表示层-会话层-传输层-网络层-数据链路层-物理层</span><br><span class="line">(<span class="number">3</span>)网络编程的三要素</span><br><span class="line">	A:IP地址</span><br><span class="line">		a:点分十进制：<span class="number">192.168</span>.1.1</span><br><span class="line">		b:IP地址的组成：网络号段+主机号段</span><br><span class="line">		c:IP地址的分类：</span><br><span class="line">			A类	<span class="number">1.0</span>.0.1---<span class="number">127.255</span>.255.254	</span><br><span class="line">				(<span class="number">1</span>)<span class="number">10</span>.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)										</span><br><span class="line">				(<span class="number">2</span>)<span class="number">127</span>.X.X.X是保留地址，用做循环测试用的。</span><br><span class="line">			B类	<span class="number">128.0</span>.0.1---<span class="number">191.255</span>.255.254	<span class="number">172.16</span>.0.0---<span class="number">172.31</span>.255.255是私有地址。<span class="number">169.254</span>.X.X是保留地址。</span><br><span class="line">			C类	<span class="number">192.0</span>.0.1---<span class="number">223.255</span>.255.254	<span class="number">192.168</span>.X.X是私有地址</span><br><span class="line">			D类	<span class="number">224.0</span>.0.1---<span class="number">239.255</span>.255.254 	</span><br><span class="line">			E类	<span class="number">240.0</span>.0.1---<span class="number">247.255</span>.255.254</span><br><span class="line">		d:dos命令</span><br><span class="line">			ipconfig; telnet; ping</span><br><span class="line">		e:InetAddress</span><br><span class="line">			<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPDemo</span> </span>&#123;</span><br><span class="line">			    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">			        InetAddress ip = InetAddress.getByName(<span class="string">"192.168.2.203"</span>);</span><br><span class="line">			        System.out.println(ip.getHostName() + <span class="string">":"</span> + ip.getHostAddress());</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br><span class="line">	B:端口</span><br><span class="line">		是应用程序的标识。范围：<span class="number">0</span>-<span class="number">65535</span>。其中<span class="number">0</span>-<span class="number">1024</span>不建议使用。</span><br><span class="line">	C:协议</span><br><span class="line">		UDP:数据打包,有限制,不连接,效率高,不可靠</span><br><span class="line">		TCP:建立数据通道,无限制,效率低,可靠</span><br><span class="line">(<span class="number">3</span>)Socket机制</span><br><span class="line">	A:通信两端都应该有Socket对象</span><br><span class="line">	B:所有的通信都是通过Socket间的IO进行操作的</span><br><span class="line">(<span class="number">4</span>)UDP协议发送和接收数据(掌握 自己补齐代码)</span><br><span class="line">	发送：</span><br><span class="line">		创建UDP发送端的Socket对象</span><br><span class="line">		创建数据并把数据打包</span><br><span class="line">		发送数据</span><br><span class="line">		释放资源</span><br><span class="line">	接收：</span><br><span class="line">		创建UDP接收端的Socket对象</span><br><span class="line">		创建数据包用于接收数据</span><br><span class="line">		接收数据</span><br><span class="line">		解析数据包</span><br><span class="line">		释放资源</span><br><span class="line">		</span><br><span class="line">(<span class="number">5</span>)TCP协议发送和接收数据(掌握 自己补齐代码)</span><br><span class="line">	发送：</span><br><span class="line">		创建TCP客户端的Socket对象</span><br><span class="line">		获取输出流，写数据</span><br><span class="line">		释放资源</span><br><span class="line">		</span><br><span class="line">	接收：</span><br><span class="line">		创建TCP服务器端的Socket对象</span><br><span class="line">		监听客户端连接</span><br><span class="line">		获取输入流，读取数据</span><br><span class="line">		释放资源</span><br><span class="line">(<span class="number">6</span>)案例：</span><br><span class="line">	A:UDP</span><br><span class="line">		a:最基本的UDP协议发送和接收数据</span><br><span class="line">		b:把发送数据改进为键盘录入</span><br><span class="line">		发送端：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSocket</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        <span class="comment">//设置socket发送的端口号，不设置的则为随机端口号</span></span><br><span class="line">		        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">12307</span>);</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		        String s = <span class="keyword">null</span>;</span><br><span class="line">		        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		            <span class="keyword">if</span> (Objects.equals(s, <span class="string">"bye"</span>)) &#123;</span><br><span class="line">		                <span class="keyword">break</span>;</span><br><span class="line">		            &#125;</span><br><span class="line">		            <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">		            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">		            	bytes, bytes.length, InetAddress.getByName(<span class="string">"192.168.2.203"</span>), <span class="number">12306</span>);</span><br><span class="line">		            ds.send(dp);</span><br><span class="line">		        &#125;</span><br><span class="line">		        ds.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		接收端：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveSocket</span> </span>&#123;</span><br><span class="line">					    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">					        <span class="comment">//设置socket接收的端口号</span></span><br><span class="line">					        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">12306</span>);</span><br><span class="line">					        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">					            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class="line">					            ds.receive(dp);</span><br><span class="line">					            String s = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</span><br><span class="line">					            System.out.println(dp.getAddress().getHostAddress() + <span class="string">":"</span> + dp.getPort() + <span class="string">"\n"</span> + s);</span><br><span class="line">					        &#125;</span><br><span class="line">					</span><br><span class="line">					    &#125;</span><br><span class="line">					&#125;</span><br><span class="line">		c:一个简易聊天小程序并用多线程改进</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		        Thread sendThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		            <span class="meta">@Override</span></span><br><span class="line">		            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		                <span class="keyword">try</span> &#123;</span><br><span class="line">		                    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">12307</span>);</span><br><span class="line">		                    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		                    String s = <span class="keyword">null</span>;</span><br><span class="line">		                    <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		                        <span class="keyword">if</span> (Objects.equals(s, <span class="string">"bye"</span>)) &#123;</span><br><span class="line">		                            <span class="keyword">break</span>;</span><br><span class="line">		                        &#125;</span><br><span class="line">		                        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">		                        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">		                        	bytes, bytes.length, InetAddress.getByName(<span class="string">"192.168.2.203"</span>), <span class="number">12306</span>);</span><br><span class="line">		                        ds.send(dp);</span><br><span class="line">		                    &#125;</span><br><span class="line">		                    ds.close();</span><br><span class="line">		                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		                    e.printStackTrace();</span><br><span class="line">		                &#125;</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;);</span><br><span class="line">		        Thread receiveThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		            <span class="meta">@Override</span></span><br><span class="line">		            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		                <span class="keyword">try</span> &#123;</span><br><span class="line">		                    DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">12306</span>);</span><br><span class="line">		                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		                        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class="line">		                        ds.receive(dp);</span><br><span class="line">		                        String s = <span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength());</span><br><span class="line">		                        System.out.println(dp.getAddress().getHostAddress() + <span class="string">":"</span> + dp.getPort() + <span class="string">"\n"</span> + s);</span><br><span class="line">		                    &#125;</span><br><span class="line">		                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		                    e.printStackTrace();</span><br><span class="line">		                &#125;</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;);</span><br><span class="line">		</span><br><span class="line">		        sendThread.start();</span><br><span class="line">		        receiveThread.start();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	B:TCP</span><br><span class="line">		a:最基本的TCP协议发送和接收数据</span><br><span class="line">		client：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        Socket client = <span class="keyword">new</span> Socket(<span class="string">"192.168.2.203"</span>, <span class="number">8809</span>);</span><br><span class="line">		        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class="line">		        </span><br><span class="line">		        bw.write(<span class="string">"hello tcp"</span>);</span><br><span class="line">		        bw.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		server：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8809</span>);</span><br><span class="line">		        Socket s = server.accept();</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">		</span><br><span class="line">		        System.out.println(br.readLine());</span><br><span class="line">		        br.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		b:服务器给出反馈</span><br><span class="line">		client：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        Socket client = <span class="keyword">new</span> Socket(<span class="string">"192.168.2.203"</span>, <span class="number">8809</span>);</span><br><span class="line">		        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class="line">		</span><br><span class="line">		        bw.write(<span class="string">"hello tcp"</span>);</span><br><span class="line">		        bw.flush();</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//给服务端发送停止写入的信号，否则服务端会一直阻塞</span></span><br><span class="line">		        client.shutdownOutput();</span><br><span class="line">		</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">		        System.out.println(br.readLine());</span><br><span class="line">		</span><br><span class="line">		        bw.close();</span><br><span class="line">		        br.close();</span><br><span class="line">		        client.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		server：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8809</span>);</span><br><span class="line">		        Socket s = server.accept();</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">		</span><br><span class="line">		        System.out.println(br.readLine());</span><br><span class="line">		</span><br><span class="line">		        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">		        bw.write(<span class="string">"已收到"</span>);</span><br><span class="line">		        bw.flush();</span><br><span class="line">		</span><br><span class="line">		        bw.close();</span><br><span class="line">		        br.close();</span><br><span class="line">		        server.close();</span><br><span class="line">		        server.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		c:客户端键盘录入服务器控制台输出</span><br><span class="line">		client：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        Socket client = <span class="keyword">new</span> Socket(<span class="string">"192.168.2.203"</span>, <span class="number">8809</span>);</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class="line">		</span><br><span class="line">		        String s = <span class="keyword">null</span>;</span><br><span class="line">		        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		            <span class="keyword">if</span> (Objects.equals(s, <span class="string">"bye"</span>)) &#123;</span><br><span class="line">		                <span class="keyword">break</span>;</span><br><span class="line">		            &#125;</span><br><span class="line">		            bw.write(s);</span><br><span class="line">		            bw.newLine();</span><br><span class="line">		            bw.flush();</span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">		        <span class="comment">//给服务端发送停止写入的信号，否则服务端会一直阻塞</span></span><br><span class="line">		        client.shutdownOutput();</span><br><span class="line">		</span><br><span class="line">		        br.close();</span><br><span class="line">		        bw.close();</span><br><span class="line">		        client.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		server：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8809</span>);</span><br><span class="line">		        Socket s = server.accept();</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">		</span><br><span class="line">		        String client = <span class="keyword">null</span>;</span><br><span class="line">		        <span class="keyword">while</span> ((client = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		            System.out.println(client);</span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">		        br.close();</span><br><span class="line">		        s.close();</span><br><span class="line">		        server.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		d:客户端键盘录入服务器写到文本文件</span><br><span class="line">		client：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        Socket s = <span class="keyword">new</span> Socket(<span class="string">"192.168.2.203"</span>,<span class="number">8809</span>);</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">		</span><br><span class="line">		        String msg = <span class="keyword">null</span>;</span><br><span class="line">		        <span class="keyword">while</span> ((msg = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">		            <span class="keyword">if</span> (Objects.equals(msg, <span class="string">"bye"</span>)) &#123;</span><br><span class="line">		                <span class="keyword">break</span>;</span><br><span class="line">		            &#125;</span><br><span class="line">		            bw.write(msg);</span><br><span class="line">		            bw.newLine();</span><br><span class="line">		            bw.flush();</span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">		        s.shutdownOutput();</span><br><span class="line">		</span><br><span class="line">		        BufferedReader br1 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">		        System.out.println(br1.readLine());</span><br><span class="line">		</span><br><span class="line">		        br.close();</span><br><span class="line">		        br1.close();</span><br><span class="line">		        bw.close();</span><br><span class="line">		        s.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		server：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">8809</span>);</span><br><span class="line">		        Socket s = ss.accept();</span><br><span class="line">		</span><br><span class="line">		        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>));</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(s.getInputStream()));</span><br><span class="line">		</span><br><span class="line">		        String msg = <span class="keyword">null</span>;</span><br><span class="line">		        <span class="keyword">while</span> ((msg = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		            bw.write(msg);</span><br><span class="line">		            bw.newLine();</span><br><span class="line">		            bw.flush();</span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">		        BufferedWriter bw1 = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class="line">		        bw1.write(<span class="string">"已全部接收！"</span>);</span><br><span class="line">		        bw1.newLine();</span><br><span class="line">		        bw1.flush();</span><br><span class="line">		</span><br><span class="line">		        br.close();</span><br><span class="line">		        bw.close();</span><br><span class="line">		        bw1.close();</span><br><span class="line">		        s.close();</span><br><span class="line">		        ss.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		e:客户端读取文本文件服务器控制台输出</span><br><span class="line">		client：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		        Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">8808</span>);</span><br><span class="line">		</span><br><span class="line">		        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>)));</span><br><span class="line">		        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class="line">		</span><br><span class="line">		        String s = <span class="keyword">null</span>;</span><br><span class="line">		        <span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		            bw.write(s);</span><br><span class="line">		            bw.newLine();</span><br><span class="line">		            bw.flush();</span><br><span class="line">		        &#125;</span><br><span class="line">		</span><br><span class="line">		        bw.close();</span><br><span class="line">		        br.close();</span><br><span class="line">		        client.close();</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		server：</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8808</span>);</span><br><span class="line"></span><br><span class="line">				Socket client = server.accept();</span><br><span class="line"></span><br><span class="line">				BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line"></span><br><span class="line">				String s = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">while</span> ((s = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					System.out.println(s);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		f:客户端读取文本文件服务器写到文本文件</span><br><span class="line">		g:上传图片</span><br><span class="line">		h:多线程改进上传文件</span><br></pre></td></tr></table></figure>

<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><h2 id="1-反射-理解"><a href="#1-反射-理解" class="headerlink" title="1. 反射(理解)"></a>1. 反射(理解)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)类的加载及类加载器</span><br><span class="line">(<span class="number">2</span>)反射：</span><br><span class="line">	通过字节码文件对象，去使用成员变量，构造方法，成员方法</span><br><span class="line">(<span class="number">3</span>)反射的使用</span><br><span class="line">	A:通过反射获取构造方法并使用</span><br><span class="line">	B:通过反射获取成员变量并使用</span><br><span class="line">	C:通过反射获取成员方法并使用</span><br><span class="line">(<span class="number">4</span>)反射案例</span><br><span class="line">	A:通过反射运行配置文件的内容</span><br><span class="line">	B:通过反射越过泛型检查</span><br><span class="line">	C:通过反射给任意的一个对象的任意的属性赋值为指定的值</span><br><span class="line">(<span class="number">5</span>)动态代理</span><br></pre></td></tr></table></figure>

<h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)装饰设计模式</span><br><span class="line">	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">	</span><br><span class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">(<span class="number">2</span>)模版设计模式</span><br></pre></td></tr></table></figure>

<h2 id="3-JDK新特性"><a href="#3-JDK新特性" class="headerlink" title="3. JDK新特性"></a>3. JDK新特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)JDK5(掌握)</span><br><span class="line">	装箱和拆箱</span><br><span class="line">	泛型</span><br><span class="line">	增强<span class="keyword">for</span></span><br><span class="line">	静态导入</span><br><span class="line">	可变参数</span><br><span class="line">	枚举</span><br><span class="line">(<span class="number">2</span>)JDK6(了解)</span><br><span class="line">(<span class="number">3</span>)JDK7(理解)</span><br><span class="line">	二进制的表现形式</span><br><span class="line">	用_分隔数据</span><br><span class="line">	<span class="keyword">switch</span>语句可是用字符串</span><br><span class="line">	泛型推断(菱形泛型)</span><br><span class="line">	多<span class="keyword">catch</span>的使用</span><br><span class="line">	自动释放资源的用法</span><br><span class="line">(<span class="number">4</span>)JDK8(了解)</span><br><span class="line">	可以去网上了解资料</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">xDaShen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/12/05/Java学习笔记/">http://yoursite.com/2018/12/05/Java学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/学习笔记/">学习笔记</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/09/03/SpringBoot与axios遇到的坑/"><i class="fa fa-chevron-left">  </i><span>SpringBoot与axios遇到的坑</span></a></div><div class="next-post pull-right"><a href="/2018/12/05/JDBC学习笔记/"><span>JDBC学习笔记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By xDaShen</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>