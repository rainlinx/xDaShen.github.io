{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/_data/melody.yml","hash":"286852ab404a41451050601269b527044eb1d376","modified":1567440550450},{"_id":"source/_posts/JDBC学习笔记.md","hash":"525389291fd21c58aef97bb0f421ba45aa00c1fd","modified":1567440550451},{"_id":"source/_posts/MyBatis学习笔记.md","hash":"4ebe65a20347b5ad774a9ba74214c3770d2b1a74","modified":1567440550452},{"_id":"source/_posts/SpringMVC学习笔记.md","hash":"aeb96d2fcedaecfccc5df0b5ade68888f87a23e6","modified":1567440550453},{"_id":"source/_posts/Spring学习笔记.md","hash":"cf7e454717dc26d558214004e57c92b0c0c940e5","modified":1567440550453},{"_id":"source/tags/index.md","hash":"d674937ef2cf98f4257e2ebbb2131d593e01455a","modified":1567440550453},{"_id":"source/_posts/Ubuntu-18-04-开发环境搭建.md","hash":"af12b579c987eec1610a245b63a4a700e6b5cbb3","modified":1567440550453},{"_id":"source/_posts/Java学习笔记.md","hash":"697f891d0cda4507536dd3112bf2aa7d5ecbb62c","modified":1567440550452},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/2018/12/05/Java学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/2018/12/05/JDBC学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/2018/12/05/MyBatis学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/2018/12/05/SpringMVC学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/2018/12/05/Spring学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/2018/12/05/Ubuntu-18-04-开发环境搭建/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666344},{"_id":"public/tags/学习笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666345},{"_id":"public/tags/环境搭建/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666345},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666345},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666345},{"_id":"public/archives/2018/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1567477666345}],"Category":[],"Data":[{"_id":"melody","data":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}],"Page":[{"title":"tags","date":"2018-12-05T08:02:10.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-12-05 16:02:10\ntype: tags\n---\n","updated":"2019-09-02T16:09:10.453Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck037qbqj000aliydgro3ipiy","content":"","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":""}],"Post":[{"title":"MyBatis学习笔记","date":"2018-12-05T07:54:16.000Z","_content":"\n# MyBatis学习笔记\n\n## 1. 对原生态jdbc程序开发中的问题的总结\n\n### 1.1 环境\n\n- jdk 1.8\n- idea\n- mysql 8\n\n### 1.2 创建mysql相关库表数据\n\n1. 执行以下建表语句：\n\n   ```mysql\n   CREATE TABLE `items` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `name` varchar(32) NOT NULL COMMENT '商品名称',\n       `price` float(10,1) NOT NULL COMMENT '商品定价',\n       `detail` text COMMENT '商品描述',\n       `pic` varchar(64) DEFAULT NULL COMMENT '商品图片',\n       `createtime` datetime NOT NULL COMMENT '生产日期',\n       PRIMARY KEY (`id`)\n   );\n   \n   CREATE TABLE `orderdetail` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `orders_id` int(11) NOT NULL COMMENT '订单id',\n       `items_id` int(11) NOT NULL COMMENT '商品id',\n       `items_num` int(11) DEFAULT NULL COMMENT '商品购买数量',\n       PRIMARY KEY (`id`),\n       KEY `FK_orderdetail_1` (`orders_id`),\n       KEY `FK_orderdetail_2` (`items_id`),\n       CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,\n       CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\n   );\n   \n   CREATE TABLE `orders` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `user_id` int(11) NOT NULL COMMENT '下单用户id',\n       `number` varchar(32) NOT NULL COMMENT '订单号',\n       `createtime` datetime NOT NULL COMMENT '创建订单时间',\n       `note` varchar(100) DEFAULT NULL COMMENT '备注',\n       PRIMARY KEY (`id`),\n       KEY `FK_orders_1` (`user_id`),\n       CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\n   );\n   \n   CREATE TABLE `user` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `username` varchar(32) NOT NULL COMMENT '用户名称',\n       `birthday` date DEFAULT NULL COMMENT '生日',\n       `sex` char(1) DEFAULT NULL COMMENT '性别',\n       `address` varchar(256) DEFAULT NULL COMMENT '地址',\n       PRIMARY KEY (`id`)\n   );\n   \n   ```\n\n2. 执行以下初始化数据脚本：\n\n   ```mysql\n   insert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,'台式机',3000.0,'该电脑质量非常好！！！！',NULL,'2015-02-03 13:22:53'),(2,'笔记本',6000.0,'笔记本性能好，质量好！！！！！',NULL,'2015-02-09 13:22:57'),(3,'背包',200.0,'名牌背包，容量大质量好！！！！',NULL,'2015-02-06 13:23:02');\n   \n   insert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,'1000010','2015-02-04 13:22:35',NULL),(4,1,'1000011','2015-02-03 13:22:41',NULL),(5,10,'1000012','2015-02-12 16:13:23',NULL);\n   \n   insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,'王五',NULL,'2',NULL),(10,'张三','2014-07-10','1','北京市'),(16,'张小明',NULL,'1','河南郑州'),(22,'陈小明',NULL,'1','河南郑州'),(24,'张三丰',NULL,'1','河南郑州'),(25,'陈小明',NULL,'1','河南郑州'),(26,'王五',NULL,NULL,NULL);\n   ```\n\n### 1.3 jdbc程序\n\n### 1.4 问题总结\n\n- 数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。\n\n  设想：使用数据库连接池管理数据库连接。\n\n- 将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。\n\n  设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。\n\n- 向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。\n\n  设想：将sql语句及占位符号和参数全部配置在xml中。\n\n- 从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。\n\n  设想：将查询的结果集，自动映射成java对象。\n\n## 2. MyBatis框架\n\n### 2.1 mybatis是什么？\n\nmybatis是一个持久层的框架，是apache下的顶级项目。\n\nmybatis托管到goolecode下，再后来托管到github下(https://github.com/mybatis/mybatis-3/releases)。\n\nmybatis让程序员将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。\n\nmybatis可以将向 preparedStatement中输入的参数自动进行输入映射，将查询结果集灵活映射成java对象（输出映射）。\n\n### 2.2 mybatis框架结构\n\n![img](file:///C:/Users/Xmoss/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)\n\n## 3. 入门程序\n\n### 3.1 环境\n\n- jdk 1.8\n- idea\n- mysql 8.0.13\n- mybatis-3.4.0.jar\n\n### 3.2 log4j.properties\n\n```prop\n### direct log messages to stdout ###\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\n\n### direct messages to file mylog.log ###\nlog4j.appender.file=org.apache.log4j.FileAppender\n#log4j.appender.file.File=c:\\mylog.log\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\n\n### set log levels - for more verbose logging change 'info' to 'debug' ###\n\nlog4j.rootLogger=debug, stdout\n```\n\n### 3.3 SqlMapConfig.xml\n\n配置mybatis的运行环境，数据源、事务等。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 加载属性文件 -->\n    <properties resource=\"jdbc.properties\">\n        <!--properties中还可以配置一些属性名和属性值  -->\n        <!-- <property name=\"jdbc.driver\" value=\"\"/> -->\n    </properties>\n    <!-- 和spring整合后 environments配置将废除-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <!-- 使用jdbc事务管理，事务控制由mybatis-->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据库连接池，由mybatis管理-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.username}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n</configuration>\n```\n\n### 3.4 jdbc.properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/jdbc\njdbc.username=root\njdbc.password=941218\n```\n\n### 3.5 根据用户id（主键）查询用户信息\n\n#### 3.5.1 创建dao类\n\n```java\npublic class User {\n    //属性名和数据库表的字段对应\n    private int id;\n    private String username;//用户名\n    private String sex;//性别\n    private Date birthday;//生日\n    private String address;//地址\n}\n```","source":"_posts/MyBatis学习笔记.md","raw":"---\ntitle: MyBatis学习笔记\ndate: 2018-12-05 15:54:16\ntags: 学习笔记\n---\n\n# MyBatis学习笔记\n\n## 1. 对原生态jdbc程序开发中的问题的总结\n\n### 1.1 环境\n\n- jdk 1.8\n- idea\n- mysql 8\n\n### 1.2 创建mysql相关库表数据\n\n1. 执行以下建表语句：\n\n   ```mysql\n   CREATE TABLE `items` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `name` varchar(32) NOT NULL COMMENT '商品名称',\n       `price` float(10,1) NOT NULL COMMENT '商品定价',\n       `detail` text COMMENT '商品描述',\n       `pic` varchar(64) DEFAULT NULL COMMENT '商品图片',\n       `createtime` datetime NOT NULL COMMENT '生产日期',\n       PRIMARY KEY (`id`)\n   );\n   \n   CREATE TABLE `orderdetail` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `orders_id` int(11) NOT NULL COMMENT '订单id',\n       `items_id` int(11) NOT NULL COMMENT '商品id',\n       `items_num` int(11) DEFAULT NULL COMMENT '商品购买数量',\n       PRIMARY KEY (`id`),\n       KEY `FK_orderdetail_1` (`orders_id`),\n       KEY `FK_orderdetail_2` (`items_id`),\n       CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,\n       CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\n   );\n   \n   CREATE TABLE `orders` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `user_id` int(11) NOT NULL COMMENT '下单用户id',\n       `number` varchar(32) NOT NULL COMMENT '订单号',\n       `createtime` datetime NOT NULL COMMENT '创建订单时间',\n       `note` varchar(100) DEFAULT NULL COMMENT '备注',\n       PRIMARY KEY (`id`),\n       KEY `FK_orders_1` (`user_id`),\n       CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION\n   );\n   \n   CREATE TABLE `user` (\n       `id` int(11) NOT NULL AUTO_INCREMENT,\n       `username` varchar(32) NOT NULL COMMENT '用户名称',\n       `birthday` date DEFAULT NULL COMMENT '生日',\n       `sex` char(1) DEFAULT NULL COMMENT '性别',\n       `address` varchar(256) DEFAULT NULL COMMENT '地址',\n       PRIMARY KEY (`id`)\n   );\n   \n   ```\n\n2. 执行以下初始化数据脚本：\n\n   ```mysql\n   insert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,'台式机',3000.0,'该电脑质量非常好！！！！',NULL,'2015-02-03 13:22:53'),(2,'笔记本',6000.0,'笔记本性能好，质量好！！！！！',NULL,'2015-02-09 13:22:57'),(3,'背包',200.0,'名牌背包，容量大质量好！！！！',NULL,'2015-02-06 13:23:02');\n   \n   insert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,'1000010','2015-02-04 13:22:35',NULL),(4,1,'1000011','2015-02-03 13:22:41',NULL),(5,10,'1000012','2015-02-12 16:13:23',NULL);\n   \n   insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,'王五',NULL,'2',NULL),(10,'张三','2014-07-10','1','北京市'),(16,'张小明',NULL,'1','河南郑州'),(22,'陈小明',NULL,'1','河南郑州'),(24,'张三丰',NULL,'1','河南郑州'),(25,'陈小明',NULL,'1','河南郑州'),(26,'王五',NULL,NULL,NULL);\n   ```\n\n### 1.3 jdbc程序\n\n### 1.4 问题总结\n\n- 数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。\n\n  设想：使用数据库连接池管理数据库连接。\n\n- 将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。\n\n  设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。\n\n- 向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。\n\n  设想：将sql语句及占位符号和参数全部配置在xml中。\n\n- 从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。\n\n  设想：将查询的结果集，自动映射成java对象。\n\n## 2. MyBatis框架\n\n### 2.1 mybatis是什么？\n\nmybatis是一个持久层的框架，是apache下的顶级项目。\n\nmybatis托管到goolecode下，再后来托管到github下(https://github.com/mybatis/mybatis-3/releases)。\n\nmybatis让程序员将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。\n\nmybatis可以将向 preparedStatement中输入的参数自动进行输入映射，将查询结果集灵活映射成java对象（输出映射）。\n\n### 2.2 mybatis框架结构\n\n![img](file:///C:/Users/Xmoss/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif)\n\n## 3. 入门程序\n\n### 3.1 环境\n\n- jdk 1.8\n- idea\n- mysql 8.0.13\n- mybatis-3.4.0.jar\n\n### 3.2 log4j.properties\n\n```prop\n### direct log messages to stdout ###\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.Target=System.err\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\n\n### direct messages to file mylog.log ###\nlog4j.appender.file=org.apache.log4j.FileAppender\n#log4j.appender.file.File=c:\\mylog.log\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n\n\n### set log levels - for more verbose logging change 'info' to 'debug' ###\n\nlog4j.rootLogger=debug, stdout\n```\n\n### 3.3 SqlMapConfig.xml\n\n配置mybatis的运行环境，数据源、事务等。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!-- 加载属性文件 -->\n    <properties resource=\"jdbc.properties\">\n        <!--properties中还可以配置一些属性名和属性值  -->\n        <!-- <property name=\"jdbc.driver\" value=\"\"/> -->\n    </properties>\n    <!-- 和spring整合后 environments配置将废除-->\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <!-- 使用jdbc事务管理，事务控制由mybatis-->\n            <transactionManager type=\"JDBC\"/>\n            <!-- 数据库连接池，由mybatis管理-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\"/>\n                <property name=\"url\" value=\"${jdbc.url}\"/>\n                <property name=\"username\" value=\"${jdbc.username}\"/>\n                <property name=\"password\" value=\"${jdbc.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n</configuration>\n```\n\n### 3.4 jdbc.properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/jdbc\njdbc.username=root\njdbc.password=941218\n```\n\n### 3.5 根据用户id（主键）查询用户信息\n\n#### 3.5.1 创建dao类\n\n```java\npublic class User {\n    //属性名和数据库表的字段对应\n    private int id;\n    private String username;//用户名\n    private String sex;//性别\n    private Date birthday;//生日\n    private String address;//地址\n}\n```","slug":"MyBatis学习笔记","published":1,"updated":"2019-09-02T16:09:10.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck037qbq90000liydunj55vq1","content":"<h1 id=\"MyBatis学习笔记\"><a href=\"#MyBatis学习笔记\" class=\"headerlink\" title=\"MyBatis学习笔记\"></a>MyBatis学习笔记</h1><h2 id=\"1-对原生态jdbc程序开发中的问题的总结\"><a href=\"#1-对原生态jdbc程序开发中的问题的总结\" class=\"headerlink\" title=\"1. 对原生态jdbc程序开发中的问题的总结\"></a>1. 对原生态jdbc程序开发中的问题的总结</h2><h3 id=\"1-1-环境\"><a href=\"#1-1-环境\" class=\"headerlink\" title=\"1.1 环境\"></a>1.1 环境</h3><ul>\n<li>jdk 1.8</li>\n<li>idea</li>\n<li>mysql 8</li>\n</ul>\n<h3 id=\"1-2-创建mysql相关库表数据\"><a href=\"#1-2-创建mysql相关库表数据\" class=\"headerlink\" title=\"1.2 创建mysql相关库表数据\"></a>1.2 创建mysql相关库表数据</h3><ol>\n<li><p>执行以下建表语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `items` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `name` varchar(32) NOT NULL COMMENT &apos;商品名称&apos;,</span><br><span class=\"line\">    `price` float(10,1) NOT NULL COMMENT &apos;商品定价&apos;,</span><br><span class=\"line\">    `detail` text COMMENT &apos;商品描述&apos;,</span><br><span class=\"line\">    `pic` varchar(64) DEFAULT NULL COMMENT &apos;商品图片&apos;,</span><br><span class=\"line\">    `createtime` datetime NOT NULL COMMENT &apos;生产日期&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `orderdetail` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `orders_id` int(11) NOT NULL COMMENT &apos;订单id&apos;,</span><br><span class=\"line\">    `items_id` int(11) NOT NULL COMMENT &apos;商品id&apos;,</span><br><span class=\"line\">    `items_num` int(11) DEFAULT NULL COMMENT &apos;商品购买数量&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`),</span><br><span class=\"line\">    KEY `FK_orderdetail_1` (`orders_id`),</span><br><span class=\"line\">    KEY `FK_orderdetail_2` (`items_id`),</span><br><span class=\"line\">    CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,</span><br><span class=\"line\">    CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `orders` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `user_id` int(11) NOT NULL COMMENT &apos;下单用户id&apos;,</span><br><span class=\"line\">    `number` varchar(32) NOT NULL COMMENT &apos;订单号&apos;,</span><br><span class=\"line\">    `createtime` datetime NOT NULL COMMENT &apos;创建订单时间&apos;,</span><br><span class=\"line\">    `note` varchar(100) DEFAULT NULL COMMENT &apos;备注&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`),</span><br><span class=\"line\">    KEY `FK_orders_1` (`user_id`),</span><br><span class=\"line\">    CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;,</span><br><span class=\"line\">    `birthday` date DEFAULT NULL COMMENT &apos;生日&apos;,</span><br><span class=\"line\">    `sex` char(1) DEFAULT NULL COMMENT &apos;性别&apos;,</span><br><span class=\"line\">    `address` varchar(256) DEFAULT NULL COMMENT &apos;地址&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行以下初始化数据脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,&apos;台式机&apos;,3000.0,&apos;该电脑质量非常好！！！！&apos;,NULL,&apos;2015-02-03 13:22:53&apos;),(2,&apos;笔记本&apos;,6000.0,&apos;笔记本性能好，质量好！！！！！&apos;,NULL,&apos;2015-02-09 13:22:57&apos;),(3,&apos;背包&apos;,200.0,&apos;名牌背包，容量大质量好！！！！&apos;,NULL,&apos;2015-02-06 13:23:02&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,&apos;1000010&apos;,&apos;2015-02-04 13:22:35&apos;,NULL),(4,1,&apos;1000011&apos;,&apos;2015-02-03 13:22:41&apos;,NULL),(5,10,&apos;1000012&apos;,&apos;2015-02-12 16:13:23&apos;,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,&apos;王五&apos;,NULL,&apos;2&apos;,NULL),(10,&apos;张三&apos;,&apos;2014-07-10&apos;,&apos;1&apos;,&apos;北京市&apos;),(16,&apos;张小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(22,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(24,&apos;张三丰&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(25,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(26,&apos;王五&apos;,NULL,NULL,NULL);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"1-3-jdbc程序\"><a href=\"#1-3-jdbc程序\" class=\"headerlink\" title=\"1.3 jdbc程序\"></a>1.3 jdbc程序</h3><h3 id=\"1-4-问题总结\"><a href=\"#1-4-问题总结\" class=\"headerlink\" title=\"1.4 问题总结\"></a>1.4 问题总结</h3><ul>\n<li><p>数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。</p>\n<p>设想：使用数据库连接池管理数据库连接。</p>\n</li>\n<li><p>将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。</p>\n<p>设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。</p>\n</li>\n<li><p>向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。</p>\n<p>设想：将sql语句及占位符号和参数全部配置在xml中。</p>\n</li>\n<li><p>从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。</p>\n<p>设想：将查询的结果集，自动映射成java对象。</p>\n</li>\n</ul>\n<h2 id=\"2-MyBatis框架\"><a href=\"#2-MyBatis框架\" class=\"headerlink\" title=\"2. MyBatis框架\"></a>2. MyBatis框架</h2><h3 id=\"2-1-mybatis是什么？\"><a href=\"#2-1-mybatis是什么？\" class=\"headerlink\" title=\"2.1 mybatis是什么？\"></a>2.1 mybatis是什么？</h3><p>mybatis是一个持久层的框架，是apache下的顶级项目。</p>\n<p>mybatis托管到goolecode下，再后来托管到github下(<a href=\"https://github.com/mybatis/mybatis-3/releases)。\" target=\"_blank\" rel=\"noopener\">https://github.com/mybatis/mybatis-3/releases)。</a></p>\n<p>mybatis让程序员将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</p>\n<p>mybatis可以将向 preparedStatement中输入的参数自动进行输入映射，将查询结果集灵活映射成java对象（输出映射）。</p>\n<h3 id=\"2-2-mybatis框架结构\"><a href=\"#2-2-mybatis框架结构\" class=\"headerlink\" title=\"2.2 mybatis框架结构\"></a>2.2 mybatis框架结构</h3><p><img src=\"file:///C:/Users/Xmoss/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif\" alt=\"img\"></p>\n<h2 id=\"3-入门程序\"><a href=\"#3-入门程序\" class=\"headerlink\" title=\"3. 入门程序\"></a>3. 入门程序</h2><h3 id=\"3-1-环境\"><a href=\"#3-1-环境\" class=\"headerlink\" title=\"3.1 环境\"></a>3.1 环境</h3><ul>\n<li>jdk 1.8</li>\n<li>idea</li>\n<li>mysql 8.0.13</li>\n<li>mybatis-3.4.0.jar</li>\n</ul>\n<h3 id=\"3-2-log4j-properties\"><a href=\"#3-2-log4j-properties\" class=\"headerlink\" title=\"3.2 log4j.properties\"></a>3.2 log4j.properties</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### direct log messages to stdout ###</span><br><span class=\"line\">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.stdout.Target=System.err</span><br><span class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### direct messages to file mylog.log ###</span><br><span class=\"line\">log4j.appender.file=org.apache.log4j.FileAppender</span><br><span class=\"line\">#log4j.appender.file.File=c:\\mylog.log</span><br><span class=\"line\">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.rootLogger=debug, stdout</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-SqlMapConfig-xml\"><a href=\"#3-3-SqlMapConfig-xml\" class=\"headerlink\" title=\"3.3 SqlMapConfig.xml\"></a>3.3 SqlMapConfig.xml</h3><p>配置mybatis的运行环境，数据源、事务等。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration</span></span><br><span class=\"line\"><span class=\"meta\">        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 加载属性文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"jdbc.properties\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--properties中还可以配置一些属性名和属性值  --&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- &lt;property name=\"jdbc.driver\" value=\"\"/&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 和spring整合后 environments配置将废除--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 数据库连接池，由mybatis管理--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.driver&#125;\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.url&#125;\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.username&#125;\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.password&#125;\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-jdbc-properties\"><a href=\"#3-4-jdbc-properties\" class=\"headerlink\" title=\"3.4 jdbc.properties\"></a>3.4 jdbc.properties</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class=\"line\">jdbc.url=jdbc:mysql://localhost:3306/jdbc</span><br><span class=\"line\">jdbc.username=root</span><br><span class=\"line\">jdbc.password=941218</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-根据用户id（主键）查询用户信息\"><a href=\"#3-5-根据用户id（主键）查询用户信息\" class=\"headerlink\" title=\"3.5 根据用户id（主键）查询用户信息\"></a>3.5 根据用户id（主键）查询用户信息</h3><h4 id=\"3-5-1-创建dao类\"><a href=\"#3-5-1-创建dao类\" class=\"headerlink\" title=\"3.5.1 创建dao类\"></a>3.5.1 创建dao类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性名和数据库表的字段对应</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;<span class=\"comment\">//用户名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;<span class=\"comment\">//性别</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date birthday;<span class=\"comment\">//生日</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String address;<span class=\"comment\">//地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h1 id=\"MyBatis学习笔记\"><a href=\"#MyBatis学习笔记\" class=\"headerlink\" title=\"MyBatis学习笔记\"></a>MyBatis学习笔记</h1><h2 id=\"1-对原生态jdbc程序开发中的问题的总结\"><a href=\"#1-对原生态jdbc程序开发中的问题的总结\" class=\"headerlink\" title=\"1. 对原生态jdbc程序开发中的问题的总结\"></a>1. 对原生态jdbc程序开发中的问题的总结</h2><h3 id=\"1-1-环境\"><a href=\"#1-1-环境\" class=\"headerlink\" title=\"1.1 环境\"></a>1.1 环境</h3><ul>\n<li>jdk 1.8</li>\n<li>idea</li>\n<li>mysql 8</li>\n</ul>\n<h3 id=\"1-2-创建mysql相关库表数据\"><a href=\"#1-2-创建mysql相关库表数据\" class=\"headerlink\" title=\"1.2 创建mysql相关库表数据\"></a>1.2 创建mysql相关库表数据</h3><ol>\n<li><p>执行以下建表语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `items` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `name` varchar(32) NOT NULL COMMENT &apos;商品名称&apos;,</span><br><span class=\"line\">    `price` float(10,1) NOT NULL COMMENT &apos;商品定价&apos;,</span><br><span class=\"line\">    `detail` text COMMENT &apos;商品描述&apos;,</span><br><span class=\"line\">    `pic` varchar(64) DEFAULT NULL COMMENT &apos;商品图片&apos;,</span><br><span class=\"line\">    `createtime` datetime NOT NULL COMMENT &apos;生产日期&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `orderdetail` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `orders_id` int(11) NOT NULL COMMENT &apos;订单id&apos;,</span><br><span class=\"line\">    `items_id` int(11) NOT NULL COMMENT &apos;商品id&apos;,</span><br><span class=\"line\">    `items_num` int(11) DEFAULT NULL COMMENT &apos;商品购买数量&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`),</span><br><span class=\"line\">    KEY `FK_orderdetail_1` (`orders_id`),</span><br><span class=\"line\">    KEY `FK_orderdetail_2` (`items_id`),</span><br><span class=\"line\">    CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,</span><br><span class=\"line\">    CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `orders` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `user_id` int(11) NOT NULL COMMENT &apos;下单用户id&apos;,</span><br><span class=\"line\">    `number` varchar(32) NOT NULL COMMENT &apos;订单号&apos;,</span><br><span class=\"line\">    `createtime` datetime NOT NULL COMMENT &apos;创建订单时间&apos;,</span><br><span class=\"line\">    `note` varchar(100) DEFAULT NULL COMMENT &apos;备注&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`),</span><br><span class=\"line\">    KEY `FK_orders_1` (`user_id`),</span><br><span class=\"line\">    CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">    `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">    `username` varchar(32) NOT NULL COMMENT &apos;用户名称&apos;,</span><br><span class=\"line\">    `birthday` date DEFAULT NULL COMMENT &apos;生日&apos;,</span><br><span class=\"line\">    `sex` char(1) DEFAULT NULL COMMENT &apos;性别&apos;,</span><br><span class=\"line\">    `address` varchar(256) DEFAULT NULL COMMENT &apos;地址&apos;,</span><br><span class=\"line\">    PRIMARY KEY (`id`)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>执行以下初始化数据脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert  into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,&apos;台式机&apos;,3000.0,&apos;该电脑质量非常好！！！！&apos;,NULL,&apos;2015-02-03 13:22:53&apos;),(2,&apos;笔记本&apos;,6000.0,&apos;笔记本性能好，质量好！！！！！&apos;,NULL,&apos;2015-02-09 13:22:57&apos;),(3,&apos;背包&apos;,200.0,&apos;名牌背包，容量大质量好！！！！&apos;,NULL,&apos;2015-02-06 13:23:02&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,&apos;1000010&apos;,&apos;2015-02-04 13:22:35&apos;,NULL),(4,1,&apos;1000011&apos;,&apos;2015-02-03 13:22:41&apos;,NULL),(5,10,&apos;1000012&apos;,&apos;2015-02-12 16:13:23&apos;,NULL);</span><br><span class=\"line\"></span><br><span class=\"line\">insert  into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,&apos;王五&apos;,NULL,&apos;2&apos;,NULL),(10,&apos;张三&apos;,&apos;2014-07-10&apos;,&apos;1&apos;,&apos;北京市&apos;),(16,&apos;张小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(22,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(24,&apos;张三丰&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(25,&apos;陈小明&apos;,NULL,&apos;1&apos;,&apos;河南郑州&apos;),(26,&apos;王五&apos;,NULL,NULL,NULL);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"1-3-jdbc程序\"><a href=\"#1-3-jdbc程序\" class=\"headerlink\" title=\"1.3 jdbc程序\"></a>1.3 jdbc程序</h3><h3 id=\"1-4-问题总结\"><a href=\"#1-4-问题总结\" class=\"headerlink\" title=\"1.4 问题总结\"></a>1.4 问题总结</h3><ul>\n<li><p>数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。</p>\n<p>设想：使用数据库连接池管理数据库连接。</p>\n</li>\n<li><p>将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。</p>\n<p>设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。</p>\n</li>\n<li><p>向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。</p>\n<p>设想：将sql语句及占位符号和参数全部配置在xml中。</p>\n</li>\n<li><p>从resultSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。</p>\n<p>设想：将查询的结果集，自动映射成java对象。</p>\n</li>\n</ul>\n<h2 id=\"2-MyBatis框架\"><a href=\"#2-MyBatis框架\" class=\"headerlink\" title=\"2. MyBatis框架\"></a>2. MyBatis框架</h2><h3 id=\"2-1-mybatis是什么？\"><a href=\"#2-1-mybatis是什么？\" class=\"headerlink\" title=\"2.1 mybatis是什么？\"></a>2.1 mybatis是什么？</h3><p>mybatis是一个持久层的框架，是apache下的顶级项目。</p>\n<p>mybatis托管到goolecode下，再后来托管到github下(<a href=\"https://github.com/mybatis/mybatis-3/releases)。\" target=\"_blank\" rel=\"noopener\">https://github.com/mybatis/mybatis-3/releases)。</a></p>\n<p>mybatis让程序员将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</p>\n<p>mybatis可以将向 preparedStatement中输入的参数自动进行输入映射，将查询结果集灵活映射成java对象（输出映射）。</p>\n<h3 id=\"2-2-mybatis框架结构\"><a href=\"#2-2-mybatis框架结构\" class=\"headerlink\" title=\"2.2 mybatis框架结构\"></a>2.2 mybatis框架结构</h3><p><img src=\"file:///C:/Users/Xmoss/AppData/Local/Temp/msohtmlclip1/01/clip_image001.gif\" alt=\"img\"></p>\n<h2 id=\"3-入门程序\"><a href=\"#3-入门程序\" class=\"headerlink\" title=\"3. 入门程序\"></a>3. 入门程序</h2><h3 id=\"3-1-环境\"><a href=\"#3-1-环境\" class=\"headerlink\" title=\"3.1 环境\"></a>3.1 环境</h3><ul>\n<li>jdk 1.8</li>\n<li>idea</li>\n<li>mysql 8.0.13</li>\n<li>mybatis-3.4.0.jar</li>\n</ul>\n<h3 id=\"3-2-log4j-properties\"><a href=\"#3-2-log4j-properties\" class=\"headerlink\" title=\"3.2 log4j.properties\"></a>3.2 log4j.properties</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### direct log messages to stdout ###</span><br><span class=\"line\">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">log4j.appender.stdout.Target=System.err</span><br><span class=\"line\">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### direct messages to file mylog.log ###</span><br><span class=\"line\">log4j.appender.file=org.apache.log4j.FileAppender</span><br><span class=\"line\">#log4j.appender.file.File=c:\\mylog.log</span><br><span class=\"line\">log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### set log levels - for more verbose logging change &apos;info&apos; to &apos;debug&apos; ###</span><br><span class=\"line\"></span><br><span class=\"line\">log4j.rootLogger=debug, stdout</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-SqlMapConfig-xml\"><a href=\"#3-3-SqlMapConfig-xml\" class=\"headerlink\" title=\"3.3 SqlMapConfig.xml\"></a>3.3 SqlMapConfig.xml</h3><p>配置mybatis的运行环境，数据源、事务等。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE configuration</span></span><br><span class=\"line\"><span class=\"meta\">        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"</span></span><br><span class=\"line\"><span class=\"meta\">        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 加载属性文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"jdbc.properties\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--properties中还可以配置一些属性名和属性值  --&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- &lt;property name=\"jdbc.driver\" value=\"\"/&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 和spring整合后 environments配置将废除--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 数据库连接池，由mybatis管理--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.driver&#125;\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.url&#125;\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.username&#125;\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;jdbc.password&#125;\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-jdbc-properties\"><a href=\"#3-4-jdbc-properties\" class=\"headerlink\" title=\"3.4 jdbc.properties\"></a>3.4 jdbc.properties</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class=\"line\">jdbc.url=jdbc:mysql://localhost:3306/jdbc</span><br><span class=\"line\">jdbc.username=root</span><br><span class=\"line\">jdbc.password=941218</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-根据用户id（主键）查询用户信息\"><a href=\"#3-5-根据用户id（主键）查询用户信息\" class=\"headerlink\" title=\"3.5 根据用户id（主键）查询用户信息\"></a>3.5 根据用户id（主键）查询用户信息</h3><h4 id=\"3-5-1-创建dao类\"><a href=\"#3-5-1-创建dao类\" class=\"headerlink\" title=\"3.5.1 创建dao类\"></a>3.5.1 创建dao类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性名和数据库表的字段对应</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;<span class=\"comment\">//用户名</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String sex;<span class=\"comment\">//性别</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date birthday;<span class=\"comment\">//生日</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String address;<span class=\"comment\">//地址</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"JDBC学习笔记","date":"2018-12-05T07:54:46.000Z","_content":"\n# JDBC\n## 1. 简介\nJDBC(Java Data Base Connectivity,java数据库连接),由一些接口和类构成的API。\nJ2SE的一部分,由java.sql,javax.sql包组成。\n\n## 2. 连接数据库的步骤\n### 2.1 注册驱动 (只做一次)\n```java\nClass.forName(“com.mysql.jdbc.Driver”);\n\t推荐这种方式,不会对具体的驱动类产生依赖。\n\t\nDriverManager.registerDriver(com.mysql.jdbc.Driver);\n\t会造成DriverManager中产生两个一样的驱动,并会对具体的驱动类产生依赖。\n\t\nSystem.setProperty(“jdbc.drivers”, “driver1:driver2”);\n\t虽然不会对具体的驱动类产生依赖；但注册不太方便,所以很少使用。 \n\t\n驱动类型(四种类型)\n```\n### 2.2 建立连接(Connection) \n\n```java\nConnection conn = DriverManager.getConnection(url, user, password);\nurl格式：\n\tJDBC:子协议:子名称//主机名:端口/数据库名？属性名=属性值&…\nUser,password可以用“属性名=属性值”方式告诉数据库；\n其他参数如：useUnicode=true&characterEncoding=UTF-8&useSSL=false。\n```\n### 2.3 创建执行SQL的语句(Statement)\n```java\nStatement\n\tStatement st = conn.createStatement();\n\tst.executeQuery(sql);\nPreparedStatement\n\tString sql = “select * from table_name where col_name=?”;\n\tPreparedStatement ps = conn.preparedStatement(sql);\n\tps.setString(1, “col_value”);\n\tps.executeQuery();\n```\n### 2.4 执行语句\n```java\nps.executeQuery();\t//执行查询\nps.executeUpdate();\t//执行更新和插入和删除\t\n```\n### 2.5 处理执行结果(ResultSet)\n```java\nResultSet rs = statement.executeQuery(sql);\nWhile(rs.next()){\n\trs.getString(“col_name”);\n\trs.getInt(“col_name”);\n\t//…\n}\n```\n### 2.6 释放资源\n```java\n释放ResultSet, Statement,Connection.\n数据库连接(Connection)是非常稀有的资源,用完后必须马上释放,如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建,尽量早的释放。\n```\n## 3. 基本的CRUD(创建、读取、更新、删除) \n### 3.1 模板代码 \n```java\nConnection conn = null;\nStatement st=null;\nResultSet rs = null;\ntry {\n\t//获得Connection\n\t//创建Statement\n\t//处理查询结果ResultSet\n} finally {\n\t//释放资源ResultSet, Statement,Connection\n}\n```\n### 3.2 创建\n增加对应SQL的INSERT,返回增加成功的行(记录)数\n```java\nconn = getConnection();\nStatement st = conn.createStatement();\nString sql=“insert into user(name, age,regist_date )” +  \t\t“values(‘name’, 10, now())”;\nint i = st.executeUpdate(sql);\n//i为插入的记录数\n```\n### 3.3 读取\n读取(查询)对应SQL的SELECT,返回查询结果\n```java\nconn = getConnection();\nst = conn.createStatement();\nString sql = \"select id, name, age, regist_date from user\";\nrs = st.executeQuery(sql);\nwhile (rs.next()) {\n\t\tSystem.out.print(rs.getInt(\"id\") + \" \\t\\t \");\n\t\tSystem.out.print(rs.getString(\"name\") + \" \\t\\t \");\n\t\tSystem.out.print(rs.getInt(\"age\") + \" \\t\\t \");\n\t\tSystem.out.print(rs.getTimestamp(\"regist_date\") + \" \\t\\t \");\n\t\tSystem.out.println();\n}\n```\n### 3.4 更新\n更新(修改)对应SQL的UPDATE,返回被修改的行(记录)数 \n```java\nconn = getConnection();\nStatement st = conn.createStatement();\nString sql=“update person set name = 'new name‘”;\nint i = st.executeUpdate(sql);\n//i为符合条件的记录数\n```\n### 3.5 删除\n删除对应SQL的DELETE,返回被删除的行(记录)数 \n```java\nconn = getConnection();\nStatement st = conn.createStatement();\nString sql=“delete from user where id=1”;\nint i = st.executeUpdate(sql);\n//i为删掉的记录数\n```\n### 3.6 总结\n```java\n增、删、改用Statement.executeUpdate来完成,返回整数(匹配的记录数),这类操作相对简单。\n查询用Statement.executeQuery来完成,返回的是ResultSet对象,ResultSet中包含了查询的结果；查询相对于增、删、改要复杂一些,因为有查询结果要处理。\n```\n## 4. SQL注入,PreparedStatement和Statement\n```java\n在SQL中包含特殊字符或SQL的关键字(如：' or 1 or ')时Statement将出现不可预料的结果(出现异常或查询的结果不正确),可用PreparedStatement来解决。\nPreperedStatement(从Statement扩展而来)相对Statement的优点：\n\t1.没有SQL注入的问题。\n\t2.Statement会使数据库频繁编译SQL,可能造成数据库缓冲区溢出。\n\t3.数据库和驱动可以对PreperedStatement进行优化(只有在相关联的数据库连接没有关闭的情况下有效)。 \n```\n## 5. 数据类型\n```java\n详细信息见java.sql.Types\n几种特殊且比较常用的类型\n\t1.DATA,TIME,TIMESTAMP date,time,datetime\n存：ps.setDate(i,d); ps.setTime(i,t); ps.setTimestamp(i, ts);\n  \t  取：rs.getDate(i); rs.getTime(i); rs.getTimestamp(i);\n\t2.CLOB -> text(文本文件)\n\t  存：ps.setCharacterStream(index, reader, length);\n\t         ps.setString(i, s);\n\t  取：reader = rs. getCharacterStream(i);\n\t         reader = rs.getClob(i).getCharacterStream();\n\t         string = rs.getString(i);\n\t3.BLOB -> blob(字节文件,如图片)\n\t 存：ps.setBinaryStream(i, inputStream, length);\n       取：rs.getBinaryStream(i);\n\t        rs.getBlob(i).getBinaryStream(); \n```\n## 6. 一个简单用户相关的数据访问层 \nJ2EE三层架构简介\n​\t\t表示层 、业务逻辑层、数据访问层,三层之间用接口隔离。\n定义domain对象User,定义存取用户的接口\n用JDBC实现接口\n用配置文件(properties)和反射实现与具体类的耦合 \n## 7. 事务\n### 7.1 事务(ACID)\n原子性(atomicity)：组成事务处理的语句形成了一个逻辑单元,不能只执行其中的一部分。 \n一致性(consistency)：在事务处理执行前后,数据库是一致的(两个账户要么都变,或者都不变)。 \n隔离性(isolcation)：一个事务处理对另一个事务处理没有影响。 \n持续性(durability)：事务处理的效果能够被永久保存下来 。\n```java\nconnection.setAutoCommit(false);//打开事务。\nconnection.commit();//提交事务。\nconnection.rollback();//回滚事务。\n```\n### 7.2 事务(SavePoint)\n当只想撤销事务中的部分操作时可使用SavePoint\n```java\n//建立保存点\nSavePoint sp = connection.setSavepoint();\n//回滚到保存点\nconnection.rollerbak(sp);\n//提交事务\nconnection.commit();\n```\n### 7.4 事务(JTA)\n跨越多个数据源的事务,使用JTA容器实现事务。\n分成两阶段提交。\n```java\njavax.transaction.UserTransaction tx = (UserTransaction)ctx.lookup(“jndiName\");\n\ttx.begin();\n\t//connection1 connection2 (可能来自不同的数据库)… \n    tx.commit();//tx.rollback();\n```\n### 7.4 隔离级别多线程并发读取数据时的正确性 \nconnection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); \nV:可能出现,X:不会出现\n| 隔离级别                   | 脏读 | 不可重复读 | 幻读 |\n| -------------------------- | ---- | ---------- | ---- |\n| 读未提交(Read Uncommitted) | V    | V          | V    |\n| 读已提交(Read Committed)   | X    | V          | V    |\n| 可重复读(Repeatable Read)  | X    | X          | V    |\n| 可串行化                   | X    | X          | X    |\n## 8. 存储过程\nCallableStatement(从PreperedStatement扩展来)\n```java\ncs = connection.prepareCall(“{call psname(?,?,?)}”);\ncs.registerOutParameter(index, Types.INTEGER);\ncs.setXXX(i, xxxx);\ncs.executeUpdate();\nint id=cs.getInt(index);\n```\n## 9. 其他的几个API\n返回插入语句的主键：Statement.getGeneratedKeys()\n```java\nPreparedStatement ps = connection.prepareStatement(sql,\tStatement.RETURN_GENERATED_KEYS);\nps.executeUpdate();\nResultSet rs = st.getGeneratedKeys();rs.getInt(1);\n```\n批处理,可以大幅度提升大量增、删、改的速度。\n```java\nPreparedStatement.addBatch();\nPreparedStatement.executeBatch();\n```\n可滚动的结果集\n```java\nStatement st = \nconnection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\tResultSet.CONCUR_UPDATABLE);\nResultSet rs = st.executeQuery(sql);\nrs.beforeFirst(); rs.afterLast();rs.first();rs.isFirst();rs.last();rs.isLast();\nrs.absolute(9);rs.moveToInsertRow();\n```\n可更新的结果集\n```java\nconn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\n\t\t\t\tResultSet.CONCUR_UPDATABLE);\nrs.updateString(\"col name\", \"new value\");\nrs.updateRow();\n```\n## 10. 元数据\n### 10.1 DatabaseMetaData\n```java\nDatabaseMetaData meta = connection.getMetaData();\n```\n通过DatabaseMetaData可以获得数据库相关的信息如：数据库版本、数据库名、数据库厂商信息、是否支持事务、是否支持某种事务隔离级别,是否支持滚动结果集等。\n### 10.2 ResultSetMetaData\n```java\nResultSetMetaData meta = rs.getMetaData();\n通过ResultSetMetaData可以获得结果有几列、各列名、各列别名、各列类型等。 \n可以将ResultSet放入Map(key:列名 value:列值)。\n用反射ResultSetMetaData将查询结果读入对象中(简单的O/RMapping) \n\t1)让SQL语句中列别名和要读入的对象属性名一样；\n\t2)通过ResultSetMetaData获得结果列数和列别名；\n\t3)通过反射将对象的所有setXxx方法找到;\n\t4)将3)找到的方法setXxx和2)找到的列别名进行匹配(即方法中的xxx于列别名相等)；\n\t5)由上一步找到的方法和列别名对应关系进行赋值\n\tMethod.invoke(obj, rs.getObject(columnAliasName));\n```\n## 11. 数据源与连接池\n### 11.1 简介\nDataSource用来取代DriverManager来获取Connection；\n通过DataSource获得Connection速度很快；\n通过DataSource获得的Connection都是已经被包裹过的(不是驱动原来的连接),他的close方法已经被修改。\n一般DataSource内部会用一个连接池来缓存Connection,这样可以大幅度提高数据库的访问速度；\n连接池可以理解成一个能够存放Connection的Collection；\n我们的程序只和DataSource打交道,不会直接访问连接池；\n### 11.2 简单数据源和连接池的实现\n使用装饰模式的Connection(核心代码)\n```java\nclass MyConnection implements Connection{\n\tprivate Connection realConn;\n\tprivate LinkedList connPool;\n\tMyConnection(Connection rConn, LinkedList cPool){\n\t\tthis.realConn=rConn;\n\t\tthis.connPool=cPool;\n\t}\n\tpublic void close(){\n\t\tthis.connPool.addLast(this);\n\t}\n\t//….\n}\n```\nDataSource(核心代码)\n```java\nclass MyDataSource implements DataSource{\n\tprivate LinkedList connPool = new Vector();\n\tpublic Connection getConneciton (){\n\t\tif(this.connPool.size()>0)\n\t\t\treturn this.connPool.removeFirst(0);\n\t\treturn createConnection();\n\t}\n\tprivate Connection createConnection(){\n\t  Connection realConn = DriverManager.getConnection();\n\t  Connection myConn = \n\t\tnew MyConnection(realConn,this.connPool);\n\t  return myConn;\n\t}\n\t//….\n}\n```\n### 11.3 常用的开源实现DBCP\n使用DBCP必须用的三个包：\n​\tcommons-dbcp-1.2.1.jar, commons-pool-1.2.jar, commons-collections-3.1.jar；\n配置参数：\njdbc.properties\n```java\n#连接设置\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/jdbc\nusername=root\npassword=root\n\n#<!-- 初始化连接 -->\ninitialSize=10\n\n#最大连接数量\nmaxActive=50\n\n#<!-- 最大空闲连接 -->\nmaxIdle=20\n\n#<!-- 最小空闲连接 -->\nminIdle=5\n\n#<!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 -->\nmaxWait=60000\n\n\n#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] \n#注意：\"user\" 与 \"password\" 两个属性会被明确地传递,因此这里不需要包含他们。\nconnectionProperties=useUnicode=true;characterEncoding=gbk\n\n#指定由连接池所创建的连接的自动提交(auto-commit)状态。\ndefaultAutoCommit=true\n\n#driver default 指定由连接池所创建的连接的只读(read-only)状态。\n#如果没有设置该值,则“setReadOnly”方法将不被调用。(某些驱动并不支持只读模式,如：Informix)\ndefaultReadOnly=\n\n#driver default 指定由连接池所创建的连接的事务级别(TransactionIsolation)。\n#可用值为下列之一：(详情可见javadoc。)NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE\ndefaultTransactionIsolation=READ_UNCOMMITTED\n```\n代码中读取配置信息\n```java\nProperties properties= new Properties();\nppt.load(ClassLoader.getSystemResourceAsStream(\"jdbc.properties\"));\nDataSource dataSource = BasicDataSourceFactory.createDataSource(properties)； \nConnection conn = dataSource.getConnection();\n```\n## 13. Spring的JDBC工具\n### 13.1 JdbcTemplate\n查询带有参数,和行映射方法：\n```java\npublic Object queryForObject(String sql, Object[] args, RowMapper rowMapper),使用自定义的UserRowMapper完成映射。\n一个RowMapper的常用实现BeanPropertyRowMapper,该实现可将结果集转换成一个Java Bean(字段名与Java Bean属性名不符合规范,可用别名处理)。\npublic List query(String sql, Object[] args, RowMapper rowMapper)返回多个结果。\npublic int queryForInt(String sql)(如:select count(*) from user),其他结果比如String可用queryForObject方法向下转型。\npublic Map queryForMap(String sql, Object[] args)返回若类型的Map(key：字段名或别名,value：列值)。\npublic List queryForList(String sql, Object[] args)返回多Map。\n```\n更新：\n```java\npublic int update(String sql, Object[] args)。\n```\n插入数据并获得结果：\n```java\npublic Object execute(ConnectionCallback action)\n```\n### 13.2 NamedParamterJdbcTemplate\n```java\nNamedParameterJdbcTemplate内部包含了一个JdbcTemplate,所以JdbcTemplate能做的事情NamedParameterJdbcTemplate都能干； \nNamedParameterJdbcTemplate相对于JdbcTemplate主要增加了参数可以命名的功能。\npublic Object queryForObject(String sql, Map paramMap, RowMapper rowMapper)\npublic Object queryForObject(String sql, SqlParameterSource paramSource, RowMapper rowMapper)\n\tSqlParameterSource的两个主要实现MapSqlParameterSource\n\t和BeanPropertySqlParameterSource\npublic int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)保存数据获得主键。\n```\n### 13.3 SimpleJdbcTemplate\n```java\nSimpleJdbcTemplate内部包含了一个NamedParameterJdbcTemplate;\n所以NamedParameterJdbcTemplate能做的事情SimpleJdbcTemplate都能干,SimpleJdbcTemplate相对于NamedParameterJdbcTemplate主要增加了JDK5.0的泛型和可变长度参数支持。\npublic <T> List<T> query(String sql, ParameterizedRowMapper<T> rm, Object... args)\npublic <T> T queryForObject(String sql, ParameterizedRowMapper<T> rm, SqlParameterSource args)\npublic <T> List<T> query(String sql, ParameterizedRowMapper<T> rm, SqlParameterSource args)\ngetJdbcOperations返回的是JdbcOperations(实现JdbcTemplate)\ngetNamedParameterJdbcOperations返回的是NamedParameterJdbcOperations(实现是NamedParameterJdbcTemplate)\n```","source":"_posts/JDBC学习笔记.md","raw":"---\ntitle: JDBC学习笔记\ndate: 2018-12-05 15:54:46\ntags: 学习笔记\n---\n\n# JDBC\n## 1. 简介\nJDBC(Java Data Base Connectivity,java数据库连接),由一些接口和类构成的API。\nJ2SE的一部分,由java.sql,javax.sql包组成。\n\n## 2. 连接数据库的步骤\n### 2.1 注册驱动 (只做一次)\n```java\nClass.forName(“com.mysql.jdbc.Driver”);\n\t推荐这种方式,不会对具体的驱动类产生依赖。\n\t\nDriverManager.registerDriver(com.mysql.jdbc.Driver);\n\t会造成DriverManager中产生两个一样的驱动,并会对具体的驱动类产生依赖。\n\t\nSystem.setProperty(“jdbc.drivers”, “driver1:driver2”);\n\t虽然不会对具体的驱动类产生依赖；但注册不太方便,所以很少使用。 \n\t\n驱动类型(四种类型)\n```\n### 2.2 建立连接(Connection) \n\n```java\nConnection conn = DriverManager.getConnection(url, user, password);\nurl格式：\n\tJDBC:子协议:子名称//主机名:端口/数据库名？属性名=属性值&…\nUser,password可以用“属性名=属性值”方式告诉数据库；\n其他参数如：useUnicode=true&characterEncoding=UTF-8&useSSL=false。\n```\n### 2.3 创建执行SQL的语句(Statement)\n```java\nStatement\n\tStatement st = conn.createStatement();\n\tst.executeQuery(sql);\nPreparedStatement\n\tString sql = “select * from table_name where col_name=?”;\n\tPreparedStatement ps = conn.preparedStatement(sql);\n\tps.setString(1, “col_value”);\n\tps.executeQuery();\n```\n### 2.4 执行语句\n```java\nps.executeQuery();\t//执行查询\nps.executeUpdate();\t//执行更新和插入和删除\t\n```\n### 2.5 处理执行结果(ResultSet)\n```java\nResultSet rs = statement.executeQuery(sql);\nWhile(rs.next()){\n\trs.getString(“col_name”);\n\trs.getInt(“col_name”);\n\t//…\n}\n```\n### 2.6 释放资源\n```java\n释放ResultSet, Statement,Connection.\n数据库连接(Connection)是非常稀有的资源,用完后必须马上释放,如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建,尽量早的释放。\n```\n## 3. 基本的CRUD(创建、读取、更新、删除) \n### 3.1 模板代码 \n```java\nConnection conn = null;\nStatement st=null;\nResultSet rs = null;\ntry {\n\t//获得Connection\n\t//创建Statement\n\t//处理查询结果ResultSet\n} finally {\n\t//释放资源ResultSet, Statement,Connection\n}\n```\n### 3.2 创建\n增加对应SQL的INSERT,返回增加成功的行(记录)数\n```java\nconn = getConnection();\nStatement st = conn.createStatement();\nString sql=“insert into user(name, age,regist_date )” +  \t\t“values(‘name’, 10, now())”;\nint i = st.executeUpdate(sql);\n//i为插入的记录数\n```\n### 3.3 读取\n读取(查询)对应SQL的SELECT,返回查询结果\n```java\nconn = getConnection();\nst = conn.createStatement();\nString sql = \"select id, name, age, regist_date from user\";\nrs = st.executeQuery(sql);\nwhile (rs.next()) {\n\t\tSystem.out.print(rs.getInt(\"id\") + \" \\t\\t \");\n\t\tSystem.out.print(rs.getString(\"name\") + \" \\t\\t \");\n\t\tSystem.out.print(rs.getInt(\"age\") + \" \\t\\t \");\n\t\tSystem.out.print(rs.getTimestamp(\"regist_date\") + \" \\t\\t \");\n\t\tSystem.out.println();\n}\n```\n### 3.4 更新\n更新(修改)对应SQL的UPDATE,返回被修改的行(记录)数 \n```java\nconn = getConnection();\nStatement st = conn.createStatement();\nString sql=“update person set name = 'new name‘”;\nint i = st.executeUpdate(sql);\n//i为符合条件的记录数\n```\n### 3.5 删除\n删除对应SQL的DELETE,返回被删除的行(记录)数 \n```java\nconn = getConnection();\nStatement st = conn.createStatement();\nString sql=“delete from user where id=1”;\nint i = st.executeUpdate(sql);\n//i为删掉的记录数\n```\n### 3.6 总结\n```java\n增、删、改用Statement.executeUpdate来完成,返回整数(匹配的记录数),这类操作相对简单。\n查询用Statement.executeQuery来完成,返回的是ResultSet对象,ResultSet中包含了查询的结果；查询相对于增、删、改要复杂一些,因为有查询结果要处理。\n```\n## 4. SQL注入,PreparedStatement和Statement\n```java\n在SQL中包含特殊字符或SQL的关键字(如：' or 1 or ')时Statement将出现不可预料的结果(出现异常或查询的结果不正确),可用PreparedStatement来解决。\nPreperedStatement(从Statement扩展而来)相对Statement的优点：\n\t1.没有SQL注入的问题。\n\t2.Statement会使数据库频繁编译SQL,可能造成数据库缓冲区溢出。\n\t3.数据库和驱动可以对PreperedStatement进行优化(只有在相关联的数据库连接没有关闭的情况下有效)。 \n```\n## 5. 数据类型\n```java\n详细信息见java.sql.Types\n几种特殊且比较常用的类型\n\t1.DATA,TIME,TIMESTAMP date,time,datetime\n存：ps.setDate(i,d); ps.setTime(i,t); ps.setTimestamp(i, ts);\n  \t  取：rs.getDate(i); rs.getTime(i); rs.getTimestamp(i);\n\t2.CLOB -> text(文本文件)\n\t  存：ps.setCharacterStream(index, reader, length);\n\t         ps.setString(i, s);\n\t  取：reader = rs. getCharacterStream(i);\n\t         reader = rs.getClob(i).getCharacterStream();\n\t         string = rs.getString(i);\n\t3.BLOB -> blob(字节文件,如图片)\n\t 存：ps.setBinaryStream(i, inputStream, length);\n       取：rs.getBinaryStream(i);\n\t        rs.getBlob(i).getBinaryStream(); \n```\n## 6. 一个简单用户相关的数据访问层 \nJ2EE三层架构简介\n​\t\t表示层 、业务逻辑层、数据访问层,三层之间用接口隔离。\n定义domain对象User,定义存取用户的接口\n用JDBC实现接口\n用配置文件(properties)和反射实现与具体类的耦合 \n## 7. 事务\n### 7.1 事务(ACID)\n原子性(atomicity)：组成事务处理的语句形成了一个逻辑单元,不能只执行其中的一部分。 \n一致性(consistency)：在事务处理执行前后,数据库是一致的(两个账户要么都变,或者都不变)。 \n隔离性(isolcation)：一个事务处理对另一个事务处理没有影响。 \n持续性(durability)：事务处理的效果能够被永久保存下来 。\n```java\nconnection.setAutoCommit(false);//打开事务。\nconnection.commit();//提交事务。\nconnection.rollback();//回滚事务。\n```\n### 7.2 事务(SavePoint)\n当只想撤销事务中的部分操作时可使用SavePoint\n```java\n//建立保存点\nSavePoint sp = connection.setSavepoint();\n//回滚到保存点\nconnection.rollerbak(sp);\n//提交事务\nconnection.commit();\n```\n### 7.4 事务(JTA)\n跨越多个数据源的事务,使用JTA容器实现事务。\n分成两阶段提交。\n```java\njavax.transaction.UserTransaction tx = (UserTransaction)ctx.lookup(“jndiName\");\n\ttx.begin();\n\t//connection1 connection2 (可能来自不同的数据库)… \n    tx.commit();//tx.rollback();\n```\n### 7.4 隔离级别多线程并发读取数据时的正确性 \nconnection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED); \nV:可能出现,X:不会出现\n| 隔离级别                   | 脏读 | 不可重复读 | 幻读 |\n| -------------------------- | ---- | ---------- | ---- |\n| 读未提交(Read Uncommitted) | V    | V          | V    |\n| 读已提交(Read Committed)   | X    | V          | V    |\n| 可重复读(Repeatable Read)  | X    | X          | V    |\n| 可串行化                   | X    | X          | X    |\n## 8. 存储过程\nCallableStatement(从PreperedStatement扩展来)\n```java\ncs = connection.prepareCall(“{call psname(?,?,?)}”);\ncs.registerOutParameter(index, Types.INTEGER);\ncs.setXXX(i, xxxx);\ncs.executeUpdate();\nint id=cs.getInt(index);\n```\n## 9. 其他的几个API\n返回插入语句的主键：Statement.getGeneratedKeys()\n```java\nPreparedStatement ps = connection.prepareStatement(sql,\tStatement.RETURN_GENERATED_KEYS);\nps.executeUpdate();\nResultSet rs = st.getGeneratedKeys();rs.getInt(1);\n```\n批处理,可以大幅度提升大量增、删、改的速度。\n```java\nPreparedStatement.addBatch();\nPreparedStatement.executeBatch();\n```\n可滚动的结果集\n```java\nStatement st = \nconnection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\tResultSet.CONCUR_UPDATABLE);\nResultSet rs = st.executeQuery(sql);\nrs.beforeFirst(); rs.afterLast();rs.first();rs.isFirst();rs.last();rs.isLast();\nrs.absolute(9);rs.moveToInsertRow();\n```\n可更新的结果集\n```java\nconn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\n\t\t\t\tResultSet.CONCUR_UPDATABLE);\nrs.updateString(\"col name\", \"new value\");\nrs.updateRow();\n```\n## 10. 元数据\n### 10.1 DatabaseMetaData\n```java\nDatabaseMetaData meta = connection.getMetaData();\n```\n通过DatabaseMetaData可以获得数据库相关的信息如：数据库版本、数据库名、数据库厂商信息、是否支持事务、是否支持某种事务隔离级别,是否支持滚动结果集等。\n### 10.2 ResultSetMetaData\n```java\nResultSetMetaData meta = rs.getMetaData();\n通过ResultSetMetaData可以获得结果有几列、各列名、各列别名、各列类型等。 \n可以将ResultSet放入Map(key:列名 value:列值)。\n用反射ResultSetMetaData将查询结果读入对象中(简单的O/RMapping) \n\t1)让SQL语句中列别名和要读入的对象属性名一样；\n\t2)通过ResultSetMetaData获得结果列数和列别名；\n\t3)通过反射将对象的所有setXxx方法找到;\n\t4)将3)找到的方法setXxx和2)找到的列别名进行匹配(即方法中的xxx于列别名相等)；\n\t5)由上一步找到的方法和列别名对应关系进行赋值\n\tMethod.invoke(obj, rs.getObject(columnAliasName));\n```\n## 11. 数据源与连接池\n### 11.1 简介\nDataSource用来取代DriverManager来获取Connection；\n通过DataSource获得Connection速度很快；\n通过DataSource获得的Connection都是已经被包裹过的(不是驱动原来的连接),他的close方法已经被修改。\n一般DataSource内部会用一个连接池来缓存Connection,这样可以大幅度提高数据库的访问速度；\n连接池可以理解成一个能够存放Connection的Collection；\n我们的程序只和DataSource打交道,不会直接访问连接池；\n### 11.2 简单数据源和连接池的实现\n使用装饰模式的Connection(核心代码)\n```java\nclass MyConnection implements Connection{\n\tprivate Connection realConn;\n\tprivate LinkedList connPool;\n\tMyConnection(Connection rConn, LinkedList cPool){\n\t\tthis.realConn=rConn;\n\t\tthis.connPool=cPool;\n\t}\n\tpublic void close(){\n\t\tthis.connPool.addLast(this);\n\t}\n\t//….\n}\n```\nDataSource(核心代码)\n```java\nclass MyDataSource implements DataSource{\n\tprivate LinkedList connPool = new Vector();\n\tpublic Connection getConneciton (){\n\t\tif(this.connPool.size()>0)\n\t\t\treturn this.connPool.removeFirst(0);\n\t\treturn createConnection();\n\t}\n\tprivate Connection createConnection(){\n\t  Connection realConn = DriverManager.getConnection();\n\t  Connection myConn = \n\t\tnew MyConnection(realConn,this.connPool);\n\t  return myConn;\n\t}\n\t//….\n}\n```\n### 11.3 常用的开源实现DBCP\n使用DBCP必须用的三个包：\n​\tcommons-dbcp-1.2.1.jar, commons-pool-1.2.jar, commons-collections-3.1.jar；\n配置参数：\njdbc.properties\n```java\n#连接设置\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/jdbc\nusername=root\npassword=root\n\n#<!-- 初始化连接 -->\ninitialSize=10\n\n#最大连接数量\nmaxActive=50\n\n#<!-- 最大空闲连接 -->\nmaxIdle=20\n\n#<!-- 最小空闲连接 -->\nminIdle=5\n\n#<!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 -->\nmaxWait=60000\n\n\n#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] \n#注意：\"user\" 与 \"password\" 两个属性会被明确地传递,因此这里不需要包含他们。\nconnectionProperties=useUnicode=true;characterEncoding=gbk\n\n#指定由连接池所创建的连接的自动提交(auto-commit)状态。\ndefaultAutoCommit=true\n\n#driver default 指定由连接池所创建的连接的只读(read-only)状态。\n#如果没有设置该值,则“setReadOnly”方法将不被调用。(某些驱动并不支持只读模式,如：Informix)\ndefaultReadOnly=\n\n#driver default 指定由连接池所创建的连接的事务级别(TransactionIsolation)。\n#可用值为下列之一：(详情可见javadoc。)NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE\ndefaultTransactionIsolation=READ_UNCOMMITTED\n```\n代码中读取配置信息\n```java\nProperties properties= new Properties();\nppt.load(ClassLoader.getSystemResourceAsStream(\"jdbc.properties\"));\nDataSource dataSource = BasicDataSourceFactory.createDataSource(properties)； \nConnection conn = dataSource.getConnection();\n```\n## 13. Spring的JDBC工具\n### 13.1 JdbcTemplate\n查询带有参数,和行映射方法：\n```java\npublic Object queryForObject(String sql, Object[] args, RowMapper rowMapper),使用自定义的UserRowMapper完成映射。\n一个RowMapper的常用实现BeanPropertyRowMapper,该实现可将结果集转换成一个Java Bean(字段名与Java Bean属性名不符合规范,可用别名处理)。\npublic List query(String sql, Object[] args, RowMapper rowMapper)返回多个结果。\npublic int queryForInt(String sql)(如:select count(*) from user),其他结果比如String可用queryForObject方法向下转型。\npublic Map queryForMap(String sql, Object[] args)返回若类型的Map(key：字段名或别名,value：列值)。\npublic List queryForList(String sql, Object[] args)返回多Map。\n```\n更新：\n```java\npublic int update(String sql, Object[] args)。\n```\n插入数据并获得结果：\n```java\npublic Object execute(ConnectionCallback action)\n```\n### 13.2 NamedParamterJdbcTemplate\n```java\nNamedParameterJdbcTemplate内部包含了一个JdbcTemplate,所以JdbcTemplate能做的事情NamedParameterJdbcTemplate都能干； \nNamedParameterJdbcTemplate相对于JdbcTemplate主要增加了参数可以命名的功能。\npublic Object queryForObject(String sql, Map paramMap, RowMapper rowMapper)\npublic Object queryForObject(String sql, SqlParameterSource paramSource, RowMapper rowMapper)\n\tSqlParameterSource的两个主要实现MapSqlParameterSource\n\t和BeanPropertySqlParameterSource\npublic int update(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)保存数据获得主键。\n```\n### 13.3 SimpleJdbcTemplate\n```java\nSimpleJdbcTemplate内部包含了一个NamedParameterJdbcTemplate;\n所以NamedParameterJdbcTemplate能做的事情SimpleJdbcTemplate都能干,SimpleJdbcTemplate相对于NamedParameterJdbcTemplate主要增加了JDK5.0的泛型和可变长度参数支持。\npublic <T> List<T> query(String sql, ParameterizedRowMapper<T> rm, Object... args)\npublic <T> T queryForObject(String sql, ParameterizedRowMapper<T> rm, SqlParameterSource args)\npublic <T> List<T> query(String sql, ParameterizedRowMapper<T> rm, SqlParameterSource args)\ngetJdbcOperations返回的是JdbcOperations(实现JdbcTemplate)\ngetNamedParameterJdbcOperations返回的是NamedParameterJdbcOperations(实现是NamedParameterJdbcTemplate)\n```","slug":"JDBC学习笔记","published":1,"updated":"2019-09-02T16:09:10.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck037qbqc0001liydpqm8u73i","content":"<h1 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h1><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>JDBC(Java Data Base Connectivity,java数据库连接),由一些接口和类构成的API。<br>J2SE的一部分,由java.sql,javax.sql包组成。</p>\n<h2 id=\"2-连接数据库的步骤\"><a href=\"#2-连接数据库的步骤\" class=\"headerlink\" title=\"2. 连接数据库的步骤\"></a>2. 连接数据库的步骤</h2><h3 id=\"2-1-注册驱动-只做一次\"><a href=\"#2-1-注册驱动-只做一次\" class=\"headerlink\" title=\"2.1 注册驱动 (只做一次)\"></a>2.1 注册驱动 (只做一次)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(“com.mysql.jdbc.Driver”);</span><br><span class=\"line\">\t推荐这种方式,不会对具体的驱动类产生依赖。</span><br><span class=\"line\">\t</span><br><span class=\"line\">DriverManager.registerDriver(com.mysql.jdbc.Driver);</span><br><span class=\"line\">\t会造成DriverManager中产生两个一样的驱动,并会对具体的驱动类产生依赖。</span><br><span class=\"line\">\t</span><br><span class=\"line\">System.setProperty(“jdbc.drivers”, “driver1:driver2”);</span><br><span class=\"line\">\t虽然不会对具体的驱动类产生依赖；但注册不太方便,所以很少使用。 </span><br><span class=\"line\">\t</span><br><span class=\"line\">驱动类型(四种类型)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-建立连接-Connection\"><a href=\"#2-2-建立连接-Connection\" class=\"headerlink\" title=\"2.2 建立连接(Connection)\"></a>2.2 建立连接(Connection)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">url格式：</span><br><span class=\"line\">\tJDBC:子协议:子名称<span class=\"comment\">//主机名:端口/数据库名？属性名=属性值&amp;…</span></span><br><span class=\"line\">User,password可以用“属性名=属性值”方式告诉数据库；</span><br><span class=\"line\">其他参数如：useUnicode=<span class=\"keyword\">true</span>&amp;characterEncoding=UTF-<span class=\"number\">8</span>&amp;useSSL=<span class=\"keyword\">false</span>。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-创建执行SQL的语句-Statement\"><a href=\"#2-3-创建执行SQL的语句-Statement\" class=\"headerlink\" title=\"2.3 创建执行SQL的语句(Statement)\"></a>2.3 创建执行SQL的语句(Statement)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Statement</span><br><span class=\"line\">\tStatement st = conn.createStatement();</span><br><span class=\"line\">\tst.executeQuery(sql);</span><br><span class=\"line\">PreparedStatement</span><br><span class=\"line\">\tString sql = “select * from table_name where col_name=?”;</span><br><span class=\"line\">\tPreparedStatement ps = conn.preparedStatement(sql);</span><br><span class=\"line\">\tps.setString(<span class=\"number\">1</span>, “col_value”);</span><br><span class=\"line\">\tps.executeQuery();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-执行语句\"><a href=\"#2-4-执行语句\" class=\"headerlink\" title=\"2.4 执行语句\"></a>2.4 执行语句</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps.executeQuery();\t<span class=\"comment\">//执行查询</span></span><br><span class=\"line\">ps.executeUpdate();\t<span class=\"comment\">//执行更新和插入和删除</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-处理执行结果-ResultSet\"><a href=\"#2-5-处理执行结果-ResultSet\" class=\"headerlink\" title=\"2.5 处理执行结果(ResultSet)\"></a>2.5 处理执行结果(ResultSet)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultSet rs = statement.executeQuery(sql);</span><br><span class=\"line\">While(rs.next())&#123;</span><br><span class=\"line\">\trs.getString(“col_name”);</span><br><span class=\"line\">\trs.getInt(“col_name”);</span><br><span class=\"line\">\t<span class=\"comment\">//…</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-6-释放资源\"><a href=\"#2-6-释放资源\" class=\"headerlink\" title=\"2.6 释放资源\"></a>2.6 释放资源</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">释放ResultSet, Statement,Connection.</span><br><span class=\"line\">数据库连接(Connection)是非常稀有的资源,用完后必须马上释放,如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建,尽量早的释放。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-基本的CRUD-创建、读取、更新、删除\"><a href=\"#3-基本的CRUD-创建、读取、更新、删除\" class=\"headerlink\" title=\"3. 基本的CRUD(创建、读取、更新、删除)\"></a>3. 基本的CRUD(创建、读取、更新、删除)</h2><h3 id=\"3-1-模板代码\"><a href=\"#3-1-模板代码\" class=\"headerlink\" title=\"3.1 模板代码\"></a>3.1 模板代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">Statement st=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">ResultSet rs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获得Connection</span></span><br><span class=\"line\">\t<span class=\"comment\">//创建Statement</span></span><br><span class=\"line\">\t<span class=\"comment\">//处理查询结果ResultSet</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//释放资源ResultSet, Statement,Connection</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-创建\"><a href=\"#3-2-创建\" class=\"headerlink\" title=\"3.2 创建\"></a>3.2 创建</h3><p>增加对应SQL的INSERT,返回增加成功的行(记录)数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">Statement st = conn.createStatement();</span><br><span class=\"line\">String sql=“<span class=\"function\">insert into <span class=\"title\">user</span><span class=\"params\">(name, age,regist_date )</span>” +  \t\t“<span class=\"title\">values</span><span class=\"params\">(‘name’, <span class=\"number\">10</span>, now()</span>)”</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = st.executeUpdate(sql);</span><br><span class=\"line\"><span class=\"comment\">//i为插入的记录数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-读取\"><a href=\"#3-3-读取\" class=\"headerlink\" title=\"3.3 读取\"></a>3.3 读取</h3><p>读取(查询)对应SQL的SELECT,返回查询结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">st = conn.createStatement();</span><br><span class=\"line\">String sql = <span class=\"string\">\"select id, name, age, regist_date from user\"</span>;</span><br><span class=\"line\">rs = st.executeQuery(sql);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">\t\tSystem.out.print(rs.getInt(<span class=\"string\">\"id\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.print(rs.getString(<span class=\"string\">\"name\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.print(rs.getInt(<span class=\"string\">\"age\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.print(rs.getTimestamp(<span class=\"string\">\"regist_date\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.println();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-更新\"><a href=\"#3-4-更新\" class=\"headerlink\" title=\"3.4 更新\"></a>3.4 更新</h3><p>更新(修改)对应SQL的UPDATE,返回被修改的行(记录)数 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">Statement st = conn.createStatement();</span><br><span class=\"line\">String sql=“update person set name = <span class=\"string\">'new name‘”;</span></span><br><span class=\"line\"><span class=\"string\">int i = st.executeUpdate(sql);</span></span><br><span class=\"line\"><span class=\"string\">//i为符合条件的记录数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-删除\"><a href=\"#3-5-删除\" class=\"headerlink\" title=\"3.5 删除\"></a>3.5 删除</h3><p>删除对应SQL的DELETE,返回被删除的行(记录)数 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">Statement st = conn.createStatement();</span><br><span class=\"line\">String sql=“delete from user where id=<span class=\"number\">1</span>”;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = st.executeUpdate(sql);</span><br><span class=\"line\"><span class=\"comment\">//i为删掉的记录数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-6-总结\"><a href=\"#3-6-总结\" class=\"headerlink\" title=\"3.6 总结\"></a>3.6 总结</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">增、删、改用Statement.executeUpdate来完成,返回整数(匹配的记录数),这类操作相对简单。</span><br><span class=\"line\">查询用Statement.executeQuery来完成,返回的是ResultSet对象,ResultSet中包含了查询的结果；查询相对于增、删、改要复杂一些,因为有查询结果要处理。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-SQL注入-PreparedStatement和Statement\"><a href=\"#4-SQL注入-PreparedStatement和Statement\" class=\"headerlink\" title=\"4. SQL注入,PreparedStatement和Statement\"></a>4. SQL注入,PreparedStatement和Statement</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在SQL中包含特殊字符或SQL的关键字(如：<span class=\"string\">' or 1 or '</span>)时Statement将出现不可预料的结果(出现异常或查询的结果不正确),可用PreparedStatement来解决。</span><br><span class=\"line\">PreperedStatement(从Statement扩展而来)相对Statement的优点：</span><br><span class=\"line\">\t<span class=\"number\">1</span>.没有SQL注入的问题。</span><br><span class=\"line\">\t<span class=\"number\">2</span>.Statement会使数据库频繁编译SQL,可能造成数据库缓冲区溢出。</span><br><span class=\"line\">\t<span class=\"number\">3</span>.数据库和驱动可以对PreperedStatement进行优化(只有在相关联的数据库连接没有关闭的情况下有效)。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-数据类型\"><a href=\"#5-数据类型\" class=\"headerlink\" title=\"5. 数据类型\"></a>5. 数据类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细信息见java.sql.Types</span><br><span class=\"line\">几种特殊且比较常用的类型</span><br><span class=\"line\">\t<span class=\"number\">1</span>.DATA,TIME,TIMESTAMP date,time,datetime</span><br><span class=\"line\">存：ps.setDate(i,d); ps.setTime(i,t); ps.setTimestamp(i, ts);</span><br><span class=\"line\">  \t  取：rs.getDate(i); rs.getTime(i); rs.getTimestamp(i);</span><br><span class=\"line\">\t<span class=\"number\">2</span>.CLOB -&gt; text(文本文件)</span><br><span class=\"line\">\t  存：ps.setCharacterStream(index, reader, length);</span><br><span class=\"line\">\t         ps.setString(i, s);</span><br><span class=\"line\">\t  取：reader = rs. getCharacterStream(i);</span><br><span class=\"line\">\t         reader = rs.getClob(i).getCharacterStream();</span><br><span class=\"line\">\t         string = rs.getString(i);</span><br><span class=\"line\">\t<span class=\"number\">3</span>.BLOB -&gt; blob(字节文件,如图片)</span><br><span class=\"line\">\t 存：ps.setBinaryStream(i, inputStream, length);</span><br><span class=\"line\">       取：rs.getBinaryStream(i);</span><br><span class=\"line\">\t        rs.getBlob(i).getBinaryStream();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-一个简单用户相关的数据访问层\"><a href=\"#6-一个简单用户相关的数据访问层\" class=\"headerlink\" title=\"6. 一个简单用户相关的数据访问层\"></a>6. 一个简单用户相关的数据访问层</h2><p>J2EE三层架构简介<br>​        表示层 、业务逻辑层、数据访问层,三层之间用接口隔离。<br>定义domain对象User,定义存取用户的接口<br>用JDBC实现接口<br>用配置文件(properties)和反射实现与具体类的耦合 </p>\n<h2 id=\"7-事务\"><a href=\"#7-事务\" class=\"headerlink\" title=\"7. 事务\"></a>7. 事务</h2><h3 id=\"7-1-事务-ACID\"><a href=\"#7-1-事务-ACID\" class=\"headerlink\" title=\"7.1 事务(ACID)\"></a>7.1 事务(ACID)</h3><p>原子性(atomicity)：组成事务处理的语句形成了一个逻辑单元,不能只执行其中的一部分。<br>一致性(consistency)：在事务处理执行前后,数据库是一致的(两个账户要么都变,或者都不变)。<br>隔离性(isolcation)：一个事务处理对另一个事务处理没有影响。<br>持续性(durability)：事务处理的效果能够被永久保存下来 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.setAutoCommit(<span class=\"keyword\">false</span>);<span class=\"comment\">//打开事务。</span></span><br><span class=\"line\">connection.commit();<span class=\"comment\">//提交事务。</span></span><br><span class=\"line\">connection.rollback();<span class=\"comment\">//回滚事务。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-事务-SavePoint\"><a href=\"#7-2-事务-SavePoint\" class=\"headerlink\" title=\"7.2 事务(SavePoint)\"></a>7.2 事务(SavePoint)</h3><p>当只想撤销事务中的部分操作时可使用SavePoint</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//建立保存点</span></span><br><span class=\"line\">SavePoint sp = connection.setSavepoint();</span><br><span class=\"line\"><span class=\"comment\">//回滚到保存点</span></span><br><span class=\"line\">connection.rollerbak(sp);</span><br><span class=\"line\"><span class=\"comment\">//提交事务</span></span><br><span class=\"line\">connection.commit();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-事务-JTA\"><a href=\"#7-4-事务-JTA\" class=\"headerlink\" title=\"7.4 事务(JTA)\"></a>7.4 事务(JTA)</h3><p>跨越多个数据源的事务,使用JTA容器实现事务。<br>分成两阶段提交。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javax.transaction.UserTransaction tx = (UserTransaction)ctx.lookup(“jndiName<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\ttx.begin();</span></span><br><span class=\"line\"><span class=\"string\">\t//connection1 connection2 (可能来自不同的数据库)… </span></span><br><span class=\"line\"><span class=\"string\">    tx.commit();//tx.rollback();</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-隔离级别多线程并发读取数据时的正确性\"><a href=\"#7-4-隔离级别多线程并发读取数据时的正确性\" class=\"headerlink\" title=\"7.4 隔离级别多线程并发读取数据时的正确性\"></a>7.4 隔离级别多线程并发读取数据时的正确性</h3><p>connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);<br>V:可能出现,X:不会出现<br>| 隔离级别                   | 脏读 | 不可重复读 | 幻读 |<br>| ————————– | —- | ———- | —- |<br>| 读未提交(Read Uncommitted) | V    | V          | V    |<br>| 读已提交(Read Committed)   | X    | V          | V    |<br>| 可重复读(Repeatable Read)  | X    | X          | V    |<br>| 可串行化                   | X    | X          | X    |</p>\n<h2 id=\"8-存储过程\"><a href=\"#8-存储过程\" class=\"headerlink\" title=\"8. 存储过程\"></a>8. 存储过程</h2><p>CallableStatement(从PreperedStatement扩展来)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cs = connection.prepareCall(“&#123;<span class=\"function\">call <span class=\"title\">psname</span><span class=\"params\">(?,?,?)</span>&#125;”)</span>;</span><br><span class=\"line\">cs.registerOutParameter(index, Types.INTEGER);</span><br><span class=\"line\">cs.setXXX(i, xxxx);</span><br><span class=\"line\">cs.executeUpdate();</span><br><span class=\"line\"><span class=\"keyword\">int</span> id=cs.getInt(index);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-其他的几个API\"><a href=\"#9-其他的几个API\" class=\"headerlink\" title=\"9. 其他的几个API\"></a>9. 其他的几个API</h2><p>返回插入语句的主键：Statement.getGeneratedKeys()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PreparedStatement ps = connection.prepareStatement(sql,\tStatement.RETURN_GENERATED_KEYS);</span><br><span class=\"line\">ps.executeUpdate();</span><br><span class=\"line\">ResultSet rs = st.getGeneratedKeys();rs.getInt(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>批处理,可以大幅度提升大量增、删、改的速度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PreparedStatement.addBatch();</span><br><span class=\"line\">PreparedStatement.executeBatch();</span><br></pre></td></tr></table></figure>\n\n<p>可滚动的结果集</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Statement st = </span><br><span class=\"line\">connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\tResultSet.CONCUR_UPDATABLE);</span><br><span class=\"line\">ResultSet rs = st.executeQuery(sql);</span><br><span class=\"line\">rs.beforeFirst(); rs.afterLast();rs.first();rs.isFirst();rs.last();rs.isLast();</span><br><span class=\"line\">rs.absolute(<span class=\"number\">9</span>);rs.moveToInsertRow();</span><br></pre></td></tr></table></figure>\n\n<p>可更新的结果集</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,</span><br><span class=\"line\">\t\t\t\tResultSet.CONCUR_UPDATABLE);</span><br><span class=\"line\">rs.updateString(<span class=\"string\">\"col name\"</span>, <span class=\"string\">\"new value\"</span>);</span><br><span class=\"line\">rs.updateRow();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-元数据\"><a href=\"#10-元数据\" class=\"headerlink\" title=\"10. 元数据\"></a>10. 元数据</h2><h3 id=\"10-1-DatabaseMetaData\"><a href=\"#10-1-DatabaseMetaData\" class=\"headerlink\" title=\"10.1 DatabaseMetaData\"></a>10.1 DatabaseMetaData</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DatabaseMetaData meta = connection.getMetaData();</span><br></pre></td></tr></table></figure>\n\n<p>通过DatabaseMetaData可以获得数据库相关的信息如：数据库版本、数据库名、数据库厂商信息、是否支持事务、是否支持某种事务隔离级别,是否支持滚动结果集等。</p>\n<h3 id=\"10-2-ResultSetMetaData\"><a href=\"#10-2-ResultSetMetaData\" class=\"headerlink\" title=\"10.2 ResultSetMetaData\"></a>10.2 ResultSetMetaData</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultSetMetaData meta = rs.getMetaData();</span><br><span class=\"line\">通过ResultSetMetaData可以获得结果有几列、各列名、各列别名、各列类型等。 </span><br><span class=\"line\">可以将ResultSet放入Map(key:列名 value:列值)。</span><br><span class=\"line\">用反射ResultSetMetaData将查询结果读入对象中(简单的O/RMapping) </span><br><span class=\"line\">\t<span class=\"number\">1</span>)让SQL语句中列别名和要读入的对象属性名一样；</span><br><span class=\"line\">\t<span class=\"number\">2</span>)通过ResultSetMetaData获得结果列数和列别名；</span><br><span class=\"line\">\t<span class=\"number\">3</span>)通过反射将对象的所有setXxx方法找到;</span><br><span class=\"line\">\t<span class=\"number\">4</span>)将<span class=\"number\">3</span>)找到的方法setXxx和<span class=\"number\">2</span>)找到的列别名进行匹配(即方法中的xxx于列别名相等)；</span><br><span class=\"line\">\t<span class=\"number\">5</span>)由上一步找到的方法和列别名对应关系进行赋值</span><br><span class=\"line\">\tMethod.invoke(obj, rs.getObject(columnAliasName));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-数据源与连接池\"><a href=\"#11-数据源与连接池\" class=\"headerlink\" title=\"11. 数据源与连接池\"></a>11. 数据源与连接池</h2><h3 id=\"11-1-简介\"><a href=\"#11-1-简介\" class=\"headerlink\" title=\"11.1 简介\"></a>11.1 简介</h3><p>DataSource用来取代DriverManager来获取Connection；<br>通过DataSource获得Connection速度很快；<br>通过DataSource获得的Connection都是已经被包裹过的(不是驱动原来的连接),他的close方法已经被修改。<br>一般DataSource内部会用一个连接池来缓存Connection,这样可以大幅度提高数据库的访问速度；<br>连接池可以理解成一个能够存放Connection的Collection；<br>我们的程序只和DataSource打交道,不会直接访问连接池；</p>\n<h3 id=\"11-2-简单数据源和连接池的实现\"><a href=\"#11-2-简单数据源和连接池的实现\" class=\"headerlink\" title=\"11.2 简单数据源和连接池的实现\"></a>11.2 简单数据源和连接池的实现</h3><p>使用装饰模式的Connection(核心代码)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConnection</span> <span class=\"keyword\">implements</span> <span class=\"title\">Connection</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Connection realConn;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> LinkedList connPool;</span><br><span class=\"line\">\tMyConnection(Connection rConn, LinkedList cPool)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.realConn=rConn;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.connPool=cPool;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.connPool.addLast(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//….</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DataSource(核心代码)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDataSource</span> <span class=\"keyword\">implements</span> <span class=\"title\">DataSource</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> LinkedList connPool = <span class=\"keyword\">new</span> Vector();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">getConneciton</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.connPool.size()&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.connPool.removeFirst(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> createConnection();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Connection <span class=\"title\">createConnection</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t  Connection realConn = DriverManager.getConnection();</span><br><span class=\"line\">\t  Connection myConn = </span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> MyConnection(realConn,<span class=\"keyword\">this</span>.connPool);</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> myConn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//….</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-3-常用的开源实现DBCP\"><a href=\"#11-3-常用的开源实现DBCP\" class=\"headerlink\" title=\"11.3 常用的开源实现DBCP\"></a>11.3 常用的开源实现DBCP</h3><p>使用DBCP必须用的三个包：<br>​    commons-dbcp-1.2.1.jar, commons-pool-1.2.jar, commons-collections-3.1.jar；<br>配置参数：<br>jdbc.properties</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#连接设置</span><br><span class=\"line\">driverClassName=com.mysql.jdbc.Driver</span><br><span class=\"line\">url=jdbc:mysql:<span class=\"comment\">//localhost:3306/jdbc</span></span><br><span class=\"line\">username=root</span><br><span class=\"line\">password=root</span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 初始化连接 --&gt;</span><br><span class=\"line\">initialSize=<span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">#最大连接数量</span><br><span class=\"line\">maxActive=<span class=\"number\">50</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 最大空闲连接 --&gt;</span><br><span class=\"line\">maxIdle=<span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 最小空闲连接 --&gt;</span><br><span class=\"line\">minIdle=<span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;</span><br><span class=\"line\">maxWait=<span class=\"number\">60000</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] </span><br><span class=\"line\">#注意：\"user\" 与 \"password\" 两个属性会被明确地传递,因此这里不需要包含他们。</span><br><span class=\"line\">connectionProperties=useUnicode=<span class=\"keyword\">true</span>;characterEncoding=gbk</span><br><span class=\"line\"></span><br><span class=\"line\">#指定由连接池所创建的连接的自动提交(auto-commit)状态。</span><br><span class=\"line\">defaultAutoCommit=<span class=\"keyword\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">#driver default 指定由连接池所创建的连接的只读(read-only)状态。</span><br><span class=\"line\">#如果没有设置该值,则“setReadOnly”方法将不被调用。(某些驱动并不支持只读模式,如：Informix)</span><br><span class=\"line\">defaultReadOnly=</span><br><span class=\"line\"></span><br><span class=\"line\">#driver default 指定由连接池所创建的连接的事务级别(TransactionIsolation)。</span><br><span class=\"line\">#可用值为下列之一：(详情可见javadoc。)NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE</span><br><span class=\"line\">defaultTransactionIsolation=READ_UNCOMMITTED</span><br></pre></td></tr></table></figure>\n\n<p>代码中读取配置信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties properties= <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">ppt.load(ClassLoader.getSystemResourceAsStream(<span class=\"string\">\"jdbc.properties\"</span>));</span><br><span class=\"line\">DataSource dataSource = BasicDataSourceFactory.createDataSource(properties)； </span><br><span class=\"line\">Connection conn = dataSource.getConnection();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-Spring的JDBC工具\"><a href=\"#13-Spring的JDBC工具\" class=\"headerlink\" title=\"13. Spring的JDBC工具\"></a>13. Spring的JDBC工具</h2><h3 id=\"13-1-JdbcTemplate\"><a href=\"#13-1-JdbcTemplate\" class=\"headerlink\" title=\"13.1 JdbcTemplate\"></a>13.1 JdbcTemplate</h3><p>查询带有参数,和行映射方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, Object[] args, RowMapper rowMapper)</span>,使用自定义的UserRowMapper完成映射。</span></span><br><span class=\"line\"><span class=\"function\">一个RowMapper的常用实现BeanPropertyRowMapper,该实现可将结果集转换成一个Java <span class=\"title\">Bean</span><span class=\"params\">(字段名与Java Bean属性名不符合规范,可用别名处理)</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List <span class=\"title\">query</span><span class=\"params\">(String sql, Object[] args, RowMapper rowMapper)</span>返回多个结果。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">queryForInt</span><span class=\"params\">(String sql)</span><span class=\"params\">(如:select count(*)</span> from user),其他结果比如String可用queryForObject方法向下转型。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">queryForMap</span><span class=\"params\">(String sql, Object[] args)</span>返回若类型的<span class=\"title\">Map</span><span class=\"params\">(key：字段名或别名,value：列值)</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List <span class=\"title\">queryForList</span><span class=\"params\">(String sql, Object[] args)</span>返回多Map。</span></span><br></pre></td></tr></table></figure>\n\n<p>更新：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(String sql, Object[] args)</span>。</span></span><br></pre></td></tr></table></figure>\n\n<p>插入数据并获得结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">execute</span><span class=\"params\">(ConnectionCallback action)</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-NamedParamterJdbcTemplate\"><a href=\"#13-2-NamedParamterJdbcTemplate\" class=\"headerlink\" title=\"13.2 NamedParamterJdbcTemplate\"></a>13.2 NamedParamterJdbcTemplate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NamedParameterJdbcTemplate内部包含了一个JdbcTemplate,所以JdbcTemplate能做的事情NamedParameterJdbcTemplate都能干； </span><br><span class=\"line\">NamedParameterJdbcTemplate相对于JdbcTemplate主要增加了参数可以命名的功能。</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, Map paramMap, RowMapper rowMapper)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, SqlParameterSource paramSource, RowMapper rowMapper)</span></span></span><br><span class=\"line\"><span class=\"function\">\tSqlParameterSource的两个主要实现MapSqlParameterSource</span></span><br><span class=\"line\"><span class=\"function\">\t和BeanPropertySqlParameterSource</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)</span>保存数据获得主键。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3-SimpleJdbcTemplate\"><a href=\"#13-3-SimpleJdbcTemplate\" class=\"headerlink\" title=\"13.3 SimpleJdbcTemplate\"></a>13.3 SimpleJdbcTemplate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleJdbcTemplate内部包含了一个NamedParameterJdbcTemplate;</span><br><span class=\"line\">所以NamedParameterJdbcTemplate能做的事情SimpleJdbcTemplate都能干,SimpleJdbcTemplate相对于NamedParameterJdbcTemplate主要增加了JDK5.0的泛型和可变长度参数支持。</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">query</span><span class=\"params\">(String sql, ParameterizedRowMapper&lt;T&gt; rm, Object... args)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, ParameterizedRowMapper&lt;T&gt; rm, SqlParameterSource args)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> &lt;T&gt; List&lt;T&gt; <span class=\"title\">query</span><span class=\"params\">(String sql, ParameterizedRowMapper&lt;T&gt; rm, SqlParameterSource args)</span></span></span><br><span class=\"line\"><span class=\"function\">getJdbcOperations返回的是<span class=\"title\">JdbcOperations</span><span class=\"params\">(实现JdbcTemplate)</span></span></span><br><span class=\"line\"><span class=\"function\">getNamedParameterJdbcOperations返回的是<span class=\"title\">NamedParameterJdbcOperations</span><span class=\"params\">(实现是NamedParameterJdbcTemplate)</span></span></span><br></pre></td></tr></table></figure>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h1 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h1><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><p>JDBC(Java Data Base Connectivity,java数据库连接),由一些接口和类构成的API。<br>J2SE的一部分,由java.sql,javax.sql包组成。</p>\n<h2 id=\"2-连接数据库的步骤\"><a href=\"#2-连接数据库的步骤\" class=\"headerlink\" title=\"2. 连接数据库的步骤\"></a>2. 连接数据库的步骤</h2><h3 id=\"2-1-注册驱动-只做一次\"><a href=\"#2-1-注册驱动-只做一次\" class=\"headerlink\" title=\"2.1 注册驱动 (只做一次)\"></a>2.1 注册驱动 (只做一次)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class.forName(“com.mysql.jdbc.Driver”);</span><br><span class=\"line\">\t推荐这种方式,不会对具体的驱动类产生依赖。</span><br><span class=\"line\">\t</span><br><span class=\"line\">DriverManager.registerDriver(com.mysql.jdbc.Driver);</span><br><span class=\"line\">\t会造成DriverManager中产生两个一样的驱动,并会对具体的驱动类产生依赖。</span><br><span class=\"line\">\t</span><br><span class=\"line\">System.setProperty(“jdbc.drivers”, “driver1:driver2”);</span><br><span class=\"line\">\t虽然不会对具体的驱动类产生依赖；但注册不太方便,所以很少使用。 </span><br><span class=\"line\">\t</span><br><span class=\"line\">驱动类型(四种类型)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-建立连接-Connection\"><a href=\"#2-2-建立连接-Connection\" class=\"headerlink\" title=\"2.2 建立连接(Connection)\"></a>2.2 建立连接(Connection)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class=\"line\">url格式：</span><br><span class=\"line\">\tJDBC:子协议:子名称<span class=\"comment\">//主机名:端口/数据库名？属性名=属性值&amp;…</span></span><br><span class=\"line\">User,password可以用“属性名=属性值”方式告诉数据库；</span><br><span class=\"line\">其他参数如：useUnicode=<span class=\"keyword\">true</span>&amp;characterEncoding=UTF-<span class=\"number\">8</span>&amp;useSSL=<span class=\"keyword\">false</span>。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-创建执行SQL的语句-Statement\"><a href=\"#2-3-创建执行SQL的语句-Statement\" class=\"headerlink\" title=\"2.3 创建执行SQL的语句(Statement)\"></a>2.3 创建执行SQL的语句(Statement)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Statement</span><br><span class=\"line\">\tStatement st = conn.createStatement();</span><br><span class=\"line\">\tst.executeQuery(sql);</span><br><span class=\"line\">PreparedStatement</span><br><span class=\"line\">\tString sql = “select * from table_name where col_name=?”;</span><br><span class=\"line\">\tPreparedStatement ps = conn.preparedStatement(sql);</span><br><span class=\"line\">\tps.setString(<span class=\"number\">1</span>, “col_value”);</span><br><span class=\"line\">\tps.executeQuery();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-执行语句\"><a href=\"#2-4-执行语句\" class=\"headerlink\" title=\"2.4 执行语句\"></a>2.4 执行语句</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps.executeQuery();\t<span class=\"comment\">//执行查询</span></span><br><span class=\"line\">ps.executeUpdate();\t<span class=\"comment\">//执行更新和插入和删除</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-处理执行结果-ResultSet\"><a href=\"#2-5-处理执行结果-ResultSet\" class=\"headerlink\" title=\"2.5 处理执行结果(ResultSet)\"></a>2.5 处理执行结果(ResultSet)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultSet rs = statement.executeQuery(sql);</span><br><span class=\"line\">While(rs.next())&#123;</span><br><span class=\"line\">\trs.getString(“col_name”);</span><br><span class=\"line\">\trs.getInt(“col_name”);</span><br><span class=\"line\">\t<span class=\"comment\">//…</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-6-释放资源\"><a href=\"#2-6-释放资源\" class=\"headerlink\" title=\"2.6 释放资源\"></a>2.6 释放资源</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">释放ResultSet, Statement,Connection.</span><br><span class=\"line\">数据库连接(Connection)是非常稀有的资源,用完后必须马上释放,如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建,尽量早的释放。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-基本的CRUD-创建、读取、更新、删除\"><a href=\"#3-基本的CRUD-创建、读取、更新、删除\" class=\"headerlink\" title=\"3. 基本的CRUD(创建、读取、更新、删除)\"></a>3. 基本的CRUD(创建、读取、更新、删除)</h2><h3 id=\"3-1-模板代码\"><a href=\"#3-1-模板代码\" class=\"headerlink\" title=\"3.1 模板代码\"></a>3.1 模板代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">Statement st=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">ResultSet rs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获得Connection</span></span><br><span class=\"line\">\t<span class=\"comment\">//创建Statement</span></span><br><span class=\"line\">\t<span class=\"comment\">//处理查询结果ResultSet</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//释放资源ResultSet, Statement,Connection</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-创建\"><a href=\"#3-2-创建\" class=\"headerlink\" title=\"3.2 创建\"></a>3.2 创建</h3><p>增加对应SQL的INSERT,返回增加成功的行(记录)数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">Statement st = conn.createStatement();</span><br><span class=\"line\">String sql=“<span class=\"function\">insert into <span class=\"title\">user</span><span class=\"params\">(name, age,regist_date )</span>” +  \t\t“<span class=\"title\">values</span><span class=\"params\">(‘name’, <span class=\"number\">10</span>, now()</span>)”</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = st.executeUpdate(sql);</span><br><span class=\"line\"><span class=\"comment\">//i为插入的记录数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-读取\"><a href=\"#3-3-读取\" class=\"headerlink\" title=\"3.3 读取\"></a>3.3 读取</h3><p>读取(查询)对应SQL的SELECT,返回查询结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">st = conn.createStatement();</span><br><span class=\"line\">String sql = <span class=\"string\">\"select id, name, age, regist_date from user\"</span>;</span><br><span class=\"line\">rs = st.executeQuery(sql);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">\t\tSystem.out.print(rs.getInt(<span class=\"string\">\"id\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.print(rs.getString(<span class=\"string\">\"name\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.print(rs.getInt(<span class=\"string\">\"age\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.print(rs.getTimestamp(<span class=\"string\">\"regist_date\"</span>) + <span class=\"string\">\" \\t\\t \"</span>);</span><br><span class=\"line\">\t\tSystem.out.println();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-更新\"><a href=\"#3-4-更新\" class=\"headerlink\" title=\"3.4 更新\"></a>3.4 更新</h3><p>更新(修改)对应SQL的UPDATE,返回被修改的行(记录)数 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">Statement st = conn.createStatement();</span><br><span class=\"line\">String sql=“update person set name = <span class=\"string\">'new name‘”;</span></span><br><span class=\"line\"><span class=\"string\">int i = st.executeUpdate(sql);</span></span><br><span class=\"line\"><span class=\"string\">//i为符合条件的记录数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-删除\"><a href=\"#3-5-删除\" class=\"headerlink\" title=\"3.5 删除\"></a>3.5 删除</h3><p>删除对应SQL的DELETE,返回被删除的行(记录)数 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn = getConnection();</span><br><span class=\"line\">Statement st = conn.createStatement();</span><br><span class=\"line\">String sql=“delete from user where id=<span class=\"number\">1</span>”;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = st.executeUpdate(sql);</span><br><span class=\"line\"><span class=\"comment\">//i为删掉的记录数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-6-总结\"><a href=\"#3-6-总结\" class=\"headerlink\" title=\"3.6 总结\"></a>3.6 总结</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">增、删、改用Statement.executeUpdate来完成,返回整数(匹配的记录数),这类操作相对简单。</span><br><span class=\"line\">查询用Statement.executeQuery来完成,返回的是ResultSet对象,ResultSet中包含了查询的结果；查询相对于增、删、改要复杂一些,因为有查询结果要处理。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-SQL注入-PreparedStatement和Statement\"><a href=\"#4-SQL注入-PreparedStatement和Statement\" class=\"headerlink\" title=\"4. SQL注入,PreparedStatement和Statement\"></a>4. SQL注入,PreparedStatement和Statement</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在SQL中包含特殊字符或SQL的关键字(如：<span class=\"string\">' or 1 or '</span>)时Statement将出现不可预料的结果(出现异常或查询的结果不正确),可用PreparedStatement来解决。</span><br><span class=\"line\">PreperedStatement(从Statement扩展而来)相对Statement的优点：</span><br><span class=\"line\">\t<span class=\"number\">1</span>.没有SQL注入的问题。</span><br><span class=\"line\">\t<span class=\"number\">2</span>.Statement会使数据库频繁编译SQL,可能造成数据库缓冲区溢出。</span><br><span class=\"line\">\t<span class=\"number\">3</span>.数据库和驱动可以对PreperedStatement进行优化(只有在相关联的数据库连接没有关闭的情况下有效)。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-数据类型\"><a href=\"#5-数据类型\" class=\"headerlink\" title=\"5. 数据类型\"></a>5. 数据类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细信息见java.sql.Types</span><br><span class=\"line\">几种特殊且比较常用的类型</span><br><span class=\"line\">\t<span class=\"number\">1</span>.DATA,TIME,TIMESTAMP date,time,datetime</span><br><span class=\"line\">存：ps.setDate(i,d); ps.setTime(i,t); ps.setTimestamp(i, ts);</span><br><span class=\"line\">  \t  取：rs.getDate(i); rs.getTime(i); rs.getTimestamp(i);</span><br><span class=\"line\">\t<span class=\"number\">2</span>.CLOB -&gt; text(文本文件)</span><br><span class=\"line\">\t  存：ps.setCharacterStream(index, reader, length);</span><br><span class=\"line\">\t         ps.setString(i, s);</span><br><span class=\"line\">\t  取：reader = rs. getCharacterStream(i);</span><br><span class=\"line\">\t         reader = rs.getClob(i).getCharacterStream();</span><br><span class=\"line\">\t         string = rs.getString(i);</span><br><span class=\"line\">\t<span class=\"number\">3</span>.BLOB -&gt; blob(字节文件,如图片)</span><br><span class=\"line\">\t 存：ps.setBinaryStream(i, inputStream, length);</span><br><span class=\"line\">       取：rs.getBinaryStream(i);</span><br><span class=\"line\">\t        rs.getBlob(i).getBinaryStream();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-一个简单用户相关的数据访问层\"><a href=\"#6-一个简单用户相关的数据访问层\" class=\"headerlink\" title=\"6. 一个简单用户相关的数据访问层\"></a>6. 一个简单用户相关的数据访问层</h2><p>J2EE三层架构简介<br>​        表示层 、业务逻辑层、数据访问层,三层之间用接口隔离。<br>定义domain对象User,定义存取用户的接口<br>用JDBC实现接口<br>用配置文件(properties)和反射实现与具体类的耦合 </p>\n<h2 id=\"7-事务\"><a href=\"#7-事务\" class=\"headerlink\" title=\"7. 事务\"></a>7. 事务</h2><h3 id=\"7-1-事务-ACID\"><a href=\"#7-1-事务-ACID\" class=\"headerlink\" title=\"7.1 事务(ACID)\"></a>7.1 事务(ACID)</h3><p>原子性(atomicity)：组成事务处理的语句形成了一个逻辑单元,不能只执行其中的一部分。<br>一致性(consistency)：在事务处理执行前后,数据库是一致的(两个账户要么都变,或者都不变)。<br>隔离性(isolcation)：一个事务处理对另一个事务处理没有影响。<br>持续性(durability)：事务处理的效果能够被永久保存下来 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.setAutoCommit(<span class=\"keyword\">false</span>);<span class=\"comment\">//打开事务。</span></span><br><span class=\"line\">connection.commit();<span class=\"comment\">//提交事务。</span></span><br><span class=\"line\">connection.rollback();<span class=\"comment\">//回滚事务。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-2-事务-SavePoint\"><a href=\"#7-2-事务-SavePoint\" class=\"headerlink\" title=\"7.2 事务(SavePoint)\"></a>7.2 事务(SavePoint)</h3><p>当只想撤销事务中的部分操作时可使用SavePoint</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//建立保存点</span></span><br><span class=\"line\">SavePoint sp = connection.setSavepoint();</span><br><span class=\"line\"><span class=\"comment\">//回滚到保存点</span></span><br><span class=\"line\">connection.rollerbak(sp);</span><br><span class=\"line\"><span class=\"comment\">//提交事务</span></span><br><span class=\"line\">connection.commit();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-事务-JTA\"><a href=\"#7-4-事务-JTA\" class=\"headerlink\" title=\"7.4 事务(JTA)\"></a>7.4 事务(JTA)</h3><p>跨越多个数据源的事务,使用JTA容器实现事务。<br>分成两阶段提交。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javax.transaction.UserTransaction tx = (UserTransaction)ctx.lookup(“jndiName<span class=\"string\">\");</span></span><br><span class=\"line\"><span class=\"string\">\ttx.begin();</span></span><br><span class=\"line\"><span class=\"string\">\t//connection1 connection2 (可能来自不同的数据库)… </span></span><br><span class=\"line\"><span class=\"string\">    tx.commit();//tx.rollback();</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-4-隔离级别多线程并发读取数据时的正确性\"><a href=\"#7-4-隔离级别多线程并发读取数据时的正确性\" class=\"headerlink\" title=\"7.4 隔离级别多线程并发读取数据时的正确性\"></a>7.4 隔离级别多线程并发读取数据时的正确性</h3><p>connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);<br>V:可能出现,X:不会出现<br>| 隔离级别                   | 脏读 | 不可重复读 | 幻读 |<br>| ————————– | —- | ———- | —- |<br>| 读未提交(Read Uncommitted) | V    | V          | V    |<br>| 读已提交(Read Committed)   | X    | V          | V    |<br>| 可重复读(Repeatable Read)  | X    | X          | V    |<br>| 可串行化                   | X    | X          | X    |</p>\n<h2 id=\"8-存储过程\"><a href=\"#8-存储过程\" class=\"headerlink\" title=\"8. 存储过程\"></a>8. 存储过程</h2><p>CallableStatement(从PreperedStatement扩展来)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cs = connection.prepareCall(“&#123;<span class=\"function\">call <span class=\"title\">psname</span><span class=\"params\">(?,?,?)</span>&#125;”)</span>;</span><br><span class=\"line\">cs.registerOutParameter(index, Types.INTEGER);</span><br><span class=\"line\">cs.setXXX(i, xxxx);</span><br><span class=\"line\">cs.executeUpdate();</span><br><span class=\"line\"><span class=\"keyword\">int</span> id=cs.getInt(index);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-其他的几个API\"><a href=\"#9-其他的几个API\" class=\"headerlink\" title=\"9. 其他的几个API\"></a>9. 其他的几个API</h2><p>返回插入语句的主键：Statement.getGeneratedKeys()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PreparedStatement ps = connection.prepareStatement(sql,\tStatement.RETURN_GENERATED_KEYS);</span><br><span class=\"line\">ps.executeUpdate();</span><br><span class=\"line\">ResultSet rs = st.getGeneratedKeys();rs.getInt(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>批处理,可以大幅度提升大量增、删、改的速度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PreparedStatement.addBatch();</span><br><span class=\"line\">PreparedStatement.executeBatch();</span><br></pre></td></tr></table></figure>\n\n<p>可滚动的结果集</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Statement st = </span><br><span class=\"line\">connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\tResultSet.CONCUR_UPDATABLE);</span><br><span class=\"line\">ResultSet rs = st.executeQuery(sql);</span><br><span class=\"line\">rs.beforeFirst(); rs.afterLast();rs.first();rs.isFirst();rs.last();rs.isLast();</span><br><span class=\"line\">rs.absolute(<span class=\"number\">9</span>);rs.moveToInsertRow();</span><br></pre></td></tr></table></figure>\n\n<p>可更新的结果集</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,</span><br><span class=\"line\">\t\t\t\tResultSet.CONCUR_UPDATABLE);</span><br><span class=\"line\">rs.updateString(<span class=\"string\">\"col name\"</span>, <span class=\"string\">\"new value\"</span>);</span><br><span class=\"line\">rs.updateRow();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-元数据\"><a href=\"#10-元数据\" class=\"headerlink\" title=\"10. 元数据\"></a>10. 元数据</h2><h3 id=\"10-1-DatabaseMetaData\"><a href=\"#10-1-DatabaseMetaData\" class=\"headerlink\" title=\"10.1 DatabaseMetaData\"></a>10.1 DatabaseMetaData</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DatabaseMetaData meta = connection.getMetaData();</span><br></pre></td></tr></table></figure>\n\n<p>通过DatabaseMetaData可以获得数据库相关的信息如：数据库版本、数据库名、数据库厂商信息、是否支持事务、是否支持某种事务隔离级别,是否支持滚动结果集等。</p>\n<h3 id=\"10-2-ResultSetMetaData\"><a href=\"#10-2-ResultSetMetaData\" class=\"headerlink\" title=\"10.2 ResultSetMetaData\"></a>10.2 ResultSetMetaData</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ResultSetMetaData meta = rs.getMetaData();</span><br><span class=\"line\">通过ResultSetMetaData可以获得结果有几列、各列名、各列别名、各列类型等。 </span><br><span class=\"line\">可以将ResultSet放入Map(key:列名 value:列值)。</span><br><span class=\"line\">用反射ResultSetMetaData将查询结果读入对象中(简单的O/RMapping) </span><br><span class=\"line\">\t<span class=\"number\">1</span>)让SQL语句中列别名和要读入的对象属性名一样；</span><br><span class=\"line\">\t<span class=\"number\">2</span>)通过ResultSetMetaData获得结果列数和列别名；</span><br><span class=\"line\">\t<span class=\"number\">3</span>)通过反射将对象的所有setXxx方法找到;</span><br><span class=\"line\">\t<span class=\"number\">4</span>)将<span class=\"number\">3</span>)找到的方法setXxx和<span class=\"number\">2</span>)找到的列别名进行匹配(即方法中的xxx于列别名相等)；</span><br><span class=\"line\">\t<span class=\"number\">5</span>)由上一步找到的方法和列别名对应关系进行赋值</span><br><span class=\"line\">\tMethod.invoke(obj, rs.getObject(columnAliasName));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-数据源与连接池\"><a href=\"#11-数据源与连接池\" class=\"headerlink\" title=\"11. 数据源与连接池\"></a>11. 数据源与连接池</h2><h3 id=\"11-1-简介\"><a href=\"#11-1-简介\" class=\"headerlink\" title=\"11.1 简介\"></a>11.1 简介</h3><p>DataSource用来取代DriverManager来获取Connection；<br>通过DataSource获得Connection速度很快；<br>通过DataSource获得的Connection都是已经被包裹过的(不是驱动原来的连接),他的close方法已经被修改。<br>一般DataSource内部会用一个连接池来缓存Connection,这样可以大幅度提高数据库的访问速度；<br>连接池可以理解成一个能够存放Connection的Collection；<br>我们的程序只和DataSource打交道,不会直接访问连接池；</p>\n<h3 id=\"11-2-简单数据源和连接池的实现\"><a href=\"#11-2-简单数据源和连接池的实现\" class=\"headerlink\" title=\"11.2 简单数据源和连接池的实现\"></a>11.2 简单数据源和连接池的实现</h3><p>使用装饰模式的Connection(核心代码)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConnection</span> <span class=\"keyword\">implements</span> <span class=\"title\">Connection</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Connection realConn;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> LinkedList connPool;</span><br><span class=\"line\">\tMyConnection(Connection rConn, LinkedList cPool)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.realConn=rConn;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.connPool=cPool;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.connPool.addLast(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//….</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>DataSource(核心代码)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyDataSource</span> <span class=\"keyword\">implements</span> <span class=\"title\">DataSource</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> LinkedList connPool = <span class=\"keyword\">new</span> Vector();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">getConneciton</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.connPool.size()&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.connPool.removeFirst(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> createConnection();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> Connection <span class=\"title\">createConnection</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t  Connection realConn = DriverManager.getConnection();</span><br><span class=\"line\">\t  Connection myConn = </span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> MyConnection(realConn,<span class=\"keyword\">this</span>.connPool);</span><br><span class=\"line\">\t  <span class=\"keyword\">return</span> myConn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//….</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-3-常用的开源实现DBCP\"><a href=\"#11-3-常用的开源实现DBCP\" class=\"headerlink\" title=\"11.3 常用的开源实现DBCP\"></a>11.3 常用的开源实现DBCP</h3><p>使用DBCP必须用的三个包：<br>​    commons-dbcp-1.2.1.jar, commons-pool-1.2.jar, commons-collections-3.1.jar；<br>配置参数：<br>jdbc.properties</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#连接设置</span><br><span class=\"line\">driverClassName=com.mysql.jdbc.Driver</span><br><span class=\"line\">url=jdbc:mysql:<span class=\"comment\">//localhost:3306/jdbc</span></span><br><span class=\"line\">username=root</span><br><span class=\"line\">password=root</span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 初始化连接 --&gt;</span><br><span class=\"line\">initialSize=<span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">#最大连接数量</span><br><span class=\"line\">maxActive=<span class=\"number\">50</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 最大空闲连接 --&gt;</span><br><span class=\"line\">maxIdle=<span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 最小空闲连接 --&gt;</span><br><span class=\"line\">minIdle=<span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;</span><br><span class=\"line\">maxWait=<span class=\"number\">60000</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] </span><br><span class=\"line\">#注意：\"user\" 与 \"password\" 两个属性会被明确地传递,因此这里不需要包含他们。</span><br><span class=\"line\">connectionProperties=useUnicode=<span class=\"keyword\">true</span>;characterEncoding=gbk</span><br><span class=\"line\"></span><br><span class=\"line\">#指定由连接池所创建的连接的自动提交(auto-commit)状态。</span><br><span class=\"line\">defaultAutoCommit=<span class=\"keyword\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">#driver default 指定由连接池所创建的连接的只读(read-only)状态。</span><br><span class=\"line\">#如果没有设置该值,则“setReadOnly”方法将不被调用。(某些驱动并不支持只读模式,如：Informix)</span><br><span class=\"line\">defaultReadOnly=</span><br><span class=\"line\"></span><br><span class=\"line\">#driver default 指定由连接池所创建的连接的事务级别(TransactionIsolation)。</span><br><span class=\"line\">#可用值为下列之一：(详情可见javadoc。)NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE</span><br><span class=\"line\">defaultTransactionIsolation=READ_UNCOMMITTED</span><br></pre></td></tr></table></figure>\n\n<p>代码中读取配置信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Properties properties= <span class=\"keyword\">new</span> Properties();</span><br><span class=\"line\">ppt.load(ClassLoader.getSystemResourceAsStream(<span class=\"string\">\"jdbc.properties\"</span>));</span><br><span class=\"line\">DataSource dataSource = BasicDataSourceFactory.createDataSource(properties)； </span><br><span class=\"line\">Connection conn = dataSource.getConnection();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-Spring的JDBC工具\"><a href=\"#13-Spring的JDBC工具\" class=\"headerlink\" title=\"13. Spring的JDBC工具\"></a>13. Spring的JDBC工具</h2><h3 id=\"13-1-JdbcTemplate\"><a href=\"#13-1-JdbcTemplate\" class=\"headerlink\" title=\"13.1 JdbcTemplate\"></a>13.1 JdbcTemplate</h3><p>查询带有参数,和行映射方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, Object[] args, RowMapper rowMapper)</span>,使用自定义的UserRowMapper完成映射。</span></span><br><span class=\"line\"><span class=\"function\">一个RowMapper的常用实现BeanPropertyRowMapper,该实现可将结果集转换成一个Java <span class=\"title\">Bean</span><span class=\"params\">(字段名与Java Bean属性名不符合规范,可用别名处理)</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List <span class=\"title\">query</span><span class=\"params\">(String sql, Object[] args, RowMapper rowMapper)</span>返回多个结果。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">queryForInt</span><span class=\"params\">(String sql)</span><span class=\"params\">(如:select count(*)</span> from user),其他结果比如String可用queryForObject方法向下转型。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">queryForMap</span><span class=\"params\">(String sql, Object[] args)</span>返回若类型的<span class=\"title\">Map</span><span class=\"params\">(key：字段名或别名,value：列值)</span>。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List <span class=\"title\">queryForList</span><span class=\"params\">(String sql, Object[] args)</span>返回多Map。</span></span><br></pre></td></tr></table></figure>\n\n<p>更新：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(String sql, Object[] args)</span>。</span></span><br></pre></td></tr></table></figure>\n\n<p>插入数据并获得结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">execute</span><span class=\"params\">(ConnectionCallback action)</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-NamedParamterJdbcTemplate\"><a href=\"#13-2-NamedParamterJdbcTemplate\" class=\"headerlink\" title=\"13.2 NamedParamterJdbcTemplate\"></a>13.2 NamedParamterJdbcTemplate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NamedParameterJdbcTemplate内部包含了一个JdbcTemplate,所以JdbcTemplate能做的事情NamedParameterJdbcTemplate都能干； </span><br><span class=\"line\">NamedParameterJdbcTemplate相对于JdbcTemplate主要增加了参数可以命名的功能。</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, Map paramMap, RowMapper rowMapper)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, SqlParameterSource paramSource, RowMapper rowMapper)</span></span></span><br><span class=\"line\"><span class=\"function\">\tSqlParameterSource的两个主要实现MapSqlParameterSource</span></span><br><span class=\"line\"><span class=\"function\">\t和BeanPropertySqlParameterSource</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(String sql, SqlParameterSource paramSource, KeyHolder generatedKeyHolder)</span>保存数据获得主键。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3-SimpleJdbcTemplate\"><a href=\"#13-3-SimpleJdbcTemplate\" class=\"headerlink\" title=\"13.3 SimpleJdbcTemplate\"></a>13.3 SimpleJdbcTemplate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SimpleJdbcTemplate内部包含了一个NamedParameterJdbcTemplate;</span><br><span class=\"line\">所以NamedParameterJdbcTemplate能做的事情SimpleJdbcTemplate都能干,SimpleJdbcTemplate相对于NamedParameterJdbcTemplate主要增加了JDK5.0的泛型和可变长度参数支持。</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">List&lt;T&gt; <span class=\"title\">query</span><span class=\"params\">(String sql, ParameterizedRowMapper&lt;T&gt; rm, Object... args)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title\">queryForObject</span><span class=\"params\">(String sql, ParameterizedRowMapper&lt;T&gt; rm, SqlParameterSource args)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> &lt;T&gt; List&lt;T&gt; <span class=\"title\">query</span><span class=\"params\">(String sql, ParameterizedRowMapper&lt;T&gt; rm, SqlParameterSource args)</span></span></span><br><span class=\"line\"><span class=\"function\">getJdbcOperations返回的是<span class=\"title\">JdbcOperations</span><span class=\"params\">(实现JdbcTemplate)</span></span></span><br><span class=\"line\"><span class=\"function\">getNamedParameterJdbcOperations返回的是<span class=\"title\">NamedParameterJdbcOperations</span><span class=\"params\">(实现是NamedParameterJdbcTemplate)</span></span></span><br></pre></td></tr></table></figure>"},{"title":"SpringMVC学习笔记","date":"2018-12-05T07:53:39.000Z","_content":"\n# SpringMVC学习笔记\n\n## 1. SpringMVC框架\n\n### 1.1 springmvc流程\n\n1. 用户发送请求至前端控制器**DispatcherServlet**。\n2. DispatcherServlet收到请求调用**HandlerMapping**（处理器映射器）。\n3. 处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n4. DispatcherServlet调用**HandlerAdapter**（处理器适配器）。\n5. HandlerAdapter经过适配调用具体的处理器**Controller**（也叫后端控制器）。\n6. Controller执行完成返回**ModelAndView**。\n7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。\n8. DispatcherServlet将ModelAndView传给**ViewReslover（**视图解析器）。\n9. ViewReslover解析后返回具体**View**（视图）。\n10. DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 \n11. DispatcherServlet响应用户。\n\n### 1.2 组件说明\n\n以下组件通常使用框架提供实现：\n\n- **DispatcherServlet**：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。\n- **HandlerMapping**：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 \n- **HandlAdapter**：通过扩展处理器适配器，支持更多类型的处理器。\n- **ViewResolver**：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。\n\n### 1.2 组件\n\n**1. 前端控制器DispatcherServlet（不需要工程师开发）,由框架提供**\n作用：接收请求，响应结果，相当于转发器、中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。\n用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。\n\n**2. 处理器映射器HandlerMapping(不需要工程师开发),由框架提供**\n作用：根据请求的url查找Handler\nHandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n\n**3. 处理器适配器HandlerAdapter**\n作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler\n通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。\n\n**4. 处理器Handler(需要工程师开发)**\n**注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler**\nHandler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。\n由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。\n\n**5. 视图解析器View resolver(不需要工程师开发),由框架提供**\n作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）\nView Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。\n一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。\n\n**6. 视图View(需要工程师开发jsp)**\nView是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）\n\n**核心架构的具体流程步骤如下：**\n\n1. 首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；\n2. DispatcherServlet——>HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；\n3. DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用；\n4. HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；\n5. ModelAndView的逻辑视图名——> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；\n6. View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；\n7. 返回视图给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。\n\n下边两个组件通常情况下需要开发：\n\nHandler：处理器，即后端控制器，一般用controller表示。\n\nView：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。\n\n## 2. 入门程序\n\n1. **用idea给项目添加springmvc框架**\n\n2. **配置前端控制器（web.xml中配置）**\n\n   ```xml\n   <!--配置springmvc前端控制器-->\n   <servlet>\n       <servlet-name>dispatcher</servlet-name>\n       <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n       <load-on-startup>1</load-on-startup>\n       <!--指定springmvc配置文件路径\n           默认加载/WEB-INF/*-servlet.xml\t\n       -->\n       <init-param>\n           <param-name>contextConfigLocation</param-name>\n           <param-value>/WEB-INF/springmvc.xml</param-value>\n       </init-param>\n   </servlet>\n   <servlet-mapping>\n       <servlet-name>dispatcher</servlet-name>\n       <url-pattern>*.do</url-pattern>\n   </servlet-mapping>\n   ```\n\n3. **配置处理器适配器**\n\n   在/WEB-INF/dispatcher-servlet.xml中配置处理器适配器\n\n   ```xml\n   <!--配置处理器适配器\n           所有的适配器都实现了HandlerAdapter接口\n       -->\n   <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"></bean>\n   ```\n\n4. **创建Handler**\n\n   需要实现controller接口，才能由org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter适配器执行\n\n   ```java\n   public class UserController implements Controller {\n       public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n           List<User> userList = new ArrayList<User>();\n           User user1 = new User();\n           user1.setName(\"xmos\");\n           user1.setAge(23);\n           user1.setAmt(1000);\n   \n           User user2 = new User();\n           user2.setName(\"tmos\");\n           user2.setAge(23);\n           user2.setAmt(1200);\n   \n           Collections.addAll(userList, user1, user2);\n   \n           //返回ModelAndView\n           ModelAndView modelAndView = new ModelAndView();\n           //相当于request.setAttrubute，在jsp中通过users获取数据\n           modelAndView.addObject(\"userList\", userList);\n   \n           //指定视图\n           modelAndView.setViewName(\"/WEB-INF/jsp/user/userList.jsp\");\n   \n           return modelAndView;\n       }\n   }\n   ```\n\n5. **编写视图**\n\n6. **配置Handler**\n\n   在dispatcher-servlet.xml文件配置Handler\n\n   ```xml\n   <!--配置Handler-->\n   <bean name=\"/queryUses.do\" class=\"com.xmos.ssm.controller.UserController\"></bean>\n   ```\n\n7. **配置处理器映射器**\n\n   ```xml\n   <!--处理器映射器\n           将bean的name值作为url进行查找，需要在配置Handler时指定name\n       -->\n   <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"></bean>\n   ```\n\n8. **配置视图解析器**\n\n   ```xml\n   <!--视图解析器\n           配置jsp解析\n       -->\n   <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"></bean>\n   ```\n\n## 3. 非注解的处理器映射器和适配器\n\n### 3.1 非注解的处理器映射器\n\n- **org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping**\n\n  ```xml\n  <!--处理器映射器\n          BeanNameUrlHandlerMapping：通过处理器的name属性值匹配请求url\n      -->\n  <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"></bean>\n  ```\n\n- **org.springframework.web.servlet.handler.SimpleUrlHandlerMapping**\n\n  ```xml\n  <!--处理器映射器\n          SimpleUrlHandlerMapping\n      -->\n  <bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n      <property name=\"mappings\">\n          <props>\n              <!--根据下面配置的url和处理器id进行映射-->\n              <prop key=\"/login.do\">loginController</prop>\n          </props>\n      </property>\n  </bean>\n  ```\n\n**多个映射器可以并存，前端控制器判断url能让哪些映射器映射，就让正确的映射器处理。**\n\n### 3.2 非注解的处理器适配器\n\n- **org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter**\n\n  **要求编写的Handler实现 Controller接口。**\n\n  ```xml\n  <!--处理器适配器\n          SimpleControllerHandlerAdapter：要求处理器实现Controller接口\n      -->\n  <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"></bean>\n  ```\n\n- **org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter**\n\n  **要求编写的Handler实现 HttpRequestHandler接口。**\n\n  ```xml\n  <!--处理器适配器\n          HttpRequestHandlerAdapter：要求处理器实现HttpRequestHandler接口\n      -->\n  <bean class=\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\"></bean>\n  ```\n\n## 4. DispatcherServlet.properties\n\n**前端控制器从org.springframework.web.servlet.DispatcherServlet.properties中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的。**\n\n## 4.1 注解的处理器映射器和适配器\n\n- 在spring3.1之前使用**org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping**注解映射器。\n- 在spring3.1之后使用**org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping**注解映射器。\n\n \n\n- 在spring3.1之前使用**org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter**注解适配器。\n- 在spring3.1之后使用**org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter**注解适配器。\n\n### 4.2 配置注解映射器和适配器\n\n```xml\n<!--注解映射器-->\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"></bean>\n\n<!--注解适配器-->\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"></bean>\n\n<!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置\n mvc:annotation-driven默认加载很多的参数绑定方法，\n 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\n 实际开发时使用mvc:annotation-driven\n  -->\n<mvc:annotation-driven></mvc:annotation-driven>\n```\n\n### 4.3 开发注解Handler\n\n**使用注解的映射器和注解的适配器。（注解的映射器和注解的适配器必须配对使用）**\n\n```java\n//使用Controller标识 它是一个控制器\n@Controller\npublic class ItemsController3 {\n\n    //用户登陆\n    //@RequestMapping实现 对login方法和url进行映射，一个方法对应一个url\n    //一般建议将url和方法写成一样\n    @RequestMapping(\"/login\")\n    public ModelAndView login(HttpServletRequest httpServletRequest) {\n\n        User user = new User();\n        user.setName(httpServletRequest.getParameter(\"name\"));\n\n        //返回ModelAndView\n        ModelAndView modelAndView =  new ModelAndView();\n        //相当 于request的setAttribut，在jsp页面中通过itemsList取数据\n        modelAndView.addObject(\"itemsList\", itemsList);\n\n        //指定视图\n        modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\n\n        return modelAndView;\n    }\n\n```\n\n### 4.4 在spring容器中加载Handler\n\n```xml\n<!-- 对于注解的Handler可以单个配置\n 实际开发中建议使用组件扫描\n  -->\n<!-- <bean class=\"com.xmos.demo.ssm.controller.LoginController\" /> -->\n<!-- 可以扫描controller、service、...\n  -->\n<context:component-scan base-package=\"com.xmos.demo.ssm\"></context:component-scan>\n\n```\n\n## 5. 视图解析器（jsp）\n\n配置视图解析器的前后缀\n\n```xml\n<!--视图解析器\n        配置jsp解析\n    -->\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <!--配置jsp路径前缀-->\n    <property name=\"prefix\" value=\"/WEB-INF/jsp\"></property>\n    <!--配置jsp路径后缀-->\n    <property name=\"suffix\" value=\".jsp\"></property>\n</bean>\n```\n\n**这样处理器就可以省略jsp路径的前缀和后缀了**\n\n## 6. @RequestMapping\n\n- url映射\n\n  ```java\n  @RequestMapping(\"/login\")\n  ```\n\n- 窄化请求映射\n\n  ```java\n  @Controller\n  //对url进行管理，可以在这里定义根路径\n  @RequestMapping(\"/ssm\")\n  public class LoginController {\n      @RequestMapping(\"/login\")\n      public String login() {\n          return \"login\";\n      }\n  }\n  ```\n\n- 限制http请求方法\n\n  ```java\n  //限制http请求方法为get和post\n  @RequestMapping(value=\"/login\", method={RequestMethos.GET, RequestMethod.POST})\n  ```\n\n## 7. controller方法的返回值\n\n- 返回ModelAndView\n\n  需要方法结束时，定义ModelAndView，将model和view分别进行设置。\n\n- 返回String\n\n  - 返回逻辑视图名：真正的视图（jsp路径）=前缀+逻辑视图名+后缀\n\n    ```java\n    return \"user\"; //相当于/WEB-INF/jsp/user.jsp\n    ```\n\n  - forward：页面转发，浏览器url不变，共享request\n\n    ```java\n    return \"forward:/WEB-INF/jsp/user.jsp\";\n    ```\n\n  - redirect：重定向，浏览器url变化，不共享request\n\n    ```java\n    //重定向只能访问浏览器能访问的路径\n    return \"redirect:/index.jsp\";\n    ```\n\n- 返回void\n\n  在controller方法形参上可以定义request和response，使用request或response指定响应结果：\n\n  1. **使用request转向页面**，如下：\n\n  request.getRequestDispatcher(\"页面路径\").forward(request, response);\n\n  1. **使用response页面重定向**：\n\n  response.sendRedirect(\"url\")\n\n  1. **使用response指定响应结果**，例如响应json数据如下：\n\n  response.setCharacterEncoding(\"utf-8\");\n\n  response.setContentType(\"application/json;charset=utf-8\");\n\n  response.getWriter().write(\"json串\");\n\n## 8. 参数绑定\n\n### 8.1 spring参数绑定过程\n\n从客户端请求key/value数据，经过spring提供的各种converter组件进行参数绑定，将key/value数据绑定到controller方法的形参上。springmvc中，接收页面提交的数据是通过**方法形参**来接收。而不是在controller类定义成员变更接收。\n\n### 8.2 默认支持的类型\n\n直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。\n\n- **HttpServletRequest**\n\n  通过request对象获取请求信息\n\n- **HttpServletResponse**\n\n  通过response处理响应信息\n\n- **HttpSession**\n\n  通过session对象得到session中存放的对象\n\n- **Model/ModelMap**\n\n  model是一个接口，modelMap是一个接口实现 。\n\n  作用：将model数据填充到request域。\n\n### 8.3 简单类型\n\n通过@RequestParam对简单类型的参数进行绑定。\n\n如果不使用@RequestParam，**要求request传入参数名称和controller方法的形参名称一致**，方可绑定成功。\n\n如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。\n\n通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，则会报错。\n\n### 8.4 pojo绑定\n\n- 页面中input的name值和controller的pojo属性名一致\n\n  ```html\n  <input type=\"text\" name=\"name\" />\n  ```\n\n- url参数的属性名和pojo的属性名一致\n\n  ```html\n  http://localhost:8080/login?name=xmos\n  ```\n\n- http请求方法体中请求参数的属性名和pojo的属性名一致\n\n  ```java\n  public class User {\n      private String name;\n  }\n  ```\n\n### 8.5 复杂类型参数绑定\n\n**只要页面中的参数名和controller形参名相同即可，一般开发中使用包装类来接受复杂参数类型，在包装类中创建绑定参数的set方法**\n\n### 8.5 自定义参数绑定\n\n#### 8.51 自定义日期类型绑定\n\n```java\npublic class CustomDateConverter implements Converter<String, Date> {\n    @Override\n    public Date convert(String source) {\n        //实现日期串转成日期类型(yyyy-MM-dd HH:mm:ss)\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        \n        try {\n            //转换成功直接返回\n            return sdf.parse(source);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        //如果参数绑定失败返回null\n        return null;\n    }\n}\n```\n\n#### 8.52 配置自定义参数绑定\n\n```xml\n<!--开启注解方式开发Handler\n        conversion-service:使用自定义参数绑定\n    -->\n<mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\n\n<!--自定义参数绑定-->\n<bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n    <!--转换器-->\n    <property name=\"converters\">\n        <list>\n            <!--日期类型转换-->\n            <bean id=\"com.xmos.demo.ssm.converter.CustomDateConverter\"/>\n        </list>\n    </property>\n</bean>\n```\n\n## 9. 乱码问题\n\n### 9.1 post乱码\n\n在web.xml中加入过滤器\n\n```xml\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n```\n\n\n\n### 9.2 get乱码\n\n- 方式一：修改tomcat配置文件添加编码与工程编码一致\n\n  ```xml\n  <Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n  ```\n\n- 方式二：对参数进行重新编码\n\n  ```java\n  //ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码\n  String name = new String(request.getParameter(\"name\").getBytes(\"ISO8859-1\"),\"UTF-8\");\n  ```\n\n## 10. springmvc校验\n\n## 11. 数据回显\n\n#### 11.1 什么是数据回显\n\n提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。\n\n### 11.2 pojo数据回显\n\n- springmvc默认对pojo数据进行回显，pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写），可以使用@ModelAttribute指定pojo回显到页面在request中的key\n\n  ```java\n  //user会自动放在request中\n  public String login(User user)\n  ```\n\n  ```html\n  <input type=\"text\" name=\"name\" value=\"${user.name}\"/>\n  ```\n\n- @ModelAttribute还可以将方法的返回值传到页面\n\n  ```java\n  @ModelAttrubute(\"user\")\n  public User login() {\n      return new User(\"xmos\");\n  }\n  ```\n\n- 最简单的方法是用Model.setAttrubute()方法\n\n  ```java\n  public String login(Model model) {\n      model.setAttrubute(\"user\",new User(\"xmos\"));\n      return \"forward:/index.jsp\";\n  }\n  ```\n\n### 11.3 简单类型数据回显\n\n不会自动回显，最简单的方法是用Model.setAttrubute()方法\n\n## 12. springmvc校验（to do）\n\n## 12. 异常处理\n\n### 12.1 异常处理思路\n\n系统中异常包括两类：编译期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。\n\n系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。\n\nspringmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。\n\n### 12.2 自定义异常类\n\n对不同的异常类型定义异常类，继承RuntimeException\n\n```java\npublic class UserException extends RuntimeException {\n    public UserException() {\n        super();\n    }\n\n    public UserException(String message) {\n        super(message);\n    }\n}\n```\n\n### 12.3 全局异常处理器\n\n1. 流程：系统遇到异常，直接抛出，最终前端控制器调用全局异常处理器。\n\n2. 全局异常处理思路：\n\n   解析出异常类型\n\n   如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示\n\n   如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（消息为未知错误）\n\n3. 实现springmvc提供的HandlerExceptionResolver接口\n\n   ```java\n   public class GlobalExceptionHandler implements HandlerExceptionResolver {\n       @Override\n       public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {\n           String msg = null;\n   \n           if (e instanceof UserException) {\n               msg = e.getMessage();\n           } else {\n               msg = \"未知错误\";\n           }\n   \n           ModelAndView modelAndView = new ModelAndView();\n           modelAndView.addObject(\"msg\",msg);\n           modelAndView.setViewName(\"error\");\n           return modelAndView;\n       }\n   }\n   ```\n\n4. 错误页面\n\n   ```html\n   <%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n   <html>\n   <head>\n       <title>错误提示</title>\n   </head>\n   <body>\n       ${msg}\n   </body>\n   </html>\n   ```\n\n5. 在springmvc配置文件中配置全局异常处理器\n\n   ```xml\n   <!--全局异常处理器\n           只要实现了HandlerExceptionResolver接口的就是全局异常处理器\n       -->\n   <bean class=\"com.xmos.demo.ssm.exception.GlobalExceptionHandler\"/>\n   ```\n\n6. 异常测试\n\n   ```java\n   @Controller\n   public class LoginController {\n   \n       @RequestMapping(\"/login\")\n       public String login(User user) {\n   \n           if (Objects.equals(user.getName(), \"xmos\")) {\n               throw new UserException(\"用户名错误\");\n           }\n   \n           return \"forward:/index.jsp\";\n       }\n   }\n   ```\n\n## 13. 上传\n\n### 13.1  springmvc中添加对多部件类型解析\n\n在页面form中提交enctype=\"multipart/form-data\"的数据时，需要springmvc对multipart类型的数据进行解析，在springmvc.xml中配置multipart类型解析器。\n\n```xml\n<!--文件上传-->\n<bean name=\"\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n    <!--设置文件上传的最大尺寸为5M-->\n    <property name=\"maxUploadSize\" value=\"5242880\"></property>\n</bean>\n```\n\n### 13.2 添加上传的jar包\n\nmaven中添加相关依赖\n\n```xml\n<!--文件上传-->\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.3</version>\n</dependency>\n```\n\n### 13.3 上传图片页面\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n    <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n        <html>\n            <head>\n                <title>文件上传</title>\n            </head>\n            <body>\n                <form action=\"${pageContext.request.contextPath}/upload.do\" method=\"post\" enctype=\"multipart/form-data\">\n                    <c:if test=\"${user_pic_name !=null}\">\n                        <img src=\"/pic/${user_pic_name}\" width=\"100\" height=\"100\"/>\n                    </c:if>\n                    <input type=\"file\" name=\"user_pic\"/>\n                </form>\n            </body>\n        </html>\n```\n\n### 13.4 controller\n\n```java\n@Controller\npublic class FileUploadController {\n    @RequestMapping(\"/upload\")\n    public String fileUpload(HttpServletRequest request, Model model, MultipartFile user_pic) throws IOException {\n\t\t//通过input的name和MultipartFile变量名进行参数绑定\n        if (user_pic != null) {\n            String fileName = user_pic.getOriginalFilename();\n            String path = request.getServletContext().getRealPath(\"/\")+\"/pic/\";\n            String filePath = path + fileName;\n            user_pic.transferTo(new File(filePath));\n            model.addAttribute(\"user_pic_name\", fileName);\n        }\n\n        return \"fileupload\";\n    }\n}\n```\n\n## 14. json数据交互\n\n### 14.1 为什么要进行json数据交互\n\njson数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。\n\n比如：webservice接口，传输json数据。\n\n### 14.2 SpringMVC进行json交互\n\n- 请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。\n- 请求key/value、输出json。此方法比较常用。\n\n### 14.3 环境准备\n\n#### 14.3.1 maven添加相关依赖\n\n#### 14.3.2 配置json转换器\n\n- 在注解适配器中加入messageConverters\n\n  ```xml\n  <!--注解适配器 -->\n  <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\n      <property name=\"messageConverters\">\n          <list>\n              <bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"></bean>\n          </list>\n      </property>\n  </bean>\n  \n  ```\n\n- **使用<mvc:annotation-driven /> 则不用定义上边的内容**\n\n### 14.4 json交互测试\n\n#### 14.4.1 输入json，输出json\n\n##### 14.4.1.1 jsp页面\n\n使用jquery的ajax提交json串，对输出的json结果进行解析。\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n    <html>\n        <head>\n            <title>json交互测试</title>\n            <script src=\"${pageContext.request.contextPath}/js/jquery/jquery-3.3.1.js\"/>\n    <script>\n        function requestJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                //数据格式是json\n                contentType: 'application/json;charset=utf-8',\n                data: '{\"name\":\"xmos\",\"age\":23,\"amt\":10000}',\n                success: function (data) { //返回json结果\n                    $(document).write(data)\n                }\n            })\n        }\n\n        function requestNoJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                data: 'name=xmos&age=23&amt=10000',\n                success: function (data) {\n                    $(document).wirte(data)\n                }\n            })\n        }\n            </script>\n        </head>\n    <body>\n        <input type=\"button\" value=\"发送json串\" onclick=\"requestJson()\"/>\n        <input type=\"button\" value=\"发送key/value串\" onclick=\"requestNoJson()\"/>\n    </body>\n    </html>\n```\n\n#### 14.4.1.2 controller\n\n```java\n@Controller\npublic class UserController {\n    /*\n        @ResponseBody：返回User对象转换成json\n        @RequestBody：将请求的json转换成User对象\n     */\n    @RequestMapping(\"/json\")\n    @ResponseBody\n    public User requestJson(@RequestBody User user) {\n\n        return user;\n    }\n}\n```\n\n#### 14.4.2 输入key/value，输出是json串\n\n#### 14.4.2.1 jsp页面\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n    <html>\n        <head>\n            <title>json交互测试</title>\n            <script src=\"${pageContext.request.contextPath}/js/jquery/jquery-3.3.1.js\"/>\n    <script>\n        function requestJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                //数据格式是json\n                contentType: 'application/json;charset=utf-8',\n                data: '{\"name\":\"xmos\",\"age\":23,\"amt\":10000}',\n                success: function (data) { //返回json结果\n                    $(document).write(data)\n                }\n            })\n        }\n\n        function requestNoJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                data: 'name=xmos&age=23&amt=10000',\n                success: function (data) {\n                    $(document).wirte(data)\n                }\n            })\n        }\n            </script>\n        </head>\n    <body>\n        <input type=\"button\" value=\"发送json串\" onclick=\"requestJson()\"/>\n        <input type=\"button\" value=\"发送key/value串\" onclick=\"requestNoJson()\"/>\n    </body>\n    </html>\n```\n\n\n\n#### 14.4.2.2 controller\n\n```java\n@Controller\npublic class UserController {\n    /*\n        @ResponseBody：返回User对象转换成json\n     */\n    @RequestMapping(\"/json\")\n    @ResponseBody\n    public User requestJson(User user) {\n\n        return user;\n    }\n}\n```\n\n## 15. RESTful\n\n### 15.1 什么是RESTful\n\n> RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。\n\n- 对url进行规范，写RESTful格式的url\n\n  非REST的url：http://...../queryItems.action?id=001&type=T01\n\n  REST的url风格：http://..../queryItems/**01**\n\n  特点：url简洁，将参数通过url传到服务端\n\n- http的方法规范\n\n  不管是删除、添加、更新、查找，使用的url是一致的，后台controller通过判断http方法，执行相应的操作\n\n  - get：查找\n  - put：修改\n  - post：新增\n  - delete：删除\n\n- 对http的contentType规范\n\n  请求时指定contentType，如需要json则指定application/json\n\n## 15.2 RESTful例子\n\n### 15.2.1 controller\n\n**设置返回的数据类型为json：**\n\n- 整个类的方法返回的都是json数据\n  - 在类上添加@Controller和@ResponseBody注解\n  - 在类上添加@RestController注解（常用）\n- 类的某些方法返回json数据\n  1. 在类上添加@Controller注解\n  2. 在方法上添加@ResonseBody\n\n**设置请求的数据类型为json：**\n\n在方法的形参前添加@RequestBody注解\n\n### 15.2.2 REST方法的前端控制器配置\n\n修改web.xml，把url-pattern配置的*.do改为/，表示映射所有请求\n\n```xml\n<servlet-mapping>\n    <servlet-name>dispatcher</servlet-name>\n    <!-- RESTful配置 -->\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n### 15.2.3 对静态资源的解析\n\n**配置前端控制器的url-parttern中指定/，对静态资源的解析会失败**\n\n**解决方法：**在springmvc.xml中添加静态资源解析方法\n\n```xml\n<mvc:resources localtion=\"/js/\" mapping=\"/js/**\"/>\n<mvc:resources localtion=\"/img/\" mapping=\"/img/**\"/>\n```\n\n## 16. 拦截器\n\n### 16.1 定义拦截器\n\n定义拦截器，需要实现HandlerInterceptor接口。接口中提供三个方法，根据需求实现其中的方法即可。\n\n- preHandle：进入Handler方法之前执行，常用于身份认证、授权。\n- postHandle：进入Handler方法之后，返回ModelAndView之前执行，常用作指定公共模型或试图。\n- afterCompletion：Handler执行完后执行，常用作统一异常处理、统一日志处理\n\n### 16.2 拦截器配置\n\n#### 16.2.1 针对HandlerMapping配置\n\nspringmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该拦截器。**一般不推荐使用。**\n\n```xml\n<bean\n      class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\">\n    <property name=\"interceptors\">\n        <list>\n            <ref bean=\"handlerInterceptor1\"/>\n            <ref bean=\"handlerInterceptor2\"/>\n        </list>\n    </property>\n</bean>\n<bean id=\"handlerInterceptor1\" class=\"springmvc.intercapter.HandlerInterceptor1\"/>\n<bean id=\"handlerInterceptor2\" class=\"springmvc.intercapter.HandlerInterceptor2\"/>\n\n```\n\n#### 16.2.2 类似全局的拦截器\n\n```xml\n<!--拦截器-->\n<mvc:interceptors>\n    <!--多个拦截器，依次执行-->\n    <mvc:interceptor>\n        <!--/**表示拦截所有请求-->\n        <mvc:mapping path=\"/**\"/>\n        <bean class=\"com.xmos.demo.ssm.interceptor.LoginInterceptor\"></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\n### 16.3 两个拦截器执行情况总结\n\n#### 16.3.1 两个拦截器都放行\n\n- preHandle方法按顺序执行。\n- postHandle和afterCompletion按拦截器配置的逆向顺序执行。\n\n#### 16.3.2 拦截器1放行，拦截器2不放行\n\n- 拦截器1放行，拦截器2 preHandle才会执行。\n- 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。\n- 只要有一个拦截器不放行，postHandle就不会执行。\n\n#### 16.3.3 拦截器1不放行，拦截器2不放行\n\n- 拦截器1postHandle和afterCompletion不会执行。\n- 拦截器2不会执行。\n\n#### 16.3.4 总结\n\n根据测试结果，对拦截器可以如下应用：\n\n- 统一日志处理拦截器，需要该 拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。\n- 登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后（因为登陆通过后才校验权限）。","source":"_posts/SpringMVC学习笔记.md","raw":"---\ntitle: SpringMVC学习笔记\ndate: 2018-12-05 15:53:39\ntags: 学习笔记\n---\n\n# SpringMVC学习笔记\n\n## 1. SpringMVC框架\n\n### 1.1 springmvc流程\n\n1. 用户发送请求至前端控制器**DispatcherServlet**。\n2. DispatcherServlet收到请求调用**HandlerMapping**（处理器映射器）。\n3. 处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n4. DispatcherServlet调用**HandlerAdapter**（处理器适配器）。\n5. HandlerAdapter经过适配调用具体的处理器**Controller**（也叫后端控制器）。\n6. Controller执行完成返回**ModelAndView**。\n7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。\n8. DispatcherServlet将ModelAndView传给**ViewReslover（**视图解析器）。\n9. ViewReslover解析后返回具体**View**（视图）。\n10. DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 \n11. DispatcherServlet响应用户。\n\n### 1.2 组件说明\n\n以下组件通常使用框架提供实现：\n\n- **DispatcherServlet**：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。\n- **HandlerMapping**：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 \n- **HandlAdapter**：通过扩展处理器适配器，支持更多类型的处理器。\n- **ViewResolver**：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。\n\n### 1.2 组件\n\n**1. 前端控制器DispatcherServlet（不需要工程师开发）,由框架提供**\n作用：接收请求，响应结果，相当于转发器、中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。\n用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。\n\n**2. 处理器映射器HandlerMapping(不需要工程师开发),由框架提供**\n作用：根据请求的url查找Handler\nHandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。\n\n**3. 处理器适配器HandlerAdapter**\n作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler\n通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。\n\n**4. 处理器Handler(需要工程师开发)**\n**注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler**\nHandler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。\n由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。\n\n**5. 视图解析器View resolver(不需要工程师开发),由框架提供**\n作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）\nView Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。\n一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。\n\n**6. 视图View(需要工程师开发jsp)**\nView是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...）\n\n**核心架构的具体流程步骤如下：**\n\n1. 首先用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；\n2. DispatcherServlet——>HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；\n3. DispatcherServlet——>HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用；\n4. HandlerAdapter——>处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；\n5. ModelAndView的逻辑视图名——> ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；\n6. View——>渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；\n7. 返回视图给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。\n\n下边两个组件通常情况下需要开发：\n\nHandler：处理器，即后端控制器，一般用controller表示。\n\nView：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。\n\n## 2. 入门程序\n\n1. **用idea给项目添加springmvc框架**\n\n2. **配置前端控制器（web.xml中配置）**\n\n   ```xml\n   <!--配置springmvc前端控制器-->\n   <servlet>\n       <servlet-name>dispatcher</servlet-name>\n       <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n       <load-on-startup>1</load-on-startup>\n       <!--指定springmvc配置文件路径\n           默认加载/WEB-INF/*-servlet.xml\t\n       -->\n       <init-param>\n           <param-name>contextConfigLocation</param-name>\n           <param-value>/WEB-INF/springmvc.xml</param-value>\n       </init-param>\n   </servlet>\n   <servlet-mapping>\n       <servlet-name>dispatcher</servlet-name>\n       <url-pattern>*.do</url-pattern>\n   </servlet-mapping>\n   ```\n\n3. **配置处理器适配器**\n\n   在/WEB-INF/dispatcher-servlet.xml中配置处理器适配器\n\n   ```xml\n   <!--配置处理器适配器\n           所有的适配器都实现了HandlerAdapter接口\n       -->\n   <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"></bean>\n   ```\n\n4. **创建Handler**\n\n   需要实现controller接口，才能由org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter适配器执行\n\n   ```java\n   public class UserController implements Controller {\n       public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {\n           List<User> userList = new ArrayList<User>();\n           User user1 = new User();\n           user1.setName(\"xmos\");\n           user1.setAge(23);\n           user1.setAmt(1000);\n   \n           User user2 = new User();\n           user2.setName(\"tmos\");\n           user2.setAge(23);\n           user2.setAmt(1200);\n   \n           Collections.addAll(userList, user1, user2);\n   \n           //返回ModelAndView\n           ModelAndView modelAndView = new ModelAndView();\n           //相当于request.setAttrubute，在jsp中通过users获取数据\n           modelAndView.addObject(\"userList\", userList);\n   \n           //指定视图\n           modelAndView.setViewName(\"/WEB-INF/jsp/user/userList.jsp\");\n   \n           return modelAndView;\n       }\n   }\n   ```\n\n5. **编写视图**\n\n6. **配置Handler**\n\n   在dispatcher-servlet.xml文件配置Handler\n\n   ```xml\n   <!--配置Handler-->\n   <bean name=\"/queryUses.do\" class=\"com.xmos.ssm.controller.UserController\"></bean>\n   ```\n\n7. **配置处理器映射器**\n\n   ```xml\n   <!--处理器映射器\n           将bean的name值作为url进行查找，需要在配置Handler时指定name\n       -->\n   <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"></bean>\n   ```\n\n8. **配置视图解析器**\n\n   ```xml\n   <!--视图解析器\n           配置jsp解析\n       -->\n   <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"></bean>\n   ```\n\n## 3. 非注解的处理器映射器和适配器\n\n### 3.1 非注解的处理器映射器\n\n- **org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping**\n\n  ```xml\n  <!--处理器映射器\n          BeanNameUrlHandlerMapping：通过处理器的name属性值匹配请求url\n      -->\n  <bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"></bean>\n  ```\n\n- **org.springframework.web.servlet.handler.SimpleUrlHandlerMapping**\n\n  ```xml\n  <!--处理器映射器\n          SimpleUrlHandlerMapping\n      -->\n  <bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n      <property name=\"mappings\">\n          <props>\n              <!--根据下面配置的url和处理器id进行映射-->\n              <prop key=\"/login.do\">loginController</prop>\n          </props>\n      </property>\n  </bean>\n  ```\n\n**多个映射器可以并存，前端控制器判断url能让哪些映射器映射，就让正确的映射器处理。**\n\n### 3.2 非注解的处理器适配器\n\n- **org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter**\n\n  **要求编写的Handler实现 Controller接口。**\n\n  ```xml\n  <!--处理器适配器\n          SimpleControllerHandlerAdapter：要求处理器实现Controller接口\n      -->\n  <bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"></bean>\n  ```\n\n- **org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter**\n\n  **要求编写的Handler实现 HttpRequestHandler接口。**\n\n  ```xml\n  <!--处理器适配器\n          HttpRequestHandlerAdapter：要求处理器实现HttpRequestHandler接口\n      -->\n  <bean class=\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\"></bean>\n  ```\n\n## 4. DispatcherServlet.properties\n\n**前端控制器从org.springframework.web.servlet.DispatcherServlet.properties中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的。**\n\n## 4.1 注解的处理器映射器和适配器\n\n- 在spring3.1之前使用**org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping**注解映射器。\n- 在spring3.1之后使用**org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping**注解映射器。\n\n \n\n- 在spring3.1之前使用**org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter**注解适配器。\n- 在spring3.1之后使用**org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter**注解适配器。\n\n### 4.2 配置注解映射器和适配器\n\n```xml\n<!--注解映射器-->\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"></bean>\n\n<!--注解适配器-->\n<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"></bean>\n\n<!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置\n mvc:annotation-driven默认加载很多的参数绑定方法，\n 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\n 实际开发时使用mvc:annotation-driven\n  -->\n<mvc:annotation-driven></mvc:annotation-driven>\n```\n\n### 4.3 开发注解Handler\n\n**使用注解的映射器和注解的适配器。（注解的映射器和注解的适配器必须配对使用）**\n\n```java\n//使用Controller标识 它是一个控制器\n@Controller\npublic class ItemsController3 {\n\n    //用户登陆\n    //@RequestMapping实现 对login方法和url进行映射，一个方法对应一个url\n    //一般建议将url和方法写成一样\n    @RequestMapping(\"/login\")\n    public ModelAndView login(HttpServletRequest httpServletRequest) {\n\n        User user = new User();\n        user.setName(httpServletRequest.getParameter(\"name\"));\n\n        //返回ModelAndView\n        ModelAndView modelAndView =  new ModelAndView();\n        //相当 于request的setAttribut，在jsp页面中通过itemsList取数据\n        modelAndView.addObject(\"itemsList\", itemsList);\n\n        //指定视图\n        modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");\n\n        return modelAndView;\n    }\n\n```\n\n### 4.4 在spring容器中加载Handler\n\n```xml\n<!-- 对于注解的Handler可以单个配置\n 实际开发中建议使用组件扫描\n  -->\n<!-- <bean class=\"com.xmos.demo.ssm.controller.LoginController\" /> -->\n<!-- 可以扫描controller、service、...\n  -->\n<context:component-scan base-package=\"com.xmos.demo.ssm\"></context:component-scan>\n\n```\n\n## 5. 视图解析器（jsp）\n\n配置视图解析器的前后缀\n\n```xml\n<!--视图解析器\n        配置jsp解析\n    -->\n<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <!--配置jsp路径前缀-->\n    <property name=\"prefix\" value=\"/WEB-INF/jsp\"></property>\n    <!--配置jsp路径后缀-->\n    <property name=\"suffix\" value=\".jsp\"></property>\n</bean>\n```\n\n**这样处理器就可以省略jsp路径的前缀和后缀了**\n\n## 6. @RequestMapping\n\n- url映射\n\n  ```java\n  @RequestMapping(\"/login\")\n  ```\n\n- 窄化请求映射\n\n  ```java\n  @Controller\n  //对url进行管理，可以在这里定义根路径\n  @RequestMapping(\"/ssm\")\n  public class LoginController {\n      @RequestMapping(\"/login\")\n      public String login() {\n          return \"login\";\n      }\n  }\n  ```\n\n- 限制http请求方法\n\n  ```java\n  //限制http请求方法为get和post\n  @RequestMapping(value=\"/login\", method={RequestMethos.GET, RequestMethod.POST})\n  ```\n\n## 7. controller方法的返回值\n\n- 返回ModelAndView\n\n  需要方法结束时，定义ModelAndView，将model和view分别进行设置。\n\n- 返回String\n\n  - 返回逻辑视图名：真正的视图（jsp路径）=前缀+逻辑视图名+后缀\n\n    ```java\n    return \"user\"; //相当于/WEB-INF/jsp/user.jsp\n    ```\n\n  - forward：页面转发，浏览器url不变，共享request\n\n    ```java\n    return \"forward:/WEB-INF/jsp/user.jsp\";\n    ```\n\n  - redirect：重定向，浏览器url变化，不共享request\n\n    ```java\n    //重定向只能访问浏览器能访问的路径\n    return \"redirect:/index.jsp\";\n    ```\n\n- 返回void\n\n  在controller方法形参上可以定义request和response，使用request或response指定响应结果：\n\n  1. **使用request转向页面**，如下：\n\n  request.getRequestDispatcher(\"页面路径\").forward(request, response);\n\n  1. **使用response页面重定向**：\n\n  response.sendRedirect(\"url\")\n\n  1. **使用response指定响应结果**，例如响应json数据如下：\n\n  response.setCharacterEncoding(\"utf-8\");\n\n  response.setContentType(\"application/json;charset=utf-8\");\n\n  response.getWriter().write(\"json串\");\n\n## 8. 参数绑定\n\n### 8.1 spring参数绑定过程\n\n从客户端请求key/value数据，经过spring提供的各种converter组件进行参数绑定，将key/value数据绑定到controller方法的形参上。springmvc中，接收页面提交的数据是通过**方法形参**来接收。而不是在controller类定义成员变更接收。\n\n### 8.2 默认支持的类型\n\n直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。\n\n- **HttpServletRequest**\n\n  通过request对象获取请求信息\n\n- **HttpServletResponse**\n\n  通过response处理响应信息\n\n- **HttpSession**\n\n  通过session对象得到session中存放的对象\n\n- **Model/ModelMap**\n\n  model是一个接口，modelMap是一个接口实现 。\n\n  作用：将model数据填充到request域。\n\n### 8.3 简单类型\n\n通过@RequestParam对简单类型的参数进行绑定。\n\n如果不使用@RequestParam，**要求request传入参数名称和controller方法的形参名称一致**，方可绑定成功。\n\n如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。\n\n通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，则会报错。\n\n### 8.4 pojo绑定\n\n- 页面中input的name值和controller的pojo属性名一致\n\n  ```html\n  <input type=\"text\" name=\"name\" />\n  ```\n\n- url参数的属性名和pojo的属性名一致\n\n  ```html\n  http://localhost:8080/login?name=xmos\n  ```\n\n- http请求方法体中请求参数的属性名和pojo的属性名一致\n\n  ```java\n  public class User {\n      private String name;\n  }\n  ```\n\n### 8.5 复杂类型参数绑定\n\n**只要页面中的参数名和controller形参名相同即可，一般开发中使用包装类来接受复杂参数类型，在包装类中创建绑定参数的set方法**\n\n### 8.5 自定义参数绑定\n\n#### 8.51 自定义日期类型绑定\n\n```java\npublic class CustomDateConverter implements Converter<String, Date> {\n    @Override\n    public Date convert(String source) {\n        //实现日期串转成日期类型(yyyy-MM-dd HH:mm:ss)\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        \n        try {\n            //转换成功直接返回\n            return sdf.parse(source);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        //如果参数绑定失败返回null\n        return null;\n    }\n}\n```\n\n#### 8.52 配置自定义参数绑定\n\n```xml\n<!--开启注解方式开发Handler\n        conversion-service:使用自定义参数绑定\n    -->\n<mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\n\n<!--自定义参数绑定-->\n<bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n    <!--转换器-->\n    <property name=\"converters\">\n        <list>\n            <!--日期类型转换-->\n            <bean id=\"com.xmos.demo.ssm.converter.CustomDateConverter\"/>\n        </list>\n    </property>\n</bean>\n```\n\n## 9. 乱码问题\n\n### 9.1 post乱码\n\n在web.xml中加入过滤器\n\n```xml\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n```\n\n\n\n### 9.2 get乱码\n\n- 方式一：修改tomcat配置文件添加编码与工程编码一致\n\n  ```xml\n  <Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/>\n  ```\n\n- 方式二：对参数进行重新编码\n\n  ```java\n  //ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码\n  String name = new String(request.getParameter(\"name\").getBytes(\"ISO8859-1\"),\"UTF-8\");\n  ```\n\n## 10. springmvc校验\n\n## 11. 数据回显\n\n#### 11.1 什么是数据回显\n\n提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。\n\n### 11.2 pojo数据回显\n\n- springmvc默认对pojo数据进行回显，pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写），可以使用@ModelAttribute指定pojo回显到页面在request中的key\n\n  ```java\n  //user会自动放在request中\n  public String login(User user)\n  ```\n\n  ```html\n  <input type=\"text\" name=\"name\" value=\"${user.name}\"/>\n  ```\n\n- @ModelAttribute还可以将方法的返回值传到页面\n\n  ```java\n  @ModelAttrubute(\"user\")\n  public User login() {\n      return new User(\"xmos\");\n  }\n  ```\n\n- 最简单的方法是用Model.setAttrubute()方法\n\n  ```java\n  public String login(Model model) {\n      model.setAttrubute(\"user\",new User(\"xmos\"));\n      return \"forward:/index.jsp\";\n  }\n  ```\n\n### 11.3 简单类型数据回显\n\n不会自动回显，最简单的方法是用Model.setAttrubute()方法\n\n## 12. springmvc校验（to do）\n\n## 12. 异常处理\n\n### 12.1 异常处理思路\n\n系统中异常包括两类：编译期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。\n\n系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。\n\nspringmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。\n\n### 12.2 自定义异常类\n\n对不同的异常类型定义异常类，继承RuntimeException\n\n```java\npublic class UserException extends RuntimeException {\n    public UserException() {\n        super();\n    }\n\n    public UserException(String message) {\n        super(message);\n    }\n}\n```\n\n### 12.3 全局异常处理器\n\n1. 流程：系统遇到异常，直接抛出，最终前端控制器调用全局异常处理器。\n\n2. 全局异常处理思路：\n\n   解析出异常类型\n\n   如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示\n\n   如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（消息为未知错误）\n\n3. 实现springmvc提供的HandlerExceptionResolver接口\n\n   ```java\n   public class GlobalExceptionHandler implements HandlerExceptionResolver {\n       @Override\n       public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {\n           String msg = null;\n   \n           if (e instanceof UserException) {\n               msg = e.getMessage();\n           } else {\n               msg = \"未知错误\";\n           }\n   \n           ModelAndView modelAndView = new ModelAndView();\n           modelAndView.addObject(\"msg\",msg);\n           modelAndView.setViewName(\"error\");\n           return modelAndView;\n       }\n   }\n   ```\n\n4. 错误页面\n\n   ```html\n   <%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n   <html>\n   <head>\n       <title>错误提示</title>\n   </head>\n   <body>\n       ${msg}\n   </body>\n   </html>\n   ```\n\n5. 在springmvc配置文件中配置全局异常处理器\n\n   ```xml\n   <!--全局异常处理器\n           只要实现了HandlerExceptionResolver接口的就是全局异常处理器\n       -->\n   <bean class=\"com.xmos.demo.ssm.exception.GlobalExceptionHandler\"/>\n   ```\n\n6. 异常测试\n\n   ```java\n   @Controller\n   public class LoginController {\n   \n       @RequestMapping(\"/login\")\n       public String login(User user) {\n   \n           if (Objects.equals(user.getName(), \"xmos\")) {\n               throw new UserException(\"用户名错误\");\n           }\n   \n           return \"forward:/index.jsp\";\n       }\n   }\n   ```\n\n## 13. 上传\n\n### 13.1  springmvc中添加对多部件类型解析\n\n在页面form中提交enctype=\"multipart/form-data\"的数据时，需要springmvc对multipart类型的数据进行解析，在springmvc.xml中配置multipart类型解析器。\n\n```xml\n<!--文件上传-->\n<bean name=\"\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n    <!--设置文件上传的最大尺寸为5M-->\n    <property name=\"maxUploadSize\" value=\"5242880\"></property>\n</bean>\n```\n\n### 13.2 添加上传的jar包\n\nmaven中添加相关依赖\n\n```xml\n<!--文件上传-->\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.3</version>\n</dependency>\n```\n\n### 13.3 上传图片页面\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n    <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n        <html>\n            <head>\n                <title>文件上传</title>\n            </head>\n            <body>\n                <form action=\"${pageContext.request.contextPath}/upload.do\" method=\"post\" enctype=\"multipart/form-data\">\n                    <c:if test=\"${user_pic_name !=null}\">\n                        <img src=\"/pic/${user_pic_name}\" width=\"100\" height=\"100\"/>\n                    </c:if>\n                    <input type=\"file\" name=\"user_pic\"/>\n                </form>\n            </body>\n        </html>\n```\n\n### 13.4 controller\n\n```java\n@Controller\npublic class FileUploadController {\n    @RequestMapping(\"/upload\")\n    public String fileUpload(HttpServletRequest request, Model model, MultipartFile user_pic) throws IOException {\n\t\t//通过input的name和MultipartFile变量名进行参数绑定\n        if (user_pic != null) {\n            String fileName = user_pic.getOriginalFilename();\n            String path = request.getServletContext().getRealPath(\"/\")+\"/pic/\";\n            String filePath = path + fileName;\n            user_pic.transferTo(new File(filePath));\n            model.addAttribute(\"user_pic_name\", fileName);\n        }\n\n        return \"fileupload\";\n    }\n}\n```\n\n## 14. json数据交互\n\n### 14.1 为什么要进行json数据交互\n\njson数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。\n\n比如：webservice接口，传输json数据。\n\n### 14.2 SpringMVC进行json交互\n\n- 请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。\n- 请求key/value、输出json。此方法比较常用。\n\n### 14.3 环境准备\n\n#### 14.3.1 maven添加相关依赖\n\n#### 14.3.2 配置json转换器\n\n- 在注解适配器中加入messageConverters\n\n  ```xml\n  <!--注解适配器 -->\n  <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\">\n      <property name=\"messageConverters\">\n          <list>\n              <bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"></bean>\n          </list>\n      </property>\n  </bean>\n  \n  ```\n\n- **使用<mvc:annotation-driven /> 则不用定义上边的内容**\n\n### 14.4 json交互测试\n\n#### 14.4.1 输入json，输出json\n\n##### 14.4.1.1 jsp页面\n\n使用jquery的ajax提交json串，对输出的json结果进行解析。\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n    <html>\n        <head>\n            <title>json交互测试</title>\n            <script src=\"${pageContext.request.contextPath}/js/jquery/jquery-3.3.1.js\"/>\n    <script>\n        function requestJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                //数据格式是json\n                contentType: 'application/json;charset=utf-8',\n                data: '{\"name\":\"xmos\",\"age\":23,\"amt\":10000}',\n                success: function (data) { //返回json结果\n                    $(document).write(data)\n                }\n            })\n        }\n\n        function requestNoJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                data: 'name=xmos&age=23&amt=10000',\n                success: function (data) {\n                    $(document).wirte(data)\n                }\n            })\n        }\n            </script>\n        </head>\n    <body>\n        <input type=\"button\" value=\"发送json串\" onclick=\"requestJson()\"/>\n        <input type=\"button\" value=\"发送key/value串\" onclick=\"requestNoJson()\"/>\n    </body>\n    </html>\n```\n\n#### 14.4.1.2 controller\n\n```java\n@Controller\npublic class UserController {\n    /*\n        @ResponseBody：返回User对象转换成json\n        @RequestBody：将请求的json转换成User对象\n     */\n    @RequestMapping(\"/json\")\n    @ResponseBody\n    public User requestJson(@RequestBody User user) {\n\n        return user;\n    }\n}\n```\n\n#### 14.4.2 输入key/value，输出是json串\n\n#### 14.4.2.1 jsp页面\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n    <html>\n        <head>\n            <title>json交互测试</title>\n            <script src=\"${pageContext.request.contextPath}/js/jquery/jquery-3.3.1.js\"/>\n    <script>\n        function requestJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                //数据格式是json\n                contentType: 'application/json;charset=utf-8',\n                data: '{\"name\":\"xmos\",\"age\":23,\"amt\":10000}',\n                success: function (data) { //返回json结果\n                    $(document).write(data)\n                }\n            })\n        }\n\n        function requestNoJson() {\n            $.ajax({\n                type: 'post',\n                url: '${pageContext.request.contextPath}/json.do',\n                data: 'name=xmos&age=23&amt=10000',\n                success: function (data) {\n                    $(document).wirte(data)\n                }\n            })\n        }\n            </script>\n        </head>\n    <body>\n        <input type=\"button\" value=\"发送json串\" onclick=\"requestJson()\"/>\n        <input type=\"button\" value=\"发送key/value串\" onclick=\"requestNoJson()\"/>\n    </body>\n    </html>\n```\n\n\n\n#### 14.4.2.2 controller\n\n```java\n@Controller\npublic class UserController {\n    /*\n        @ResponseBody：返回User对象转换成json\n     */\n    @RequestMapping(\"/json\")\n    @ResponseBody\n    public User requestJson(User user) {\n\n        return user;\n    }\n}\n```\n\n## 15. RESTful\n\n### 15.1 什么是RESTful\n\n> RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。\n\n- 对url进行规范，写RESTful格式的url\n\n  非REST的url：http://...../queryItems.action?id=001&type=T01\n\n  REST的url风格：http://..../queryItems/**01**\n\n  特点：url简洁，将参数通过url传到服务端\n\n- http的方法规范\n\n  不管是删除、添加、更新、查找，使用的url是一致的，后台controller通过判断http方法，执行相应的操作\n\n  - get：查找\n  - put：修改\n  - post：新增\n  - delete：删除\n\n- 对http的contentType规范\n\n  请求时指定contentType，如需要json则指定application/json\n\n## 15.2 RESTful例子\n\n### 15.2.1 controller\n\n**设置返回的数据类型为json：**\n\n- 整个类的方法返回的都是json数据\n  - 在类上添加@Controller和@ResponseBody注解\n  - 在类上添加@RestController注解（常用）\n- 类的某些方法返回json数据\n  1. 在类上添加@Controller注解\n  2. 在方法上添加@ResonseBody\n\n**设置请求的数据类型为json：**\n\n在方法的形参前添加@RequestBody注解\n\n### 15.2.2 REST方法的前端控制器配置\n\n修改web.xml，把url-pattern配置的*.do改为/，表示映射所有请求\n\n```xml\n<servlet-mapping>\n    <servlet-name>dispatcher</servlet-name>\n    <!-- RESTful配置 -->\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n### 15.2.3 对静态资源的解析\n\n**配置前端控制器的url-parttern中指定/，对静态资源的解析会失败**\n\n**解决方法：**在springmvc.xml中添加静态资源解析方法\n\n```xml\n<mvc:resources localtion=\"/js/\" mapping=\"/js/**\"/>\n<mvc:resources localtion=\"/img/\" mapping=\"/img/**\"/>\n```\n\n## 16. 拦截器\n\n### 16.1 定义拦截器\n\n定义拦截器，需要实现HandlerInterceptor接口。接口中提供三个方法，根据需求实现其中的方法即可。\n\n- preHandle：进入Handler方法之前执行，常用于身份认证、授权。\n- postHandle：进入Handler方法之后，返回ModelAndView之前执行，常用作指定公共模型或试图。\n- afterCompletion：Handler执行完后执行，常用作统一异常处理、统一日志处理\n\n### 16.2 拦截器配置\n\n#### 16.2.1 针对HandlerMapping配置\n\nspringmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该拦截器。**一般不推荐使用。**\n\n```xml\n<bean\n      class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\">\n    <property name=\"interceptors\">\n        <list>\n            <ref bean=\"handlerInterceptor1\"/>\n            <ref bean=\"handlerInterceptor2\"/>\n        </list>\n    </property>\n</bean>\n<bean id=\"handlerInterceptor1\" class=\"springmvc.intercapter.HandlerInterceptor1\"/>\n<bean id=\"handlerInterceptor2\" class=\"springmvc.intercapter.HandlerInterceptor2\"/>\n\n```\n\n#### 16.2.2 类似全局的拦截器\n\n```xml\n<!--拦截器-->\n<mvc:interceptors>\n    <!--多个拦截器，依次执行-->\n    <mvc:interceptor>\n        <!--/**表示拦截所有请求-->\n        <mvc:mapping path=\"/**\"/>\n        <bean class=\"com.xmos.demo.ssm.interceptor.LoginInterceptor\"></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\n### 16.3 两个拦截器执行情况总结\n\n#### 16.3.1 两个拦截器都放行\n\n- preHandle方法按顺序执行。\n- postHandle和afterCompletion按拦截器配置的逆向顺序执行。\n\n#### 16.3.2 拦截器1放行，拦截器2不放行\n\n- 拦截器1放行，拦截器2 preHandle才会执行。\n- 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。\n- 只要有一个拦截器不放行，postHandle就不会执行。\n\n#### 16.3.3 拦截器1不放行，拦截器2不放行\n\n- 拦截器1postHandle和afterCompletion不会执行。\n- 拦截器2不会执行。\n\n#### 16.3.4 总结\n\n根据测试结果，对拦截器可以如下应用：\n\n- 统一日志处理拦截器，需要该 拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。\n- 登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后（因为登陆通过后才校验权限）。","slug":"SpringMVC学习笔记","published":1,"updated":"2019-09-02T16:09:10.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck037qbqe0003liyd39wdct9b","content":"<h1 id=\"SpringMVC学习笔记\"><a href=\"#SpringMVC学习笔记\" class=\"headerlink\" title=\"SpringMVC学习笔记\"></a>SpringMVC学习笔记</h1><h2 id=\"1-SpringMVC框架\"><a href=\"#1-SpringMVC框架\" class=\"headerlink\" title=\"1. SpringMVC框架\"></a>1. SpringMVC框架</h2><h3 id=\"1-1-springmvc流程\"><a href=\"#1-1-springmvc流程\" class=\"headerlink\" title=\"1.1 springmvc流程\"></a>1.1 springmvc流程</h3><ol>\n<li>用户发送请求至前端控制器<strong>DispatcherServlet</strong>。</li>\n<li>DispatcherServlet收到请求调用<strong>HandlerMapping</strong>（处理器映射器）。</li>\n<li>处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>\n<li>DispatcherServlet调用<strong>HandlerAdapter</strong>（处理器适配器）。</li>\n<li>HandlerAdapter经过适配调用具体的处理器<strong>Controller</strong>（也叫后端控制器）。</li>\n<li>Controller执行完成返回<strong>ModelAndView</strong>。</li>\n<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>\n<li>DispatcherServlet将ModelAndView传给<strong>ViewReslover（</strong>视图解析器）。</li>\n<li>ViewReslover解析后返回具体<strong>View</strong>（视图）。</li>\n<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>\n<li>DispatcherServlet响应用户。</li>\n</ol>\n<h3 id=\"1-2-组件说明\"><a href=\"#1-2-组件说明\" class=\"headerlink\" title=\"1.2 组件说明\"></a>1.2 组件说明</h3><p>以下组件通常使用框架提供实现：</p>\n<ul>\n<li><strong>DispatcherServlet</strong>：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</li>\n<li><strong>HandlerMapping</strong>：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </li>\n<li><strong>HandlAdapter</strong>：通过扩展处理器适配器，支持更多类型的处理器。</li>\n<li><strong>ViewResolver</strong>：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</li>\n</ul>\n<h3 id=\"1-2-组件\"><a href=\"#1-2-组件\" class=\"headerlink\" title=\"1.2 组件\"></a>1.2 组件</h3><p><strong>1. 前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong><br>作用：接收请求，响应结果，相当于转发器、中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。<br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。</p>\n<p><strong>2. 处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong><br>作用：根据请求的url查找Handler<br>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n<p><strong>3. 处理器适配器HandlerAdapter</strong><br>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler<br>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>\n<p><strong>4. 处理器Handler(需要工程师开发)</strong><br><strong>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong><br>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>\n<p><strong>5. 视图解析器View resolver(不需要工程师开发),由框架提供</strong><br>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）<br>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>\n<p><strong>6. 视图View(需要工程师开发jsp)</strong><br>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>\n<p><strong>核心架构的具体流程步骤如下：</strong></p>\n<ol>\n<li>首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li>\n<li>DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</li>\n<li>DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用；</li>\n<li>HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</li>\n<li>ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</li>\n<li>View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</li>\n<li>返回视图给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</li>\n</ol>\n<p>下边两个组件通常情况下需要开发：</p>\n<p>Handler：处理器，即后端控制器，一般用controller表示。</p>\n<p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p>\n<h2 id=\"2-入门程序\"><a href=\"#2-入门程序\" class=\"headerlink\" title=\"2. 入门程序\"></a>2. 入门程序</h2><ol>\n<li><p><strong>用idea给项目添加springmvc框架</strong></p>\n</li>\n<li><p><strong>配置前端控制器（web.xml中配置）</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置springmvc前端控制器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--指定springmvc配置文件路径</span></span><br><span class=\"line\"><span class=\"comment\">        默认加载/WEB-INF/*-servlet.xml\t</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置处理器适配器</strong></p>\n<p>在/WEB-INF/dispatcher-servlet.xml中配置处理器适配器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置处理器适配器</span></span><br><span class=\"line\"><span class=\"comment\">        所有的适配器都实现了HandlerAdapter接口</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>创建Handler</strong></p>\n<p>需要实现controller接口，才能由org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter适配器执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> <span class=\"keyword\">implements</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">handleRequest</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        List&lt;User&gt; userList = <span class=\"keyword\">new</span> ArrayList&lt;User&gt;();</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user1.setName(<span class=\"string\">\"xmos\"</span>);</span><br><span class=\"line\">        user1.setAge(<span class=\"number\">23</span>);</span><br><span class=\"line\">        user1.setAmt(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user2.setName(<span class=\"string\">\"tmos\"</span>);</span><br><span class=\"line\">        user2.setAge(<span class=\"number\">23</span>);</span><br><span class=\"line\">        user2.setAmt(<span class=\"number\">1200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Collections.addAll(userList, user1, user2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//返回ModelAndView</span></span><br><span class=\"line\">        ModelAndView modelAndView = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">        <span class=\"comment\">//相当于request.setAttrubute，在jsp中通过users获取数据</span></span><br><span class=\"line\">        modelAndView.addObject(<span class=\"string\">\"userList\"</span>, userList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//指定视图</span></span><br><span class=\"line\">        modelAndView.setViewName(<span class=\"string\">\"/WEB-INF/jsp/user/userList.jsp\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> modelAndView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>编写视图</strong></p>\n</li>\n<li><p><strong>配置Handler</strong></p>\n<p>在dispatcher-servlet.xml文件配置Handler</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置Handler--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"/queryUses.do\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.controller.UserController\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置处理器映射器</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器映射器</span></span><br><span class=\"line\"><span class=\"comment\">        将bean的name值作为url进行查找，需要在配置Handler时指定name</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置视图解析器</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--视图解析器</span></span><br><span class=\"line\"><span class=\"comment\">        配置jsp解析</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"3-非注解的处理器映射器和适配器\"><a href=\"#3-非注解的处理器映射器和适配器\" class=\"headerlink\" title=\"3. 非注解的处理器映射器和适配器\"></a>3. 非注解的处理器映射器和适配器</h2><h3 id=\"3-1-非注解的处理器映射器\"><a href=\"#3-1-非注解的处理器映射器\" class=\"headerlink\" title=\"3.1 非注解的处理器映射器\"></a>3.1 非注解的处理器映射器</h3><ul>\n<li><p><strong>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器映射器</span></span><br><span class=\"line\"><span class=\"comment\">        BeanNameUrlHandlerMapping：通过处理器的name属性值匹配请求url</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>org.springframework.web.servlet.handler.SimpleUrlHandlerMapping</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器映射器</span></span><br><span class=\"line\"><span class=\"comment\">        SimpleUrlHandlerMapping</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappings\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--根据下面配置的url和处理器id进行映射--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"/login.do\"</span>&gt;</span>loginController<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>多个映射器可以并存，前端控制器判断url能让哪些映射器映射，就让正确的映射器处理。</strong></p>\n<h3 id=\"3-2-非注解的处理器适配器\"><a href=\"#3-2-非注解的处理器适配器\" class=\"headerlink\" title=\"3.2 非注解的处理器适配器\"></a>3.2 非注解的处理器适配器</h3><ul>\n<li><p><strong>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</strong></p>\n<p><strong>要求编写的Handler实现 Controller接口。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器适配器</span></span><br><span class=\"line\"><span class=\"comment\">        SimpleControllerHandlerAdapter：要求处理器实现Controller接口</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter</strong></p>\n<p><strong>要求编写的Handler实现 HttpRequestHandler接口。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器适配器</span></span><br><span class=\"line\"><span class=\"comment\">        HttpRequestHandlerAdapter：要求处理器实现HttpRequestHandler接口</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"4-DispatcherServlet-properties\"><a href=\"#4-DispatcherServlet-properties\" class=\"headerlink\" title=\"4. DispatcherServlet.properties\"></a>4. DispatcherServlet.properties</h2><p><strong>前端控制器从org.springframework.web.servlet.DispatcherServlet.properties中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的。</strong></p>\n<h2 id=\"4-1-注解的处理器映射器和适配器\"><a href=\"#4-1-注解的处理器映射器和适配器\" class=\"headerlink\" title=\"4.1 注解的处理器映射器和适配器\"></a>4.1 注解的处理器映射器和适配器</h2><ul>\n<li>在spring3.1之前使用<strong>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</strong>注解映射器。</li>\n<li>在spring3.1之后使用<strong>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</strong>注解映射器。</li>\n</ul>\n<ul>\n<li>在spring3.1之前使用<strong>org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</strong>注解适配器。</li>\n<li>在spring3.1之后使用<strong>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</strong>注解适配器。</li>\n</ul>\n<h3 id=\"4-2-配置注解映射器和适配器\"><a href=\"#4-2-配置注解映射器和适配器\" class=\"headerlink\" title=\"4.2 配置注解映射器和适配器\"></a>4.2 配置注解映射器和适配器</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--注解映射器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--注解适配器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置</span></span><br><span class=\"line\"><span class=\"comment\"> mvc:annotation-driven默认加载很多的参数绑定方法，</span></span><br><span class=\"line\"><span class=\"comment\"> 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter</span></span><br><span class=\"line\"><span class=\"comment\"> 实际开发时使用mvc:annotation-driven</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-开发注解Handler\"><a href=\"#4-3-开发注解Handler\" class=\"headerlink\" title=\"4.3 开发注解Handler\"></a>4.3 开发注解Handler</h3><p><strong>使用注解的映射器和注解的适配器。（注解的映射器和注解的适配器必须配对使用）</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Controller标识 它是一个控制器</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ItemsController3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用户登陆</span></span><br><span class=\"line\">    <span class=\"comment\">//@RequestMapping实现 对login方法和url进行映射，一个方法对应一个url</span></span><br><span class=\"line\">    <span class=\"comment\">//一般建议将url和方法写成一样</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login</span><span class=\"params\">(HttpServletRequest httpServletRequest)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setName(httpServletRequest.getParameter(<span class=\"string\">\"name\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//返回ModelAndView</span></span><br><span class=\"line\">        ModelAndView modelAndView =  <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">        <span class=\"comment\">//相当 于request的setAttribut，在jsp页面中通过itemsList取数据</span></span><br><span class=\"line\">        modelAndView.addObject(<span class=\"string\">\"itemsList\"</span>, itemsList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//指定视图</span></span><br><span class=\"line\">        modelAndView.setViewName(<span class=\"string\">\"/WEB-INF/jsp/items/itemsList.jsp\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> modelAndView;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-在spring容器中加载Handler\"><a href=\"#4-4-在spring容器中加载Handler\" class=\"headerlink\" title=\"4.4 在spring容器中加载Handler\"></a>4.4 在spring容器中加载Handler</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 对于注解的Handler可以单个配置</span></span><br><span class=\"line\"><span class=\"comment\"> 实际开发中建议使用组件扫描</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;bean class=\"com.xmos.demo.ssm.controller.LoginController\" /&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 可以扫描controller、service、...</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.xmos.demo.ssm\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-视图解析器（jsp）\"><a href=\"#5-视图解析器（jsp）\" class=\"headerlink\" title=\"5. 视图解析器（jsp）\"></a>5. 视图解析器（jsp）</h2><p>配置视图解析器的前后缀</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--视图解析器</span></span><br><span class=\"line\"><span class=\"comment\">        配置jsp解析</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--配置jsp路径前缀--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--配置jsp路径后缀--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>这样处理器就可以省略jsp路径的前缀和后缀了</strong></p>\n<h2 id=\"6-RequestMapping\"><a href=\"#6-RequestMapping\" class=\"headerlink\" title=\"6. @RequestMapping\"></a>6. @RequestMapping</h2><ul>\n<li><p>url映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>窄化请求映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"comment\">//对url进行管理，可以在这里定义根路径</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/ssm\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"login\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>限制http请求方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//限制http请求方法为get和post</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/login\"</span>, method=&#123;RequestMethos.GET, RequestMethod.POST&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"7-controller方法的返回值\"><a href=\"#7-controller方法的返回值\" class=\"headerlink\" title=\"7. controller方法的返回值\"></a>7. controller方法的返回值</h2><ul>\n<li><p>返回ModelAndView</p>\n<p>需要方法结束时，定义ModelAndView，将model和view分别进行设置。</p>\n</li>\n<li><p>返回String</p>\n<ul>\n<li><p>返回逻辑视图名：真正的视图（jsp路径）=前缀+逻辑视图名+后缀</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"user\"</span>; <span class=\"comment\">//相当于/WEB-INF/jsp/user.jsp</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>forward：页面转发，浏览器url不变，共享request</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"forward:/WEB-INF/jsp/user.jsp\"</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>redirect：重定向，浏览器url变化，不共享request</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重定向只能访问浏览器能访问的路径</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"redirect:/index.jsp\"</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>返回void</p>\n<p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p>\n<ol>\n<li><strong>使用request转向页面</strong>，如下：</li>\n</ol>\n<p>request.getRequestDispatcher(“页面路径”).forward(request, response);</p>\n<ol>\n<li><strong>使用response页面重定向</strong>：</li>\n</ol>\n<p>response.sendRedirect(“url”)</p>\n<ol>\n<li><strong>使用response指定响应结果</strong>，例如响应json数据如下：</li>\n</ol>\n<p>response.setCharacterEncoding(“utf-8”);</p>\n<p>response.setContentType(“application/json;charset=utf-8”);</p>\n<p>response.getWriter().write(“json串”);</p>\n</li>\n</ul>\n<h2 id=\"8-参数绑定\"><a href=\"#8-参数绑定\" class=\"headerlink\" title=\"8. 参数绑定\"></a>8. 参数绑定</h2><h3 id=\"8-1-spring参数绑定过程\"><a href=\"#8-1-spring参数绑定过程\" class=\"headerlink\" title=\"8.1 spring参数绑定过程\"></a>8.1 spring参数绑定过程</h3><p>从客户端请求key/value数据，经过spring提供的各种converter组件进行参数绑定，将key/value数据绑定到controller方法的形参上。springmvc中，接收页面提交的数据是通过<strong>方法形参</strong>来接收。而不是在controller类定义成员变更接收。</p>\n<h3 id=\"8-2-默认支持的类型\"><a href=\"#8-2-默认支持的类型\" class=\"headerlink\" title=\"8.2 默认支持的类型\"></a>8.2 默认支持的类型</h3><p>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。</p>\n<ul>\n<li><p><strong>HttpServletRequest</strong></p>\n<p>通过request对象获取请求信息</p>\n</li>\n<li><p><strong>HttpServletResponse</strong></p>\n<p>通过response处理响应信息</p>\n</li>\n<li><p><strong>HttpSession</strong></p>\n<p>通过session对象得到session中存放的对象</p>\n</li>\n<li><p><strong>Model/ModelMap</strong></p>\n<p>model是一个接口，modelMap是一个接口实现 。</p>\n<p>作用：将model数据填充到request域。</p>\n</li>\n</ul>\n<h3 id=\"8-3-简单类型\"><a href=\"#8-3-简单类型\" class=\"headerlink\" title=\"8.3 简单类型\"></a>8.3 简单类型</h3><p>通过@RequestParam对简单类型的参数进行绑定。</p>\n<p>如果不使用@RequestParam，<strong>要求request传入参数名称和controller方法的形参名称一致</strong>，方可绑定成功。</p>\n<p>如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。</p>\n<p>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，则会报错。</p>\n<h3 id=\"8-4-pojo绑定\"><a href=\"#8-4-pojo绑定\" class=\"headerlink\" title=\"8.4 pojo绑定\"></a>8.4 pojo绑定</h3><ul>\n<li><p>页面中input的name值和controller的pojo属性名一致</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>url参数的属性名和pojo的属性名一致</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/login?name=xmos</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http请求方法体中请求参数的属性名和pojo的属性名一致</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"8-5-复杂类型参数绑定\"><a href=\"#8-5-复杂类型参数绑定\" class=\"headerlink\" title=\"8.5 复杂类型参数绑定\"></a>8.5 复杂类型参数绑定</h3><p><strong>只要页面中的参数名和controller形参名相同即可，一般开发中使用包装类来接受复杂参数类型，在包装类中创建绑定参数的set方法</strong></p>\n<h3 id=\"8-5-自定义参数绑定\"><a href=\"#8-5-自定义参数绑定\" class=\"headerlink\" title=\"8.5 自定义参数绑定\"></a>8.5 自定义参数绑定</h3><h4 id=\"8-51-自定义日期类型绑定\"><a href=\"#8-51-自定义日期类型绑定\" class=\"headerlink\" title=\"8.51 自定义日期类型绑定\"></a>8.51 自定义日期类型绑定</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomDateConverter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Date</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">convert</span><span class=\"params\">(String source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//实现日期串转成日期类型(yyyy-MM-dd HH:mm:ss)</span></span><br><span class=\"line\">        SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//转换成功直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> sdf.parse(source);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ParseException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果参数绑定失败返回null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-52-配置自定义参数绑定\"><a href=\"#8-52-配置自定义参数绑定\" class=\"headerlink\" title=\"8.52 配置自定义参数绑定\"></a>8.52 配置自定义参数绑定</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--开启注解方式开发Handler</span></span><br><span class=\"line\"><span class=\"comment\">        conversion-service:使用自定义参数绑定</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> <span class=\"attr\">conversion-service</span>=<span class=\"string\">\"conversionService\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--自定义参数绑定--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"conversionService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--转换器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"converters\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--日期类型转换--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"com.xmos.demo.ssm.converter.CustomDateConverter\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-乱码问题\"><a href=\"#9-乱码问题\" class=\"headerlink\" title=\"9. 乱码问题\"></a>9. 乱码问题</h2><h3 id=\"9-1-post乱码\"><a href=\"#9-1-post乱码\" class=\"headerlink\" title=\"9.1 post乱码\"></a>9.1 post乱码</h3><p>在web.xml中加入过滤器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-2-get乱码\"><a href=\"#9-2-get乱码\" class=\"headerlink\" title=\"9.2 get乱码\"></a>9.2 get乱码</h3><ul>\n<li><p>方式一：修改tomcat配置文件添加编码与工程编码一致</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">URIEncoding</span>=<span class=\"string\">\"utf-8\"</span> <span class=\"attr\">connectionTimeout</span>=<span class=\"string\">\"20000\"</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8080\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"HTTP/1.1\"</span> <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方式二：对参数进行重新编码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</span></span><br><span class=\"line\">String name = <span class=\"keyword\">new</span> String(request.getParameter(<span class=\"string\">\"name\"</span>).getBytes(<span class=\"string\">\"ISO8859-1\"</span>),<span class=\"string\">\"UTF-8\"</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"10-springmvc校验\"><a href=\"#10-springmvc校验\" class=\"headerlink\" title=\"10. springmvc校验\"></a>10. springmvc校验</h2><h2 id=\"11-数据回显\"><a href=\"#11-数据回显\" class=\"headerlink\" title=\"11. 数据回显\"></a>11. 数据回显</h2><h4 id=\"11-1-什么是数据回显\"><a href=\"#11-1-什么是数据回显\" class=\"headerlink\" title=\"11.1 什么是数据回显\"></a>11.1 什么是数据回显</h4><p>提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。</p>\n<h3 id=\"11-2-pojo数据回显\"><a href=\"#11-2-pojo数据回显\" class=\"headerlink\" title=\"11.2 pojo数据回显\"></a>11.2 pojo数据回显</h3><ul>\n<li><p>springmvc默认对pojo数据进行回显，pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写），可以使用@ModelAttribute指定pojo回显到页面在request中的key</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//user会自动放在request中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(User user)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;user.name&#125;\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@ModelAttribute还可以将方法的返回值传到页面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ModelAttrubute</span>(<span class=\"string\">\"user\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">login</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"string\">\"xmos\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最简单的方法是用Model.setAttrubute()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(Model model)</span> </span>&#123;</span><br><span class=\"line\">    model.setAttrubute(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">new</span> User(<span class=\"string\">\"xmos\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"forward:/index.jsp\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"11-3-简单类型数据回显\"><a href=\"#11-3-简单类型数据回显\" class=\"headerlink\" title=\"11.3 简单类型数据回显\"></a>11.3 简单类型数据回显</h3><p>不会自动回显，最简单的方法是用Model.setAttrubute()方法</p>\n<h2 id=\"12-springmvc校验（to-do）\"><a href=\"#12-springmvc校验（to-do）\" class=\"headerlink\" title=\"12. springmvc校验（to do）\"></a>12. springmvc校验（to do）</h2><h2 id=\"12-异常处理\"><a href=\"#12-异常处理\" class=\"headerlink\" title=\"12. 异常处理\"></a>12. 异常处理</h2><h3 id=\"12-1-异常处理思路\"><a href=\"#12-1-异常处理思路\" class=\"headerlink\" title=\"12.1 异常处理思路\"></a>12.1 异常处理思路</h3><p>系统中异常包括两类：编译期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p>\n<p>系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。</p>\n<p>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。</p>\n<h3 id=\"12-2-自定义异常类\"><a href=\"#12-2-自定义异常类\" class=\"headerlink\" title=\"12.2 自定义异常类\"></a>12.2 自定义异常类</h3><p>对不同的异常类型定义异常类，继承RuntimeException</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserException</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-3-全局异常处理器\"><a href=\"#12-3-全局异常处理器\" class=\"headerlink\" title=\"12.3 全局异常处理器\"></a>12.3 全局异常处理器</h3><ol>\n<li><p>流程：系统遇到异常，直接抛出，最终前端控制器调用全局异常处理器。</p>\n</li>\n<li><p>全局异常处理思路：</p>\n<p>解析出异常类型</p>\n<p>如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示</p>\n<p>如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（消息为未知错误）</p>\n</li>\n<li><p>实现springmvc提供的HandlerExceptionResolver接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlobalExceptionHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> UserException) &#123;</span><br><span class=\"line\">            msg = e.getMessage();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = <span class=\"string\">\"未知错误\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ModelAndView modelAndView = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">        modelAndView.addObject(<span class=\"string\">\"msg\"</span>,msg);</span><br><span class=\"line\">        modelAndView.setViewName(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> modelAndView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>错误页面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>错误提示<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    $&#123;msg&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在springmvc配置文件中配置全局异常处理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--全局异常处理器</span></span><br><span class=\"line\"><span class=\"comment\">        只要实现了HandlerExceptionResolver接口的就是全局异常处理器</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.demo.ssm.exception.GlobalExceptionHandler\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异常测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Objects.equals(user.getName(), <span class=\"string\">\"xmos\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserException(<span class=\"string\">\"用户名错误\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"forward:/index.jsp\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"13-上传\"><a href=\"#13-上传\" class=\"headerlink\" title=\"13. 上传\"></a>13. 上传</h2><h3 id=\"13-1-springmvc中添加对多部件类型解析\"><a href=\"#13-1-springmvc中添加对多部件类型解析\" class=\"headerlink\" title=\"13.1  springmvc中添加对多部件类型解析\"></a>13.1  springmvc中添加对多部件类型解析</h3><p>在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析，在springmvc.xml中配置multipart类型解析器。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--文件上传--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置文件上传的最大尺寸为5M--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxUploadSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"5242880\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-添加上传的jar包\"><a href=\"#13-2-添加上传的jar包\" class=\"headerlink\" title=\"13.2 添加上传的jar包\"></a>13.2 添加上传的jar包</h3><p>maven中添加相关依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--文件上传--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-fileupload<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-fileupload<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3-上传图片页面\"><a href=\"#13-3-上传图片页面\" class=\"headerlink\" title=\"13.3 上传图片页面\"></a>13.3 上传图片页面</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">taglib</span> <span class=\"attr\">prefix</span>=<span class=\"string\">\"c\"</span> <span class=\"attr\">uri</span>=<span class=\"string\">\"http://java.sun.com/jsp/jstl/core\"</span> %&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>文件上传<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath&#125;/upload.do\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">c:if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"$&#123;user_pic_name !=null&#125;\"</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/pic/$&#123;user_pic_name&#125;\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"100\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">c:if</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user_pic\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-4-controller\"><a href=\"#13-4-controller\" class=\"headerlink\" title=\"13.4 controller\"></a>13.4 controller</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileUploadController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/upload\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">fileUpload</span><span class=\"params\">(HttpServletRequest request, Model model, MultipartFile user_pic)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过input的name和MultipartFile变量名进行参数绑定</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user_pic != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            String fileName = user_pic.getOriginalFilename();</span><br><span class=\"line\">            String path = request.getServletContext().getRealPath(<span class=\"string\">\"/\"</span>)+<span class=\"string\">\"/pic/\"</span>;</span><br><span class=\"line\">            String filePath = path + fileName;</span><br><span class=\"line\">            user_pic.transferTo(<span class=\"keyword\">new</span> File(filePath));</span><br><span class=\"line\">            model.addAttribute(<span class=\"string\">\"user_pic_name\"</span>, fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"fileupload\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-json数据交互\"><a href=\"#14-json数据交互\" class=\"headerlink\" title=\"14. json数据交互\"></a>14. json数据交互</h2><h3 id=\"14-1-为什么要进行json数据交互\"><a href=\"#14-1-为什么要进行json数据交互\" class=\"headerlink\" title=\"14.1 为什么要进行json数据交互\"></a>14.1 为什么要进行json数据交互</h3><p>json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。</p>\n<p>比如：webservice接口，传输json数据。</p>\n<h3 id=\"14-2-SpringMVC进行json交互\"><a href=\"#14-2-SpringMVC进行json交互\" class=\"headerlink\" title=\"14.2 SpringMVC进行json交互\"></a>14.2 SpringMVC进行json交互</h3><ul>\n<li>请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。</li>\n<li>请求key/value、输出json。此方法比较常用。</li>\n</ul>\n<h3 id=\"14-3-环境准备\"><a href=\"#14-3-环境准备\" class=\"headerlink\" title=\"14.3 环境准备\"></a>14.3 环境准备</h3><h4 id=\"14-3-1-maven添加相关依赖\"><a href=\"#14-3-1-maven添加相关依赖\" class=\"headerlink\" title=\"14.3.1 maven添加相关依赖\"></a>14.3.1 maven添加相关依赖</h4><h4 id=\"14-3-2-配置json转换器\"><a href=\"#14-3-2-配置json转换器\" class=\"headerlink\" title=\"14.3.2 配置json转换器\"></a>14.3.2 配置json转换器</h4><ul>\n<li><p>在注解适配器中加入messageConverters</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--注解适配器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"messageConverters\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用&lt;mvc:annotation-driven /&gt; 则不用定义上边的内容</strong></p>\n</li>\n</ul>\n<h3 id=\"14-4-json交互测试\"><a href=\"#14-4-json交互测试\" class=\"headerlink\" title=\"14.4 json交互测试\"></a>14.4 json交互测试</h3><h4 id=\"14-4-1-输入json，输出json\"><a href=\"#14-4-1-输入json，输出json\" class=\"headerlink\" title=\"14.4.1 输入json，输出json\"></a>14.4.1 输入json，输出json</h4><h5 id=\"14-4-1-1-jsp页面\"><a href=\"#14-4-1-1-jsp页面\" class=\"headerlink\" title=\"14.4.1.1 jsp页面\"></a>14.4.1.1 jsp页面</h5><p>使用jquery的ajax提交json串，对输出的json结果进行解析。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>json交互测试<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath&#125;/js/jquery/jquery-3.3.1.js\"</span>/&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                //数据格式是json</span></span><br><span class=\"line\"><span class=\"undefined\">                contentType: 'application/json;charset=utf-8',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: '&#123;\"name\":\"xmos\",\"age\":23,\"amt\":10000&#125;',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123; //返回json结果</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).write(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestNoJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: 'name=xmos&amp;age=23&amp;amt=10000',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).wirte(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送json串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestJson()\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送key/value串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestNoJson()\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"14-4-1-2-controller\"><a href=\"#14-4-1-2-controller\" class=\"headerlink\" title=\"14.4.1.2 controller\"></a>14.4.1.2 controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        @ResponseBody：返回User对象转换成json</span></span><br><span class=\"line\"><span class=\"comment\">        @RequestBody：将请求的json转换成User对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/json\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">requestJson</span><span class=\"params\">(@RequestBody User user)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"14-4-2-输入key-value，输出是json串\"><a href=\"#14-4-2-输入key-value，输出是json串\" class=\"headerlink\" title=\"14.4.2 输入key/value，输出是json串\"></a>14.4.2 输入key/value，输出是json串</h4><h4 id=\"14-4-2-1-jsp页面\"><a href=\"#14-4-2-1-jsp页面\" class=\"headerlink\" title=\"14.4.2.1 jsp页面\"></a>14.4.2.1 jsp页面</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>json交互测试<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath&#125;/js/jquery/jquery-3.3.1.js\"</span>/&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                //数据格式是json</span></span><br><span class=\"line\"><span class=\"undefined\">                contentType: 'application/json;charset=utf-8',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: '&#123;\"name\":\"xmos\",\"age\":23,\"amt\":10000&#125;',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123; //返回json结果</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).write(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestNoJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: 'name=xmos&amp;age=23&amp;amt=10000',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).wirte(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送json串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestJson()\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送key/value串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestNoJson()\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"14-4-2-2-controller\"><a href=\"#14-4-2-2-controller\" class=\"headerlink\" title=\"14.4.2.2 controller\"></a>14.4.2.2 controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        @ResponseBody：返回User对象转换成json</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/json\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">requestJson</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-RESTful\"><a href=\"#15-RESTful\" class=\"headerlink\" title=\"15. RESTful\"></a>15. RESTful</h2><h3 id=\"15-1-什么是RESTful\"><a href=\"#15-1-什么是RESTful\" class=\"headerlink\" title=\"15.1 什么是RESTful\"></a>15.1 什么是RESTful</h3><blockquote>\n<p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。</p>\n</blockquote>\n<ul>\n<li><p>对url进行规范，写RESTful格式的url</p>\n<p>非REST的url：http://…../queryItems.action?id=001&amp;type=T01</p>\n<p>REST的url风格：http://…./queryItems/<strong>01</strong></p>\n<p>特点：url简洁，将参数通过url传到服务端</p>\n</li>\n<li><p>http的方法规范</p>\n<p>不管是删除、添加、更新、查找，使用的url是一致的，后台controller通过判断http方法，执行相应的操作</p>\n<ul>\n<li>get：查找</li>\n<li>put：修改</li>\n<li>post：新增</li>\n<li>delete：删除</li>\n</ul>\n</li>\n<li><p>对http的contentType规范</p>\n<p>请求时指定contentType，如需要json则指定application/json</p>\n</li>\n</ul>\n<h2 id=\"15-2-RESTful例子\"><a href=\"#15-2-RESTful例子\" class=\"headerlink\" title=\"15.2 RESTful例子\"></a>15.2 RESTful例子</h2><h3 id=\"15-2-1-controller\"><a href=\"#15-2-1-controller\" class=\"headerlink\" title=\"15.2.1 controller\"></a>15.2.1 controller</h3><p><strong>设置返回的数据类型为json：</strong></p>\n<ul>\n<li>整个类的方法返回的都是json数据<ul>\n<li>在类上添加@Controller和@ResponseBody注解</li>\n<li>在类上添加@RestController注解（常用）</li>\n</ul>\n</li>\n<li>类的某些方法返回json数据<ol>\n<li>在类上添加@Controller注解</li>\n<li>在方法上添加@ResonseBody</li>\n</ol>\n</li>\n</ul>\n<p><strong>设置请求的数据类型为json：</strong></p>\n<p>在方法的形参前添加@RequestBody注解</p>\n<h3 id=\"15-2-2-REST方法的前端控制器配置\"><a href=\"#15-2-2-REST方法的前端控制器配置\" class=\"headerlink\" title=\"15.2.2 REST方法的前端控制器配置\"></a>15.2.2 REST方法的前端控制器配置</h3><p>修改web.xml，把url-pattern配置的*.do改为/，表示映射所有请求</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- RESTful配置 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-2-3-对静态资源的解析\"><a href=\"#15-2-3-对静态资源的解析\" class=\"headerlink\" title=\"15.2.3 对静态资源的解析\"></a>15.2.3 对静态资源的解析</h3><p><strong>配置前端控制器的url-parttern中指定/，对静态资源的解析会失败</strong></p>\n<p><strong>解决方法：</strong>在springmvc.xml中添加静态资源解析方法</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"/js/\"</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/js/**\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"/img/\"</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/img/**\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-拦截器\"><a href=\"#16-拦截器\" class=\"headerlink\" title=\"16. 拦截器\"></a>16. 拦截器</h2><h3 id=\"16-1-定义拦截器\"><a href=\"#16-1-定义拦截器\" class=\"headerlink\" title=\"16.1 定义拦截器\"></a>16.1 定义拦截器</h3><p>定义拦截器，需要实现HandlerInterceptor接口。接口中提供三个方法，根据需求实现其中的方法即可。</p>\n<ul>\n<li>preHandle：进入Handler方法之前执行，常用于身份认证、授权。</li>\n<li>postHandle：进入Handler方法之后，返回ModelAndView之前执行，常用作指定公共模型或试图。</li>\n<li>afterCompletion：Handler执行完后执行，常用作统一异常处理、统一日志处理</li>\n</ul>\n<h3 id=\"16-2-拦截器配置\"><a href=\"#16-2-拦截器配置\" class=\"headerlink\" title=\"16.2 拦截器配置\"></a>16.2 拦截器配置</h3><h4 id=\"16-2-1-针对HandlerMapping配置\"><a href=\"#16-2-1-针对HandlerMapping配置\" class=\"headerlink\" title=\"16.2.1 针对HandlerMapping配置\"></a>16.2.1 针对HandlerMapping配置</h4><p>springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该拦截器。<strong>一般不推荐使用。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"interceptors\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"handlerInterceptor1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"handlerInterceptor2\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"handlerInterceptor1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"springmvc.intercapter.HandlerInterceptor1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"handlerInterceptor2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"springmvc.intercapter.HandlerInterceptor2\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"16-2-2-类似全局的拦截器\"><a href=\"#16-2-2-类似全局的拦截器\" class=\"headerlink\" title=\"16.2.2 类似全局的拦截器\"></a>16.2.2 类似全局的拦截器</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--拦截器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--多个拦截器，依次执行--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--/**表示拦截所有请求--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/**\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.demo.ssm.interceptor.LoginInterceptor\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-3-两个拦截器执行情况总结\"><a href=\"#16-3-两个拦截器执行情况总结\" class=\"headerlink\" title=\"16.3 两个拦截器执行情况总结\"></a>16.3 两个拦截器执行情况总结</h3><h4 id=\"16-3-1-两个拦截器都放行\"><a href=\"#16-3-1-两个拦截器都放行\" class=\"headerlink\" title=\"16.3.1 两个拦截器都放行\"></a>16.3.1 两个拦截器都放行</h4><ul>\n<li>preHandle方法按顺序执行。</li>\n<li>postHandle和afterCompletion按拦截器配置的逆向顺序执行。</li>\n</ul>\n<h4 id=\"16-3-2-拦截器1放行，拦截器2不放行\"><a href=\"#16-3-2-拦截器1放行，拦截器2不放行\" class=\"headerlink\" title=\"16.3.2 拦截器1放行，拦截器2不放行\"></a>16.3.2 拦截器1放行，拦截器2不放行</h4><ul>\n<li>拦截器1放行，拦截器2 preHandle才会执行。</li>\n<li>拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。</li>\n<li>只要有一个拦截器不放行，postHandle就不会执行。</li>\n</ul>\n<h4 id=\"16-3-3-拦截器1不放行，拦截器2不放行\"><a href=\"#16-3-3-拦截器1不放行，拦截器2不放行\" class=\"headerlink\" title=\"16.3.3 拦截器1不放行，拦截器2不放行\"></a>16.3.3 拦截器1不放行，拦截器2不放行</h4><ul>\n<li>拦截器1postHandle和afterCompletion不会执行。</li>\n<li>拦截器2不会执行。</li>\n</ul>\n<h4 id=\"16-3-4-总结\"><a href=\"#16-3-4-总结\" class=\"headerlink\" title=\"16.3.4 总结\"></a>16.3.4 总结</h4><p>根据测试结果，对拦截器可以如下应用：</p>\n<ul>\n<li>统一日志处理拦截器，需要该 拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。</li>\n<li>登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后（因为登陆通过后才校验权限）。</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h1 id=\"SpringMVC学习笔记\"><a href=\"#SpringMVC学习笔记\" class=\"headerlink\" title=\"SpringMVC学习笔记\"></a>SpringMVC学习笔记</h1><h2 id=\"1-SpringMVC框架\"><a href=\"#1-SpringMVC框架\" class=\"headerlink\" title=\"1. SpringMVC框架\"></a>1. SpringMVC框架</h2><h3 id=\"1-1-springmvc流程\"><a href=\"#1-1-springmvc流程\" class=\"headerlink\" title=\"1.1 springmvc流程\"></a>1.1 springmvc流程</h3><ol>\n<li>用户发送请求至前端控制器<strong>DispatcherServlet</strong>。</li>\n<li>DispatcherServlet收到请求调用<strong>HandlerMapping</strong>（处理器映射器）。</li>\n<li>处理器映射器找到具体的处理器（可以根据xml配置、注解进行查找），生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>\n<li>DispatcherServlet调用<strong>HandlerAdapter</strong>（处理器适配器）。</li>\n<li>HandlerAdapter经过适配调用具体的处理器<strong>Controller</strong>（也叫后端控制器）。</li>\n<li>Controller执行完成返回<strong>ModelAndView</strong>。</li>\n<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li>\n<li>DispatcherServlet将ModelAndView传给<strong>ViewReslover（</strong>视图解析器）。</li>\n<li>ViewReslover解析后返回具体<strong>View</strong>（视图）。</li>\n<li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 </li>\n<li>DispatcherServlet响应用户。</li>\n</ol>\n<h3 id=\"1-2-组件说明\"><a href=\"#1-2-组件说明\" class=\"headerlink\" title=\"1.2 组件说明\"></a>1.2 组件说明</h3><p>以下组件通常使用框架提供实现：</p>\n<ul>\n<li><strong>DispatcherServlet</strong>：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</li>\n<li><strong>HandlerMapping</strong>：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </li>\n<li><strong>HandlAdapter</strong>：通过扩展处理器适配器，支持更多类型的处理器。</li>\n<li><strong>ViewResolver</strong>：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</li>\n</ul>\n<h3 id=\"1-2-组件\"><a href=\"#1-2-组件\" class=\"headerlink\" title=\"1.2 组件\"></a>1.2 组件</h3><p><strong>1. 前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong><br>作用：接收请求，响应结果，相当于转发器、中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。<br>用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。</p>\n<p><strong>2. 处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong><br>作用：根据请求的url查找Handler<br>HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p>\n<p><strong>3. 处理器适配器HandlerAdapter</strong><br>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler<br>通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p>\n<p><strong>4. 处理器Handler(需要工程师开发)</strong><br><strong>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</strong><br>Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。<br>由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。</p>\n<p><strong>5. 视图解析器View resolver(不需要工程师开发),由框架提供</strong><br>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）<br>View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。<br>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p>\n<p><strong>6. 视图View(需要工程师开发jsp)</strong><br>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p>\n<p><strong>核心架构的具体流程步骤如下：</strong></p>\n<ol>\n<li>首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li>\n<li>DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</li>\n<li>DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用；</li>\n<li>HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</li>\n<li>ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</li>\n<li>View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</li>\n<li>返回视图给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</li>\n</ol>\n<p>下边两个组件通常情况下需要开发：</p>\n<p>Handler：处理器，即后端控制器，一般用controller表示。</p>\n<p>View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。</p>\n<h2 id=\"2-入门程序\"><a href=\"#2-入门程序\" class=\"headerlink\" title=\"2. 入门程序\"></a>2. 入门程序</h2><ol>\n<li><p><strong>用idea给项目添加springmvc框架</strong></p>\n</li>\n<li><p><strong>配置前端控制器（web.xml中配置）</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置springmvc前端控制器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--指定springmvc配置文件路径</span></span><br><span class=\"line\"><span class=\"comment\">        默认加载/WEB-INF/*-servlet.xml\t</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置处理器适配器</strong></p>\n<p>在/WEB-INF/dispatcher-servlet.xml中配置处理器适配器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置处理器适配器</span></span><br><span class=\"line\"><span class=\"comment\">        所有的适配器都实现了HandlerAdapter接口</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>创建Handler</strong></p>\n<p>需要实现controller接口，才能由org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter适配器执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> <span class=\"keyword\">implements</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">handleRequest</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        List&lt;User&gt; userList = <span class=\"keyword\">new</span> ArrayList&lt;User&gt;();</span><br><span class=\"line\">        User user1 = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user1.setName(<span class=\"string\">\"xmos\"</span>);</span><br><span class=\"line\">        user1.setAge(<span class=\"number\">23</span>);</span><br><span class=\"line\">        user1.setAmt(<span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user2 = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user2.setName(<span class=\"string\">\"tmos\"</span>);</span><br><span class=\"line\">        user2.setAge(<span class=\"number\">23</span>);</span><br><span class=\"line\">        user2.setAmt(<span class=\"number\">1200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Collections.addAll(userList, user1, user2);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//返回ModelAndView</span></span><br><span class=\"line\">        ModelAndView modelAndView = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">        <span class=\"comment\">//相当于request.setAttrubute，在jsp中通过users获取数据</span></span><br><span class=\"line\">        modelAndView.addObject(<span class=\"string\">\"userList\"</span>, userList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//指定视图</span></span><br><span class=\"line\">        modelAndView.setViewName(<span class=\"string\">\"/WEB-INF/jsp/user/userList.jsp\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> modelAndView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>编写视图</strong></p>\n</li>\n<li><p><strong>配置Handler</strong></p>\n<p>在dispatcher-servlet.xml文件配置Handler</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置Handler--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"/queryUses.do\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.controller.UserController\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置处理器映射器</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器映射器</span></span><br><span class=\"line\"><span class=\"comment\">        将bean的name值作为url进行查找，需要在配置Handler时指定name</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>配置视图解析器</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--视图解析器</span></span><br><span class=\"line\"><span class=\"comment\">        配置jsp解析</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"3-非注解的处理器映射器和适配器\"><a href=\"#3-非注解的处理器映射器和适配器\" class=\"headerlink\" title=\"3. 非注解的处理器映射器和适配器\"></a>3. 非注解的处理器映射器和适配器</h2><h3 id=\"3-1-非注解的处理器映射器\"><a href=\"#3-1-非注解的处理器映射器\" class=\"headerlink\" title=\"3.1 非注解的处理器映射器\"></a>3.1 非注解的处理器映射器</h3><ul>\n<li><p><strong>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器映射器</span></span><br><span class=\"line\"><span class=\"comment\">        BeanNameUrlHandlerMapping：通过处理器的name属性值匹配请求url</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>org.springframework.web.servlet.handler.SimpleUrlHandlerMapping</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器映射器</span></span><br><span class=\"line\"><span class=\"comment\">        SimpleUrlHandlerMapping</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappings\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--根据下面配置的url和处理器id进行映射--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"/login.do\"</span>&gt;</span>loginController<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><strong>多个映射器可以并存，前端控制器判断url能让哪些映射器映射，就让正确的映射器处理。</strong></p>\n<h3 id=\"3-2-非注解的处理器适配器\"><a href=\"#3-2-非注解的处理器适配器\" class=\"headerlink\" title=\"3.2 非注解的处理器适配器\"></a>3.2 非注解的处理器适配器</h3><ul>\n<li><p><strong>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</strong></p>\n<p><strong>要求编写的Handler实现 Controller接口。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器适配器</span></span><br><span class=\"line\"><span class=\"comment\">        SimpleControllerHandlerAdapter：要求处理器实现Controller接口</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter</strong></p>\n<p><strong>要求编写的Handler实现 HttpRequestHandler接口。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--处理器适配器</span></span><br><span class=\"line\"><span class=\"comment\">        HttpRequestHandlerAdapter：要求处理器实现HttpRequestHandler接口</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"4-DispatcherServlet-properties\"><a href=\"#4-DispatcherServlet-properties\" class=\"headerlink\" title=\"4. DispatcherServlet.properties\"></a>4. DispatcherServlet.properties</h2><p><strong>前端控制器从org.springframework.web.servlet.DispatcherServlet.properties中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的。</strong></p>\n<h2 id=\"4-1-注解的处理器映射器和适配器\"><a href=\"#4-1-注解的处理器映射器和适配器\" class=\"headerlink\" title=\"4.1 注解的处理器映射器和适配器\"></a>4.1 注解的处理器映射器和适配器</h2><ul>\n<li>在spring3.1之前使用<strong>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</strong>注解映射器。</li>\n<li>在spring3.1之后使用<strong>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</strong>注解映射器。</li>\n</ul>\n<ul>\n<li>在spring3.1之前使用<strong>org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</strong>注解适配器。</li>\n<li>在spring3.1之后使用<strong>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</strong>注解适配器。</li>\n</ul>\n<h3 id=\"4-2-配置注解映射器和适配器\"><a href=\"#4-2-配置注解映射器和适配器\" class=\"headerlink\" title=\"4.2 配置注解映射器和适配器\"></a>4.2 配置注解映射器和适配器</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--注解映射器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--注解适配器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置</span></span><br><span class=\"line\"><span class=\"comment\"> mvc:annotation-driven默认加载很多的参数绑定方法，</span></span><br><span class=\"line\"><span class=\"comment\"> 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter</span></span><br><span class=\"line\"><span class=\"comment\"> 实际开发时使用mvc:annotation-driven</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-开发注解Handler\"><a href=\"#4-3-开发注解Handler\" class=\"headerlink\" title=\"4.3 开发注解Handler\"></a>4.3 开发注解Handler</h3><p><strong>使用注解的映射器和注解的适配器。（注解的映射器和注解的适配器必须配对使用）</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用Controller标识 它是一个控制器</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ItemsController3</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用户登陆</span></span><br><span class=\"line\">    <span class=\"comment\">//@RequestMapping实现 对login方法和url进行映射，一个方法对应一个url</span></span><br><span class=\"line\">    <span class=\"comment\">//一般建议将url和方法写成一样</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login</span><span class=\"params\">(HttpServletRequest httpServletRequest)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setName(httpServletRequest.getParameter(<span class=\"string\">\"name\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//返回ModelAndView</span></span><br><span class=\"line\">        ModelAndView modelAndView =  <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">        <span class=\"comment\">//相当 于request的setAttribut，在jsp页面中通过itemsList取数据</span></span><br><span class=\"line\">        modelAndView.addObject(<span class=\"string\">\"itemsList\"</span>, itemsList);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//指定视图</span></span><br><span class=\"line\">        modelAndView.setViewName(<span class=\"string\">\"/WEB-INF/jsp/items/itemsList.jsp\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> modelAndView;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-在spring容器中加载Handler\"><a href=\"#4-4-在spring容器中加载Handler\" class=\"headerlink\" title=\"4.4 在spring容器中加载Handler\"></a>4.4 在spring容器中加载Handler</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 对于注解的Handler可以单个配置</span></span><br><span class=\"line\"><span class=\"comment\"> 实际开发中建议使用组件扫描</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;bean class=\"com.xmos.demo.ssm.controller.LoginController\" /&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 可以扫描controller、service、...</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.xmos.demo.ssm\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-视图解析器（jsp）\"><a href=\"#5-视图解析器（jsp）\" class=\"headerlink\" title=\"5. 视图解析器（jsp）\"></a>5. 视图解析器（jsp）</h2><p>配置视图解析器的前后缀</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--视图解析器</span></span><br><span class=\"line\"><span class=\"comment\">        配置jsp解析</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--配置jsp路径前缀--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--配置jsp路径后缀--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>这样处理器就可以省略jsp路径的前缀和后缀了</strong></p>\n<h2 id=\"6-RequestMapping\"><a href=\"#6-RequestMapping\" class=\"headerlink\" title=\"6. @RequestMapping\"></a>6. @RequestMapping</h2><ul>\n<li><p>url映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>窄化请求映射</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"comment\">//对url进行管理，可以在这里定义根路径</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/ssm\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"login\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>限制http请求方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//限制http请求方法为get和post</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/login\"</span>, method=&#123;RequestMethos.GET, RequestMethod.POST&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"7-controller方法的返回值\"><a href=\"#7-controller方法的返回值\" class=\"headerlink\" title=\"7. controller方法的返回值\"></a>7. controller方法的返回值</h2><ul>\n<li><p>返回ModelAndView</p>\n<p>需要方法结束时，定义ModelAndView，将model和view分别进行设置。</p>\n</li>\n<li><p>返回String</p>\n<ul>\n<li><p>返回逻辑视图名：真正的视图（jsp路径）=前缀+逻辑视图名+后缀</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"user\"</span>; <span class=\"comment\">//相当于/WEB-INF/jsp/user.jsp</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>forward：页面转发，浏览器url不变，共享request</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"forward:/WEB-INF/jsp/user.jsp\"</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>redirect：重定向，浏览器url变化，不共享request</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重定向只能访问浏览器能访问的路径</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">\"redirect:/index.jsp\"</span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>返回void</p>\n<p>在controller方法形参上可以定义request和response，使用request或response指定响应结果：</p>\n<ol>\n<li><strong>使用request转向页面</strong>，如下：</li>\n</ol>\n<p>request.getRequestDispatcher(“页面路径”).forward(request, response);</p>\n<ol>\n<li><strong>使用response页面重定向</strong>：</li>\n</ol>\n<p>response.sendRedirect(“url”)</p>\n<ol>\n<li><strong>使用response指定响应结果</strong>，例如响应json数据如下：</li>\n</ol>\n<p>response.setCharacterEncoding(“utf-8”);</p>\n<p>response.setContentType(“application/json;charset=utf-8”);</p>\n<p>response.getWriter().write(“json串”);</p>\n</li>\n</ul>\n<h2 id=\"8-参数绑定\"><a href=\"#8-参数绑定\" class=\"headerlink\" title=\"8. 参数绑定\"></a>8. 参数绑定</h2><h3 id=\"8-1-spring参数绑定过程\"><a href=\"#8-1-spring参数绑定过程\" class=\"headerlink\" title=\"8.1 spring参数绑定过程\"></a>8.1 spring参数绑定过程</h3><p>从客户端请求key/value数据，经过spring提供的各种converter组件进行参数绑定，将key/value数据绑定到controller方法的形参上。springmvc中，接收页面提交的数据是通过<strong>方法形参</strong>来接收。而不是在controller类定义成员变更接收。</p>\n<h3 id=\"8-2-默认支持的类型\"><a href=\"#8-2-默认支持的类型\" class=\"headerlink\" title=\"8.2 默认支持的类型\"></a>8.2 默认支持的类型</h3><p>直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。</p>\n<ul>\n<li><p><strong>HttpServletRequest</strong></p>\n<p>通过request对象获取请求信息</p>\n</li>\n<li><p><strong>HttpServletResponse</strong></p>\n<p>通过response处理响应信息</p>\n</li>\n<li><p><strong>HttpSession</strong></p>\n<p>通过session对象得到session中存放的对象</p>\n</li>\n<li><p><strong>Model/ModelMap</strong></p>\n<p>model是一个接口，modelMap是一个接口实现 。</p>\n<p>作用：将model数据填充到request域。</p>\n</li>\n</ul>\n<h3 id=\"8-3-简单类型\"><a href=\"#8-3-简单类型\" class=\"headerlink\" title=\"8.3 简单类型\"></a>8.3 简单类型</h3><p>通过@RequestParam对简单类型的参数进行绑定。</p>\n<p>如果不使用@RequestParam，<strong>要求request传入参数名称和controller方法的形参名称一致</strong>，方可绑定成功。</p>\n<p>如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。</p>\n<p>通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，则会报错。</p>\n<h3 id=\"8-4-pojo绑定\"><a href=\"#8-4-pojo绑定\" class=\"headerlink\" title=\"8.4 pojo绑定\"></a>8.4 pojo绑定</h3><ul>\n<li><p>页面中input的name值和controller的pojo属性名一致</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>url参数的属性名和pojo的属性名一致</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://localhost:8080/login?name=xmos</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>http请求方法体中请求参数的属性名和pojo的属性名一致</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"8-5-复杂类型参数绑定\"><a href=\"#8-5-复杂类型参数绑定\" class=\"headerlink\" title=\"8.5 复杂类型参数绑定\"></a>8.5 复杂类型参数绑定</h3><p><strong>只要页面中的参数名和controller形参名相同即可，一般开发中使用包装类来接受复杂参数类型，在包装类中创建绑定参数的set方法</strong></p>\n<h3 id=\"8-5-自定义参数绑定\"><a href=\"#8-5-自定义参数绑定\" class=\"headerlink\" title=\"8.5 自定义参数绑定\"></a>8.5 自定义参数绑定</h3><h4 id=\"8-51-自定义日期类型绑定\"><a href=\"#8-51-自定义日期类型绑定\" class=\"headerlink\" title=\"8.51 自定义日期类型绑定\"></a>8.51 自定义日期类型绑定</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomDateConverter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Converter</span>&lt;<span class=\"title\">String</span>, <span class=\"title\">Date</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Date <span class=\"title\">convert</span><span class=\"params\">(String source)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//实现日期串转成日期类型(yyyy-MM-dd HH:mm:ss)</span></span><br><span class=\"line\">        SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//转换成功直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> sdf.parse(source);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ParseException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果参数绑定失败返回null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-52-配置自定义参数绑定\"><a href=\"#8-52-配置自定义参数绑定\" class=\"headerlink\" title=\"8.52 配置自定义参数绑定\"></a>8.52 配置自定义参数绑定</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--开启注解方式开发Handler</span></span><br><span class=\"line\"><span class=\"comment\">        conversion-service:使用自定义参数绑定</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> <span class=\"attr\">conversion-service</span>=<span class=\"string\">\"conversionService\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mvc:annotation-driven</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--自定义参数绑定--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"conversionService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--转换器--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"converters\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--日期类型转换--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"com.xmos.demo.ssm.converter.CustomDateConverter\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-乱码问题\"><a href=\"#9-乱码问题\" class=\"headerlink\" title=\"9. 乱码问题\"></a>9. 乱码问题</h2><h3 id=\"9-1-post乱码\"><a href=\"#9-1-post乱码\" class=\"headerlink\" title=\"9.1 post乱码\"></a>9.1 post乱码</h3><p>在web.xml中加入过滤器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-2-get乱码\"><a href=\"#9-2-get乱码\" class=\"headerlink\" title=\"9.2 get乱码\"></a>9.2 get乱码</h3><ul>\n<li><p>方式一：修改tomcat配置文件添加编码与工程编码一致</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">URIEncoding</span>=<span class=\"string\">\"utf-8\"</span> <span class=\"attr\">connectionTimeout</span>=<span class=\"string\">\"20000\"</span> <span class=\"attr\">port</span>=<span class=\"string\">\"8080\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"HTTP/1.1\"</span> <span class=\"attr\">redirectPort</span>=<span class=\"string\">\"8443\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方式二：对参数进行重新编码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码</span></span><br><span class=\"line\">String name = <span class=\"keyword\">new</span> String(request.getParameter(<span class=\"string\">\"name\"</span>).getBytes(<span class=\"string\">\"ISO8859-1\"</span>),<span class=\"string\">\"UTF-8\"</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"10-springmvc校验\"><a href=\"#10-springmvc校验\" class=\"headerlink\" title=\"10. springmvc校验\"></a>10. springmvc校验</h2><h2 id=\"11-数据回显\"><a href=\"#11-数据回显\" class=\"headerlink\" title=\"11. 数据回显\"></a>11. 数据回显</h2><h4 id=\"11-1-什么是数据回显\"><a href=\"#11-1-什么是数据回显\" class=\"headerlink\" title=\"11.1 什么是数据回显\"></a>11.1 什么是数据回显</h4><p>提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。</p>\n<h3 id=\"11-2-pojo数据回显\"><a href=\"#11-2-pojo数据回显\" class=\"headerlink\" title=\"11.2 pojo数据回显\"></a>11.2 pojo数据回显</h3><ul>\n<li><p>springmvc默认对pojo数据进行回显，pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写），可以使用@ModelAttribute指定pojo回显到页面在request中的key</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//user会自动放在request中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(User user)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;user.name&#125;\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@ModelAttribute还可以将方法的返回值传到页面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ModelAttrubute</span>(<span class=\"string\">\"user\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">login</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User(<span class=\"string\">\"xmos\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最简单的方法是用Model.setAttrubute()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(Model model)</span> </span>&#123;</span><br><span class=\"line\">    model.setAttrubute(<span class=\"string\">\"user\"</span>,<span class=\"keyword\">new</span> User(<span class=\"string\">\"xmos\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"forward:/index.jsp\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"11-3-简单类型数据回显\"><a href=\"#11-3-简单类型数据回显\" class=\"headerlink\" title=\"11.3 简单类型数据回显\"></a>11.3 简单类型数据回显</h3><p>不会自动回显，最简单的方法是用Model.setAttrubute()方法</p>\n<h2 id=\"12-springmvc校验（to-do）\"><a href=\"#12-springmvc校验（to-do）\" class=\"headerlink\" title=\"12. springmvc校验（to do）\"></a>12. springmvc校验（to do）</h2><h2 id=\"12-异常处理\"><a href=\"#12-异常处理\" class=\"headerlink\" title=\"12. 异常处理\"></a>12. 异常处理</h2><h3 id=\"12-1-异常处理思路\"><a href=\"#12-1-异常处理思路\" class=\"headerlink\" title=\"12.1 异常处理思路\"></a>12.1 异常处理思路</h3><p>系统中异常包括两类：编译期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</p>\n<p>系统的dao、service、controller出现异常都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。</p>\n<p>springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。</p>\n<h3 id=\"12-2-自定义异常类\"><a href=\"#12-2-自定义异常类\" class=\"headerlink\" title=\"12.2 自定义异常类\"></a>12.2 自定义异常类</h3><p>对不同的异常类型定义异常类，继承RuntimeException</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserException</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-3-全局异常处理器\"><a href=\"#12-3-全局异常处理器\" class=\"headerlink\" title=\"12.3 全局异常处理器\"></a>12.3 全局异常处理器</h3><ol>\n<li><p>流程：系统遇到异常，直接抛出，最终前端控制器调用全局异常处理器。</p>\n</li>\n<li><p>全局异常处理思路：</p>\n<p>解析出异常类型</p>\n<p>如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示</p>\n<p>如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（消息为未知错误）</p>\n</li>\n<li><p>实现springmvc提供的HandlerExceptionResolver接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GlobalExceptionHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class=\"line\">        String msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> UserException) &#123;</span><br><span class=\"line\">            msg = e.getMessage();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = <span class=\"string\">\"未知错误\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ModelAndView modelAndView = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">        modelAndView.addObject(<span class=\"string\">\"msg\"</span>,msg);</span><br><span class=\"line\">        modelAndView.setViewName(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> modelAndView;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>错误页面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>错误提示<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    $&#123;msg&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在springmvc配置文件中配置全局异常处理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--全局异常处理器</span></span><br><span class=\"line\"><span class=\"comment\">        只要实现了HandlerExceptionResolver接口的就是全局异常处理器</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.demo.ssm.exception.GlobalExceptionHandler\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异常测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Objects.equals(user.getName(), <span class=\"string\">\"xmos\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserException(<span class=\"string\">\"用户名错误\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"forward:/index.jsp\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"13-上传\"><a href=\"#13-上传\" class=\"headerlink\" title=\"13. 上传\"></a>13. 上传</h2><h3 id=\"13-1-springmvc中添加对多部件类型解析\"><a href=\"#13-1-springmvc中添加对多部件类型解析\" class=\"headerlink\" title=\"13.1  springmvc中添加对多部件类型解析\"></a>13.1  springmvc中添加对多部件类型解析</h3><p>在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析，在springmvc.xml中配置multipart类型解析器。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--文件上传--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">name</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置文件上传的最大尺寸为5M--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxUploadSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"5242880\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-添加上传的jar包\"><a href=\"#13-2-添加上传的jar包\" class=\"headerlink\" title=\"13.2 添加上传的jar包\"></a>13.2 添加上传的jar包</h3><p>maven中添加相关依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--文件上传--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-fileupload<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-fileupload<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3-上传图片页面\"><a href=\"#13-3-上传图片页面\" class=\"headerlink\" title=\"13.3 上传图片页面\"></a>13.3 上传图片页面</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">taglib</span> <span class=\"attr\">prefix</span>=<span class=\"string\">\"c\"</span> <span class=\"attr\">uri</span>=<span class=\"string\">\"http://java.sun.com/jsp/jstl/core\"</span> %&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>文件上传<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath&#125;/upload.do\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">c:if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"$&#123;user_pic_name !=null&#125;\"</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/pic/$&#123;user_pic_name&#125;\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"100\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"100\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">c:if</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user_pic\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-4-controller\"><a href=\"#13-4-controller\" class=\"headerlink\" title=\"13.4 controller\"></a>13.4 controller</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileUploadController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/upload\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">fileUpload</span><span class=\"params\">(HttpServletRequest request, Model model, MultipartFile user_pic)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//通过input的name和MultipartFile变量名进行参数绑定</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user_pic != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            String fileName = user_pic.getOriginalFilename();</span><br><span class=\"line\">            String path = request.getServletContext().getRealPath(<span class=\"string\">\"/\"</span>)+<span class=\"string\">\"/pic/\"</span>;</span><br><span class=\"line\">            String filePath = path + fileName;</span><br><span class=\"line\">            user_pic.transferTo(<span class=\"keyword\">new</span> File(filePath));</span><br><span class=\"line\">            model.addAttribute(<span class=\"string\">\"user_pic_name\"</span>, fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"fileupload\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"14-json数据交互\"><a href=\"#14-json数据交互\" class=\"headerlink\" title=\"14. json数据交互\"></a>14. json数据交互</h2><h3 id=\"14-1-为什么要进行json数据交互\"><a href=\"#14-1-为什么要进行json数据交互\" class=\"headerlink\" title=\"14.1 为什么要进行json数据交互\"></a>14.1 为什么要进行json数据交互</h3><p>json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。</p>\n<p>比如：webservice接口，传输json数据。</p>\n<h3 id=\"14-2-SpringMVC进行json交互\"><a href=\"#14-2-SpringMVC进行json交互\" class=\"headerlink\" title=\"14.2 SpringMVC进行json交互\"></a>14.2 SpringMVC进行json交互</h3><ul>\n<li>请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。</li>\n<li>请求key/value、输出json。此方法比较常用。</li>\n</ul>\n<h3 id=\"14-3-环境准备\"><a href=\"#14-3-环境准备\" class=\"headerlink\" title=\"14.3 环境准备\"></a>14.3 环境准备</h3><h4 id=\"14-3-1-maven添加相关依赖\"><a href=\"#14-3-1-maven添加相关依赖\" class=\"headerlink\" title=\"14.3.1 maven添加相关依赖\"></a>14.3.1 maven添加相关依赖</h4><h4 id=\"14-3-2-配置json转换器\"><a href=\"#14-3-2-配置json转换器\" class=\"headerlink\" title=\"14.3.2 配置json转换器\"></a>14.3.2 配置json转换器</h4><ul>\n<li><p>在注解适配器中加入messageConverters</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--注解适配器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"messageConverters\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>使用&lt;mvc:annotation-driven /&gt; 则不用定义上边的内容</strong></p>\n</li>\n</ul>\n<h3 id=\"14-4-json交互测试\"><a href=\"#14-4-json交互测试\" class=\"headerlink\" title=\"14.4 json交互测试\"></a>14.4 json交互测试</h3><h4 id=\"14-4-1-输入json，输出json\"><a href=\"#14-4-1-输入json，输出json\" class=\"headerlink\" title=\"14.4.1 输入json，输出json\"></a>14.4.1 输入json，输出json</h4><h5 id=\"14-4-1-1-jsp页面\"><a href=\"#14-4-1-1-jsp页面\" class=\"headerlink\" title=\"14.4.1.1 jsp页面\"></a>14.4.1.1 jsp页面</h5><p>使用jquery的ajax提交json串，对输出的json结果进行解析。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>json交互测试<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath&#125;/js/jquery/jquery-3.3.1.js\"</span>/&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                //数据格式是json</span></span><br><span class=\"line\"><span class=\"undefined\">                contentType: 'application/json;charset=utf-8',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: '&#123;\"name\":\"xmos\",\"age\":23,\"amt\":10000&#125;',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123; //返回json结果</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).write(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestNoJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: 'name=xmos&amp;age=23&amp;amt=10000',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).wirte(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送json串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestJson()\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送key/value串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestNoJson()\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"14-4-1-2-controller\"><a href=\"#14-4-1-2-controller\" class=\"headerlink\" title=\"14.4.1.2 controller\"></a>14.4.1.2 controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        @ResponseBody：返回User对象转换成json</span></span><br><span class=\"line\"><span class=\"comment\">        @RequestBody：将请求的json转换成User对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/json\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">requestJson</span><span class=\"params\">(@RequestBody User user)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"14-4-2-输入key-value，输出是json串\"><a href=\"#14-4-2-输入key-value，输出是json串\" class=\"headerlink\" title=\"14.4.2 输入key/value，输出是json串\"></a>14.4.2 输入key/value，输出是json串</h4><h4 id=\"14-4-2-1-jsp页面\"><a href=\"#14-4-2-1-jsp页面\" class=\"headerlink\" title=\"14.4.2.1 jsp页面\"></a>14.4.2.1 jsp页面</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">%@</span> <span class=\"attr\">page</span> <span class=\"attr\">contentType</span>=<span class=\"string\">\"text/html;charset=UTF-8\"</span> <span class=\"attr\">language</span>=<span class=\"string\">\"java\"</span> %&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>json交互测试<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"$&#123;pageContext.request.contextPath&#125;/js/jquery/jquery-3.3.1.js\"</span>/&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                //数据格式是json</span></span><br><span class=\"line\"><span class=\"undefined\">                contentType: 'application/json;charset=utf-8',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: '&#123;\"name\":\"xmos\",\"age\":23,\"amt\":10000&#125;',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123; //返回json结果</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).write(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        function requestNoJson() &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                type: 'post',</span></span><br><span class=\"line\"><span class=\"undefined\">                url: '$&#123;pageContext.request.contextPath&#125;/json.do',</span></span><br><span class=\"line\"><span class=\"undefined\">                data: 'name=xmos&amp;age=23&amp;amt=10000',</span></span><br><span class=\"line\"><span class=\"undefined\">                success: function (data) &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">                    $(document).wirte(data)</span></span><br><span class=\"line\"><span class=\"undefined\">                &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;)</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">            </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送json串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestJson()\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"发送key/value串\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"requestNoJson()\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"14-4-2-2-controller\"><a href=\"#14-4-2-2-controller\" class=\"headerlink\" title=\"14.4.2.2 controller\"></a>14.4.2.2 controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        @ResponseBody：返回User对象转换成json</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/json\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">requestJson</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-RESTful\"><a href=\"#15-RESTful\" class=\"headerlink\" title=\"15. RESTful\"></a>15. RESTful</h2><h3 id=\"15-1-什么是RESTful\"><a href=\"#15-1-什么是RESTful\" class=\"headerlink\" title=\"15.1 什么是RESTful\"></a>15.1 什么是RESTful</h3><blockquote>\n<p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。</p>\n</blockquote>\n<ul>\n<li><p>对url进行规范，写RESTful格式的url</p>\n<p>非REST的url：http://…../queryItems.action?id=001&amp;type=T01</p>\n<p>REST的url风格：http://…./queryItems/<strong>01</strong></p>\n<p>特点：url简洁，将参数通过url传到服务端</p>\n</li>\n<li><p>http的方法规范</p>\n<p>不管是删除、添加、更新、查找，使用的url是一致的，后台controller通过判断http方法，执行相应的操作</p>\n<ul>\n<li>get：查找</li>\n<li>put：修改</li>\n<li>post：新增</li>\n<li>delete：删除</li>\n</ul>\n</li>\n<li><p>对http的contentType规范</p>\n<p>请求时指定contentType，如需要json则指定application/json</p>\n</li>\n</ul>\n<h2 id=\"15-2-RESTful例子\"><a href=\"#15-2-RESTful例子\" class=\"headerlink\" title=\"15.2 RESTful例子\"></a>15.2 RESTful例子</h2><h3 id=\"15-2-1-controller\"><a href=\"#15-2-1-controller\" class=\"headerlink\" title=\"15.2.1 controller\"></a>15.2.1 controller</h3><p><strong>设置返回的数据类型为json：</strong></p>\n<ul>\n<li>整个类的方法返回的都是json数据<ul>\n<li>在类上添加@Controller和@ResponseBody注解</li>\n<li>在类上添加@RestController注解（常用）</li>\n</ul>\n</li>\n<li>类的某些方法返回json数据<ol>\n<li>在类上添加@Controller注解</li>\n<li>在方法上添加@ResonseBody</li>\n</ol>\n</li>\n</ul>\n<p><strong>设置请求的数据类型为json：</strong></p>\n<p>在方法的形参前添加@RequestBody注解</p>\n<h3 id=\"15-2-2-REST方法的前端控制器配置\"><a href=\"#15-2-2-REST方法的前端控制器配置\" class=\"headerlink\" title=\"15.2.2 REST方法的前端控制器配置\"></a>15.2.2 REST方法的前端控制器配置</h3><p>修改web.xml，把url-pattern配置的*.do改为/，表示映射所有请求</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- RESTful配置 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-2-3-对静态资源的解析\"><a href=\"#15-2-3-对静态资源的解析\" class=\"headerlink\" title=\"15.2.3 对静态资源的解析\"></a>15.2.3 对静态资源的解析</h3><p><strong>配置前端控制器的url-parttern中指定/，对静态资源的解析会失败</strong></p>\n<p><strong>解决方法：</strong>在springmvc.xml中添加静态资源解析方法</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"/js/\"</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/js/**\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:resources</span> <span class=\"attr\">localtion</span>=<span class=\"string\">\"/img/\"</span> <span class=\"attr\">mapping</span>=<span class=\"string\">\"/img/**\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"16-拦截器\"><a href=\"#16-拦截器\" class=\"headerlink\" title=\"16. 拦截器\"></a>16. 拦截器</h2><h3 id=\"16-1-定义拦截器\"><a href=\"#16-1-定义拦截器\" class=\"headerlink\" title=\"16.1 定义拦截器\"></a>16.1 定义拦截器</h3><p>定义拦截器，需要实现HandlerInterceptor接口。接口中提供三个方法，根据需求实现其中的方法即可。</p>\n<ul>\n<li>preHandle：进入Handler方法之前执行，常用于身份认证、授权。</li>\n<li>postHandle：进入Handler方法之后，返回ModelAndView之前执行，常用作指定公共模型或试图。</li>\n<li>afterCompletion：Handler执行完后执行，常用作统一异常处理、统一日志处理</li>\n</ul>\n<h3 id=\"16-2-拦截器配置\"><a href=\"#16-2-拦截器配置\" class=\"headerlink\" title=\"16.2 拦截器配置\"></a>16.2 拦截器配置</h3><h4 id=\"16-2-1-针对HandlerMapping配置\"><a href=\"#16-2-1-针对HandlerMapping配置\" class=\"headerlink\" title=\"16.2.1 针对HandlerMapping配置\"></a>16.2.1 针对HandlerMapping配置</h4><p>springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该 HandlerMapping映射成功的handler最终使用该拦截器。<strong>一般不推荐使用。</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"interceptors\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"handlerInterceptor1\"</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">\"handlerInterceptor2\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"handlerInterceptor1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"springmvc.intercapter.HandlerInterceptor1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"handlerInterceptor2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"springmvc.intercapter.HandlerInterceptor2\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"16-2-2-类似全局的拦截器\"><a href=\"#16-2-2-类似全局的拦截器\" class=\"headerlink\" title=\"16.2.2 类似全局的拦截器\"></a>16.2.2 类似全局的拦截器</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--拦截器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--多个拦截器，依次执行--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--/**表示拦截所有请求--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/**\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.demo.ssm.interceptor.LoginInterceptor\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-3-两个拦截器执行情况总结\"><a href=\"#16-3-两个拦截器执行情况总结\" class=\"headerlink\" title=\"16.3 两个拦截器执行情况总结\"></a>16.3 两个拦截器执行情况总结</h3><h4 id=\"16-3-1-两个拦截器都放行\"><a href=\"#16-3-1-两个拦截器都放行\" class=\"headerlink\" title=\"16.3.1 两个拦截器都放行\"></a>16.3.1 两个拦截器都放行</h4><ul>\n<li>preHandle方法按顺序执行。</li>\n<li>postHandle和afterCompletion按拦截器配置的逆向顺序执行。</li>\n</ul>\n<h4 id=\"16-3-2-拦截器1放行，拦截器2不放行\"><a href=\"#16-3-2-拦截器1放行，拦截器2不放行\" class=\"headerlink\" title=\"16.3.2 拦截器1放行，拦截器2不放行\"></a>16.3.2 拦截器1放行，拦截器2不放行</h4><ul>\n<li>拦截器1放行，拦截器2 preHandle才会执行。</li>\n<li>拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。</li>\n<li>只要有一个拦截器不放行，postHandle就不会执行。</li>\n</ul>\n<h4 id=\"16-3-3-拦截器1不放行，拦截器2不放行\"><a href=\"#16-3-3-拦截器1不放行，拦截器2不放行\" class=\"headerlink\" title=\"16.3.3 拦截器1不放行，拦截器2不放行\"></a>16.3.3 拦截器1不放行，拦截器2不放行</h4><ul>\n<li>拦截器1postHandle和afterCompletion不会执行。</li>\n<li>拦截器2不会执行。</li>\n</ul>\n<h4 id=\"16-3-4-总结\"><a href=\"#16-3-4-总结\" class=\"headerlink\" title=\"16.3.4 总结\"></a>16.3.4 总结</h4><p>根据测试结果，对拦截器可以如下应用：</p>\n<ul>\n<li>统一日志处理拦截器，需要该 拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。</li>\n<li>登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后（因为登陆通过后才校验权限）。</li>\n</ul>\n"},{"title":"Spring学习笔记","date":"2018-12-05T07:52:28.000Z","_content":"\n# Spring学习笔记\n\n## 1. Spring概念\n\n- spring是开源的轻量级框架\n- spring核心主要两部分\n  - aop：面向切面编程，扩展功能不是修改源代码实现\n  - ioc：控制反转，比如有一个类，在类里面有方法（不是静态的方法），以前调用类里面的方法需要创建类的对象，使用对象来调用方法，创建类对象的过程，需要new出来对象，Ioc就是把对象的创建不是通过new方式实现，而是交给spring配置创建类对象\n- spring是一站式框架\n  - spring在javaee三层结构中，每一层都提供不同的解决技术\n    - web层：springMVC\n    - service层：spring的ioc\n    - dao层：spring的jdbcTemplate \n\n## 2. Spring的ioc操作\n\n- 把对象的创建交给spring进行管理\n- ioc的两种操作方式\n  - ioc的配置文件方式\n  - ioc的注解方式\n\n## 3. IoC底层原理\n\n- ioc底层原理使用技术\n  - xml配置文件\n  - dom4j解析xml\n  - 工厂设计模式\n  - 反射\n    ![ioc底层原理](https://img-blog.csdnimg.cn/20181030001454415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==,size_16,color_FFFFFF,t_70)\n\n## 4. IoC入门案例\n\n1. 通过idea创建maven项目，引入spring框架\n\n   ```xml\n   <properties>\n       <!-- spring版本号 -->\n       <spring.version>4.3.20.RELEASE</spring.version>\n       <!-- log4j日志文件管理包版本 -->\n       <slf4j.version>1.7.7</slf4j.version>\n       <log4j.version>1.2.17</log4j.version>\n   </properties>\n   <!-- spring核心包 -->\n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-core</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-web</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-oxm</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-tx</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-jdbc</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-webmvc</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-aop</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-context-support</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-test</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <!-- 日志文件管理包 -->\n   <!-- log start -->\n   <dependency>\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n       <version>${log4j.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-api</artifactId>\n       <version>${slf4j.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-log4j12</artifactId>\n       <version>${slf4j.version}</version>\n   </dependency>\n   ```\n\n2. 创建类，在类里面创建方法\n\n   ```java\n   public class User {\n       public void show() {\n           System.out.println(\"user...\");\n       }\n   }\n   ```\n\n3. 创建spring配置文件applicationContext.xml，建议放在src/main/resources下\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\">\n   \n   </beans>\n   ```\n\n4. 在spring配置文件中配置创建类\n\n   ```xml\n   <bean id=\"user\" class=\"com.xmos.ssm.model.User\"></bean>\n   ```\n\n5. 测试创建类\n\n   ```java\n   @Test\n   public void test() {\n       //加载spring配置文件，根据bean id创建对象\n       ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n       //得到配置的对象\n       User user = (User) ctx.getBean(\"user\");\n       user.show();\n   }\n   ```\n\n## 5. Spring的bean管理（xml方式）\n\n### 5.1 bean实例化的方式\n\n- 概念：在spring里通过配置文件创建对象\n\n- bean实例化的三种方式\n\n  - 使用类的无参构造创建（见入门案例）\n\n  - 使用静态工厂创建\n\n    ```java\n    public class UserFactory {\n        public static User getUser() {\n            return new User();\n        }\n    }\n    ```\n\n    ```xml\n    <bean id=\"userFactory\" class=\"com.xmos.ssm.model.UserFactory\"></bean>\n    <bean id=\"user\" class=\"com.xmos.ssm.model.UserFactory\" factory-method=\"getUser\"></bean>\n    ```\n\n  - 使用实例工厂创建\n\n    ```java\n    public class UserFactory {\n        public User getUser() {\n            return new User();\n        }\n    }\n    ```\n\n    ```xml\n    <bean id=\"userFactory\" class=\"com.xmos.ssm.model.UserFactory\"></bean>\n    <bean id=\"user\" class=\"com.xmos.ssm.model.UserFactory\" factory-bean=\"userFactory\" factory-method=\"getUser\"></bean>\n    ```\n\n### 5.2 bean标签常用属性\n\n- id：唯一标识bean，根据id值获取对象，不能包含特殊符号\n- class：类的全路径\n- name：功能和id一致，但可以包含特殊符号\n- scope：\n  - singleton：单例，默认值\n  - prototype：多例\n  - request：把创建的对象放到request域里面\n  - session：把创建的对象放到session里面\n  - globalSession：把创建的对象放到globalSession里面\n\n## 6. 属性注入（xml方式）\n\n- 概念：创建对象的时候，设置类的属性值\n- spring属性注入的两种方式\n  - set方法注入\n  - 有参构造函数注入\n\n### 6.1 注入方式\n\n#### 6.1.1 set注入\n\n```java\npublic class User {\n    private String name;\n\n    //set注入\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void show() {\n        System.out.println(\"user...\" + name);\n    }\n}\n```\n\n```xml\n<bean id=\"user\" class=\"com.xmos.ssm.model.User\">\n\t<property name=\"name\" value=\"xmos\"></property>\n</bean>\n```\n\n#### 6.1.2 有参构造注入\n\n```java\npublic class User {\n    private String name;\n\n    //有参构造注入\n    public User(String name) {\n        this.name = name;\n    }\n\n    public void show() {\n        System.out.println(\"user...\" + name);\n    }\n}\n```\n\n```xml\n<bean id=\"user\" class=\"com.xmos.ssm.model.User\">\n    <constructor-arg name=\"name\" value=\"xmos\"></constructor-arg>\n</bean>\n```\n\n### 6.2 注入对象类型\n\n1. 创建UserService和UserDao类\n\n   ```java\n   public class UserService {\n       private UserDao userDao;\n   \n       public void setUserDao(UserDao userDao) {\n           this.userDao = userDao;\n       }\n   \n       public void add() {\n           userDao.add();\n       }\n   }\n   \n   public class UserDao {\n       public void add() {\n           System.out.println(\"add...\");\n       }\n   }\n   ```\n\n2. 通过配置文件在userService中注入userDao对象\n\n   ```xml\n   <bean id=\"userDao\" class=\"com.xmos.dao.UserDao\"></bean>\n   <bean id=\"userService\" class=\"com.xmos.service.UserService\">\n       <!--通过set方法注入userDao对象-->\n       <property name=\"userDao\" ref=\"userDao\"></property>\n   </bean>\n   ```\n\n### 6.3 注入复杂类型属性\n\n- 数组\n\n  ```xml\n  <property name=\"arrs\">\n      <list>\n          <value>小王</value>\n          <value>小马</value>\n          <value>小宋</value>\n      </list>\n  </property>\n  ```\n\n- list集合\n\n  ```xml\n  <property name=\"list\">\n      <list>\n          <value>小奥</value>\n          <value>小金</value>\n          <value>小普</value>\n      </list>\t\t\t\n  </property>\n  ```\n\n- map\n\n  ```xml\n  <property name=\"map\">\n      <map>\n          <entry key=\"aa\" value=\"lucy\"></entry>\n          <entry key=\"bb\" value=\"mary\"></entry>\n          <entry key=\"cc\" value=\"tom\"></entry>\n      </map>\n  </property>\n  ```\n\n- properties类型\n\n  ```xml\n  <property name=\"properties\">\n      <props>\n          <prop key=\"driverclass\">com.mysql.jdbc.Driver</prop>\n          <prop key=\"username\">root</prop>\n      </props>\n  </property>\n  ```\n\n## 7. IoC和DI的区别\n\n- IoC：控制反转，把对象的创建交给spring进行管理\n- DI：依赖注入，设置对象的属性值\n- 关系：**依赖注入不能单独存在，需要在IoC基础之上完成操作**\n\n## 8. Spring整合web项目\n\n- 整合前：在每个servlet中都会执行以下代码获取spring容器中的对象，重复代码多，效率低\n\n  ```java\n  ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n  User user = (User)ctx.getBean(\"user\");\n  ```\n\n- 实现思想：把加载配置文件和创建对象过程放在服务器启动时候完成\n\n- 实现原理\n\n  - ServletContext\n  - ServletContextListener（监听器）\n\n- 具体过程\n\n  1. 在服务器启动时候，为每个项目创建一个ServletContext对象\n\n  2. 当监听器监听到ServletContext对象创建时候，加载spring配置文件\n\n  3. 创建spring文件配置的类的对象\n\n  4. 通过ServletContext.setAttribute()方法添加创建出的对象\n\n  5. 通过ServletContext.getAttribute()获取创建的对象\n\n     ```xml\n     <!--指定监听器加载spring配置文件路径-->\n     <context-param>\n         <param-name>contextConfigLocation</param-name>\n         <param-value>classpath:applicationContext.xml</param-value>\n     </context-param>\n     <!--配置监听器-->\n     <listener>\n         <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n     </listener>\n     ```\n\n## 9. Spring的bean管理（注解）\n\n### 9.1 注解介绍\n\n- 代码里面的特殊标记，可以完成某些功能\n- 注解的写法：@注解名称(属性名=属性值)，只有属性值时，属性名默认是value属性\n- 注解可以使用在类，方法和属性上面\n\n### 9.2 注解创建对象\n\n#### 9.2.1 步骤\n\n1. spring配置文件中开启注解扫描\n\n   ```xml\n   <!--开启注解扫描，扫描包里面类、方法、属性上是否有注解-->\n   <context:component-scan base-package=\"com.xmos.ssm\"></context:component-scan>\n   <!--扫描属性上的注解，有了上面就不用配置-->\n   <!--<context:annotation-config></context:annotation-config>-->\n   ```\n\n2. 使用注解创建对象\n\n   ```java\n   @Component(value=\"user\") //相当于<bean id=\"user\" class=\"\"></bean>\n   public class User {}\n   ```\n\n3. 测试\n\n   ```java\n   @Test\n   public void test() {\n       ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n       User user = (User) ctx.getBean(\"user\");\n       user.show();\n   }\n   ```\n\n#### 9.2.2 分析\n\n1. 创建对象有四个注解，功能都一样\n   - @Component\n   - @Controller：WEB层\n   - @Service：业务层\n   - @Repository：持久层\n2. 设置创建对象是单实例还是多实例\n   - @Scope(\"singleton\")：单例\n   - @Scope(\"prototype\")：多例\n\n### 9.3 注解注入属性\n\n1. @Autowired\n\n   默认按类型装配（这个注解是属于spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n\n2. @Resource\n\n   - 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常\n\n   - 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常\n\n   - 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常\n\n   - 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；\n\n## 10. AOP概念（未完）\n\n\n\n## 11. Spring的声明式事务管理（注解）\n\n1. 配置数据源\n\n   ```XML\n   <!--配置数据源-->\n   <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n       <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n       <property name=\"url\" value=\"jdbc:mysql://localhost:3306/jdbc\"></property>\n       <property name=\"username\" value=\"root\"></property>\n       <property name=\"password\" value=\"123456\"></property>\n   </bean>\n   ```\n\n2. 配置事务管理器\n\n   ```XML\n   <!--配置事务管理器-->\n   <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n       <!--注入dataSource-->\n       <property name=\"dataSource\" value=\"dataSource\"></property>\n   </bean>\n   ```\n\n3. 配置JdbcTemplate\n\n   ```xml\n   <!--配置JdbcTemplate-->\n   <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n       <!--注入dataSource-->\n       <property name=\"dataSource\" ref=\"dataSource\"></property>\n   </bean>\n   ```\n\n4. 开启事务注解\n\n   ```XML\n   <!--开启事务注解-->\n   <tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n   ```\n\n5. 在需要使用事务的方法或类上添加注解，遇到**运行时异常**自动回滚\n\n   ```java\n   @Transactional\n   public void transferAccount() {\n       String sql = \"update user set amt=amt-1000 where name='tmos'\";\n       jdbcTemplate.update(sql);\n       int i = 1/0;\n       sql = \"update user set amt=amt+1000 where name='xmos'\";\n       jdbcTemplate.update(sql);\n   }\n   ```","source":"_posts/Spring学习笔记.md","raw":"---\ntitle: Spring学习笔记\ndate: 2018-12-05 15:52:28\ntags: 学习笔记\n---\n\n# Spring学习笔记\n\n## 1. Spring概念\n\n- spring是开源的轻量级框架\n- spring核心主要两部分\n  - aop：面向切面编程，扩展功能不是修改源代码实现\n  - ioc：控制反转，比如有一个类，在类里面有方法（不是静态的方法），以前调用类里面的方法需要创建类的对象，使用对象来调用方法，创建类对象的过程，需要new出来对象，Ioc就是把对象的创建不是通过new方式实现，而是交给spring配置创建类对象\n- spring是一站式框架\n  - spring在javaee三层结构中，每一层都提供不同的解决技术\n    - web层：springMVC\n    - service层：spring的ioc\n    - dao层：spring的jdbcTemplate \n\n## 2. Spring的ioc操作\n\n- 把对象的创建交给spring进行管理\n- ioc的两种操作方式\n  - ioc的配置文件方式\n  - ioc的注解方式\n\n## 3. IoC底层原理\n\n- ioc底层原理使用技术\n  - xml配置文件\n  - dom4j解析xml\n  - 工厂设计模式\n  - 反射\n    ![ioc底层原理](https://img-blog.csdnimg.cn/20181030001454415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==,size_16,color_FFFFFF,t_70)\n\n## 4. IoC入门案例\n\n1. 通过idea创建maven项目，引入spring框架\n\n   ```xml\n   <properties>\n       <!-- spring版本号 -->\n       <spring.version>4.3.20.RELEASE</spring.version>\n       <!-- log4j日志文件管理包版本 -->\n       <slf4j.version>1.7.7</slf4j.version>\n       <log4j.version>1.2.17</log4j.version>\n   </properties>\n   <!-- spring核心包 -->\n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-core</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-web</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-oxm</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-tx</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-jdbc</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-webmvc</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-aop</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-context-support</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-test</artifactId>\n       <version>${spring.version}</version>\n   </dependency>\n   \n   <!-- 日志文件管理包 -->\n   <!-- log start -->\n   <dependency>\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n       <version>${log4j.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-api</artifactId>\n       <version>${slf4j.version}</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>org.slf4j</groupId>\n       <artifactId>slf4j-log4j12</artifactId>\n       <version>${slf4j.version}</version>\n   </dependency>\n   ```\n\n2. 创建类，在类里面创建方法\n\n   ```java\n   public class User {\n       public void show() {\n           System.out.println(\"user...\");\n       }\n   }\n   ```\n\n3. 创建spring配置文件applicationContext.xml，建议放在src/main/resources下\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\">\n   \n   </beans>\n   ```\n\n4. 在spring配置文件中配置创建类\n\n   ```xml\n   <bean id=\"user\" class=\"com.xmos.ssm.model.User\"></bean>\n   ```\n\n5. 测试创建类\n\n   ```java\n   @Test\n   public void test() {\n       //加载spring配置文件，根据bean id创建对象\n       ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n       //得到配置的对象\n       User user = (User) ctx.getBean(\"user\");\n       user.show();\n   }\n   ```\n\n## 5. Spring的bean管理（xml方式）\n\n### 5.1 bean实例化的方式\n\n- 概念：在spring里通过配置文件创建对象\n\n- bean实例化的三种方式\n\n  - 使用类的无参构造创建（见入门案例）\n\n  - 使用静态工厂创建\n\n    ```java\n    public class UserFactory {\n        public static User getUser() {\n            return new User();\n        }\n    }\n    ```\n\n    ```xml\n    <bean id=\"userFactory\" class=\"com.xmos.ssm.model.UserFactory\"></bean>\n    <bean id=\"user\" class=\"com.xmos.ssm.model.UserFactory\" factory-method=\"getUser\"></bean>\n    ```\n\n  - 使用实例工厂创建\n\n    ```java\n    public class UserFactory {\n        public User getUser() {\n            return new User();\n        }\n    }\n    ```\n\n    ```xml\n    <bean id=\"userFactory\" class=\"com.xmos.ssm.model.UserFactory\"></bean>\n    <bean id=\"user\" class=\"com.xmos.ssm.model.UserFactory\" factory-bean=\"userFactory\" factory-method=\"getUser\"></bean>\n    ```\n\n### 5.2 bean标签常用属性\n\n- id：唯一标识bean，根据id值获取对象，不能包含特殊符号\n- class：类的全路径\n- name：功能和id一致，但可以包含特殊符号\n- scope：\n  - singleton：单例，默认值\n  - prototype：多例\n  - request：把创建的对象放到request域里面\n  - session：把创建的对象放到session里面\n  - globalSession：把创建的对象放到globalSession里面\n\n## 6. 属性注入（xml方式）\n\n- 概念：创建对象的时候，设置类的属性值\n- spring属性注入的两种方式\n  - set方法注入\n  - 有参构造函数注入\n\n### 6.1 注入方式\n\n#### 6.1.1 set注入\n\n```java\npublic class User {\n    private String name;\n\n    //set注入\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void show() {\n        System.out.println(\"user...\" + name);\n    }\n}\n```\n\n```xml\n<bean id=\"user\" class=\"com.xmos.ssm.model.User\">\n\t<property name=\"name\" value=\"xmos\"></property>\n</bean>\n```\n\n#### 6.1.2 有参构造注入\n\n```java\npublic class User {\n    private String name;\n\n    //有参构造注入\n    public User(String name) {\n        this.name = name;\n    }\n\n    public void show() {\n        System.out.println(\"user...\" + name);\n    }\n}\n```\n\n```xml\n<bean id=\"user\" class=\"com.xmos.ssm.model.User\">\n    <constructor-arg name=\"name\" value=\"xmos\"></constructor-arg>\n</bean>\n```\n\n### 6.2 注入对象类型\n\n1. 创建UserService和UserDao类\n\n   ```java\n   public class UserService {\n       private UserDao userDao;\n   \n       public void setUserDao(UserDao userDao) {\n           this.userDao = userDao;\n       }\n   \n       public void add() {\n           userDao.add();\n       }\n   }\n   \n   public class UserDao {\n       public void add() {\n           System.out.println(\"add...\");\n       }\n   }\n   ```\n\n2. 通过配置文件在userService中注入userDao对象\n\n   ```xml\n   <bean id=\"userDao\" class=\"com.xmos.dao.UserDao\"></bean>\n   <bean id=\"userService\" class=\"com.xmos.service.UserService\">\n       <!--通过set方法注入userDao对象-->\n       <property name=\"userDao\" ref=\"userDao\"></property>\n   </bean>\n   ```\n\n### 6.3 注入复杂类型属性\n\n- 数组\n\n  ```xml\n  <property name=\"arrs\">\n      <list>\n          <value>小王</value>\n          <value>小马</value>\n          <value>小宋</value>\n      </list>\n  </property>\n  ```\n\n- list集合\n\n  ```xml\n  <property name=\"list\">\n      <list>\n          <value>小奥</value>\n          <value>小金</value>\n          <value>小普</value>\n      </list>\t\t\t\n  </property>\n  ```\n\n- map\n\n  ```xml\n  <property name=\"map\">\n      <map>\n          <entry key=\"aa\" value=\"lucy\"></entry>\n          <entry key=\"bb\" value=\"mary\"></entry>\n          <entry key=\"cc\" value=\"tom\"></entry>\n      </map>\n  </property>\n  ```\n\n- properties类型\n\n  ```xml\n  <property name=\"properties\">\n      <props>\n          <prop key=\"driverclass\">com.mysql.jdbc.Driver</prop>\n          <prop key=\"username\">root</prop>\n      </props>\n  </property>\n  ```\n\n## 7. IoC和DI的区别\n\n- IoC：控制反转，把对象的创建交给spring进行管理\n- DI：依赖注入，设置对象的属性值\n- 关系：**依赖注入不能单独存在，需要在IoC基础之上完成操作**\n\n## 8. Spring整合web项目\n\n- 整合前：在每个servlet中都会执行以下代码获取spring容器中的对象，重复代码多，效率低\n\n  ```java\n  ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n  User user = (User)ctx.getBean(\"user\");\n  ```\n\n- 实现思想：把加载配置文件和创建对象过程放在服务器启动时候完成\n\n- 实现原理\n\n  - ServletContext\n  - ServletContextListener（监听器）\n\n- 具体过程\n\n  1. 在服务器启动时候，为每个项目创建一个ServletContext对象\n\n  2. 当监听器监听到ServletContext对象创建时候，加载spring配置文件\n\n  3. 创建spring文件配置的类的对象\n\n  4. 通过ServletContext.setAttribute()方法添加创建出的对象\n\n  5. 通过ServletContext.getAttribute()获取创建的对象\n\n     ```xml\n     <!--指定监听器加载spring配置文件路径-->\n     <context-param>\n         <param-name>contextConfigLocation</param-name>\n         <param-value>classpath:applicationContext.xml</param-value>\n     </context-param>\n     <!--配置监听器-->\n     <listener>\n         <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n     </listener>\n     ```\n\n## 9. Spring的bean管理（注解）\n\n### 9.1 注解介绍\n\n- 代码里面的特殊标记，可以完成某些功能\n- 注解的写法：@注解名称(属性名=属性值)，只有属性值时，属性名默认是value属性\n- 注解可以使用在类，方法和属性上面\n\n### 9.2 注解创建对象\n\n#### 9.2.1 步骤\n\n1. spring配置文件中开启注解扫描\n\n   ```xml\n   <!--开启注解扫描，扫描包里面类、方法、属性上是否有注解-->\n   <context:component-scan base-package=\"com.xmos.ssm\"></context:component-scan>\n   <!--扫描属性上的注解，有了上面就不用配置-->\n   <!--<context:annotation-config></context:annotation-config>-->\n   ```\n\n2. 使用注解创建对象\n\n   ```java\n   @Component(value=\"user\") //相当于<bean id=\"user\" class=\"\"></bean>\n   public class User {}\n   ```\n\n3. 测试\n\n   ```java\n   @Test\n   public void test() {\n       ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n       User user = (User) ctx.getBean(\"user\");\n       user.show();\n   }\n   ```\n\n#### 9.2.2 分析\n\n1. 创建对象有四个注解，功能都一样\n   - @Component\n   - @Controller：WEB层\n   - @Service：业务层\n   - @Repository：持久层\n2. 设置创建对象是单实例还是多实例\n   - @Scope(\"singleton\")：单例\n   - @Scope(\"prototype\")：多例\n\n### 9.3 注解注入属性\n\n1. @Autowired\n\n   默认按类型装配（这个注解是属于spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用\n\n2. @Resource\n\n   - 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常\n\n   - 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常\n\n   - 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常\n\n   - 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；\n\n## 10. AOP概念（未完）\n\n\n\n## 11. Spring的声明式事务管理（注解）\n\n1. 配置数据源\n\n   ```XML\n   <!--配置数据源-->\n   <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n       <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n       <property name=\"url\" value=\"jdbc:mysql://localhost:3306/jdbc\"></property>\n       <property name=\"username\" value=\"root\"></property>\n       <property name=\"password\" value=\"123456\"></property>\n   </bean>\n   ```\n\n2. 配置事务管理器\n\n   ```XML\n   <!--配置事务管理器-->\n   <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n       <!--注入dataSource-->\n       <property name=\"dataSource\" value=\"dataSource\"></property>\n   </bean>\n   ```\n\n3. 配置JdbcTemplate\n\n   ```xml\n   <!--配置JdbcTemplate-->\n   <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n       <!--注入dataSource-->\n       <property name=\"dataSource\" ref=\"dataSource\"></property>\n   </bean>\n   ```\n\n4. 开启事务注解\n\n   ```XML\n   <!--开启事务注解-->\n   <tx:annotation-driven transaction-manager=\"transactionManager\"></tx:annotation-driven>\n   ```\n\n5. 在需要使用事务的方法或类上添加注解，遇到**运行时异常**自动回滚\n\n   ```java\n   @Transactional\n   public void transferAccount() {\n       String sql = \"update user set amt=amt-1000 where name='tmos'\";\n       jdbcTemplate.update(sql);\n       int i = 1/0;\n       sql = \"update user set amt=amt+1000 where name='xmos'\";\n       jdbcTemplate.update(sql);\n   }\n   ```","slug":"Spring学习笔记","published":1,"updated":"2019-09-02T16:09:10.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck037qbqj0009liyd7gb1e2lg","content":"<h1 id=\"Spring学习笔记\"><a href=\"#Spring学习笔记\" class=\"headerlink\" title=\"Spring学习笔记\"></a>Spring学习笔记</h1><h2 id=\"1-Spring概念\"><a href=\"#1-Spring概念\" class=\"headerlink\" title=\"1. Spring概念\"></a>1. Spring概念</h2><ul>\n<li>spring是开源的轻量级框架</li>\n<li>spring核心主要两部分<ul>\n<li>aop：面向切面编程，扩展功能不是修改源代码实现</li>\n<li>ioc：控制反转，比如有一个类，在类里面有方法（不是静态的方法），以前调用类里面的方法需要创建类的对象，使用对象来调用方法，创建类对象的过程，需要new出来对象，Ioc就是把对象的创建不是通过new方式实现，而是交给spring配置创建类对象</li>\n</ul>\n</li>\n<li>spring是一站式框架<ul>\n<li>spring在javaee三层结构中，每一层都提供不同的解决技术<ul>\n<li>web层：springMVC</li>\n<li>service层：spring的ioc</li>\n<li>dao层：spring的jdbcTemplate </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Spring的ioc操作\"><a href=\"#2-Spring的ioc操作\" class=\"headerlink\" title=\"2. Spring的ioc操作\"></a>2. Spring的ioc操作</h2><ul>\n<li>把对象的创建交给spring进行管理</li>\n<li>ioc的两种操作方式<ul>\n<li>ioc的配置文件方式</li>\n<li>ioc的注解方式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-IoC底层原理\"><a href=\"#3-IoC底层原理\" class=\"headerlink\" title=\"3. IoC底层原理\"></a>3. IoC底层原理</h2><ul>\n<li>ioc底层原理使用技术<ul>\n<li>xml配置文件</li>\n<li>dom4j解析xml</li>\n<li>工厂设计模式</li>\n<li>反射<br><img src=\"https://img-blog.csdnimg.cn/20181030001454415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==,size_16,color_FFFFFF,t_70\" alt=\"ioc底层原理\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-IoC入门案例\"><a href=\"#4-IoC入门案例\" class=\"headerlink\" title=\"4. IoC入门案例\"></a>4. IoC入门案例</h2><ol>\n<li><p>通过idea创建maven项目，引入spring框架</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- spring版本号 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spring.version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- log4j日志文件管理包版本 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slf4j.version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">slf4j.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">log4j.version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">log4j.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- spring核心包 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-oxm<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 日志文件管理包 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- log start --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;log4j.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建类，在类里面创建方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建spring配置文件applicationContext.xml，建议放在src/main/resources下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span> <span class=\"attr\">xmlns:tx</span>=<span class=\"string\">\"http://www.springframework.org/schema/tx\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件中配置创建类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.User\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试创建类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加载spring配置文件，根据bean id创建对象</span></span><br><span class=\"line\">    ApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//得到配置的对象</span></span><br><span class=\"line\">    User user = (User) ctx.getBean(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">    user.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"5-Spring的bean管理（xml方式）\"><a href=\"#5-Spring的bean管理（xml方式）\" class=\"headerlink\" title=\"5. Spring的bean管理（xml方式）\"></a>5. Spring的bean管理（xml方式）</h2><h3 id=\"5-1-bean实例化的方式\"><a href=\"#5-1-bean实例化的方式\" class=\"headerlink\" title=\"5.1 bean实例化的方式\"></a>5.1 bean实例化的方式</h3><ul>\n<li><p>概念：在spring里通过配置文件创建对象</p>\n</li>\n<li><p>bean实例化的三种方式</p>\n<ul>\n<li><p>使用类的无参构造创建（见入门案例）</p>\n</li>\n<li><p>使用静态工厂创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getUser\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用实例工厂创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span> <span class=\"attr\">factory-bean</span>=<span class=\"string\">\"userFactory\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getUser\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-bean标签常用属性\"><a href=\"#5-2-bean标签常用属性\" class=\"headerlink\" title=\"5.2 bean标签常用属性\"></a>5.2 bean标签常用属性</h3><ul>\n<li>id：唯一标识bean，根据id值获取对象，不能包含特殊符号</li>\n<li>class：类的全路径</li>\n<li>name：功能和id一致，但可以包含特殊符号</li>\n<li>scope：<ul>\n<li>singleton：单例，默认值</li>\n<li>prototype：多例</li>\n<li>request：把创建的对象放到request域里面</li>\n<li>session：把创建的对象放到session里面</li>\n<li>globalSession：把创建的对象放到globalSession里面</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-属性注入（xml方式）\"><a href=\"#6-属性注入（xml方式）\" class=\"headerlink\" title=\"6. 属性注入（xml方式）\"></a>6. 属性注入（xml方式）</h2><ul>\n<li>概念：创建对象的时候，设置类的属性值</li>\n<li>spring属性注入的两种方式<ul>\n<li>set方法注入</li>\n<li>有参构造函数注入</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-1-注入方式\"><a href=\"#6-1-注入方式\" class=\"headerlink\" title=\"6.1 注入方式\"></a>6.1 注入方式</h3><h4 id=\"6-1-1-set注入\"><a href=\"#6-1-1-set注入\" class=\"headerlink\" title=\"6.1.1 set注入\"></a>6.1.1 set注入</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//set注入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user...\"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.User\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"xmos\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-1-2-有参构造注入\"><a href=\"#6-1-2-有参构造注入\" class=\"headerlink\" title=\"6.1.2 有参构造注入\"></a>6.1.2 有参构造注入</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造注入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user...\"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.User\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"xmos\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-注入对象类型\"><a href=\"#6-2-注入对象类型\" class=\"headerlink\" title=\"6.2 注入对象类型\"></a>6.2 注入对象类型</h3><ol>\n<li><p>创建UserService和UserDao类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserDao</span><span class=\"params\">(UserDao userDao)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userDao = userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        userDao.add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"add...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过配置文件在userService中注入userDao对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.dao.UserDao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.service.UserService\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--通过set方法注入userDao对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"userDao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"6-3-注入复杂类型属性\"><a href=\"#6-3-注入复杂类型属性\" class=\"headerlink\" title=\"6.3 注入复杂类型属性\"></a>6.3 注入复杂类型属性</h3><ul>\n<li><p>数组</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"arrs\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小王<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小马<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小宋<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>list集合</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小奥<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小金<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小普<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span>\t\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>map</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"map\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"aa\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"lucy\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"bb\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"mary\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"cc\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"tom\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>properties类型</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"properties\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"driverclass\"</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"7-IoC和DI的区别\"><a href=\"#7-IoC和DI的区别\" class=\"headerlink\" title=\"7. IoC和DI的区别\"></a>7. IoC和DI的区别</h2><ul>\n<li>IoC：控制反转，把对象的创建交给spring进行管理</li>\n<li>DI：依赖注入，设置对象的属性值</li>\n<li>关系：<strong>依赖注入不能单独存在，需要在IoC基础之上完成操作</strong></li>\n</ul>\n<h2 id=\"8-Spring整合web项目\"><a href=\"#8-Spring整合web项目\" class=\"headerlink\" title=\"8. Spring整合web项目\"></a>8. Spring整合web项目</h2><ul>\n<li><p>整合前：在每个servlet中都会执行以下代码获取spring容器中的对象，重复代码多，效率低</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">User user = (User)ctx.getBean(<span class=\"string\">\"user\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现思想：把加载配置文件和创建对象过程放在服务器启动时候完成</p>\n</li>\n<li><p>实现原理</p>\n<ul>\n<li>ServletContext</li>\n<li>ServletContextListener（监听器）</li>\n</ul>\n</li>\n<li><p>具体过程</p>\n<ol>\n<li><p>在服务器启动时候，为每个项目创建一个ServletContext对象</p>\n</li>\n<li><p>当监听器监听到ServletContext对象创建时候，加载spring配置文件</p>\n</li>\n<li><p>创建spring文件配置的类的对象</p>\n</li>\n<li><p>通过ServletContext.setAttribute()方法添加创建出的对象</p>\n</li>\n<li><p>通过ServletContext.getAttribute()获取创建的对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--指定监听器加载spring配置文件路径--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--配置监听器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"9-Spring的bean管理（注解）\"><a href=\"#9-Spring的bean管理（注解）\" class=\"headerlink\" title=\"9. Spring的bean管理（注解）\"></a>9. Spring的bean管理（注解）</h2><h3 id=\"9-1-注解介绍\"><a href=\"#9-1-注解介绍\" class=\"headerlink\" title=\"9.1 注解介绍\"></a>9.1 注解介绍</h3><ul>\n<li>代码里面的特殊标记，可以完成某些功能</li>\n<li>注解的写法：@注解名称(属性名=属性值)，只有属性值时，属性名默认是value属性</li>\n<li>注解可以使用在类，方法和属性上面</li>\n</ul>\n<h3 id=\"9-2-注解创建对象\"><a href=\"#9-2-注解创建对象\" class=\"headerlink\" title=\"9.2 注解创建对象\"></a>9.2 注解创建对象</h3><h4 id=\"9-2-1-步骤\"><a href=\"#9-2-1-步骤\" class=\"headerlink\" title=\"9.2.1 步骤\"></a>9.2.1 步骤</h4><ol>\n<li><p>spring配置文件中开启注解扫描</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--开启注解扫描，扫描包里面类、方法、属性上是否有注解--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.xmos.ssm\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--扫描属性上的注解，有了上面就不用配置--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用注解创建对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(value=<span class=\"string\">\"user\"</span>) <span class=\"comment\">//相当于&lt;bean id=\"user\" class=\"\"&gt;&lt;/bean&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">    User user = (User) ctx.getBean(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">    user.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"9-2-2-分析\"><a href=\"#9-2-2-分析\" class=\"headerlink\" title=\"9.2.2 分析\"></a>9.2.2 分析</h4><ol>\n<li>创建对象有四个注解，功能都一样<ul>\n<li>@Component</li>\n<li>@Controller：WEB层</li>\n<li>@Service：业务层</li>\n<li>@Repository：持久层</li>\n</ul>\n</li>\n<li>设置创建对象是单实例还是多实例<ul>\n<li>@Scope(“singleton”)：单例</li>\n<li>@Scope(“prototype”)：多例</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"9-3-注解注入属性\"><a href=\"#9-3-注解注入属性\" class=\"headerlink\" title=\"9.3 注解注入属性\"></a>9.3 注解注入属性</h3><ol>\n<li><p>@Autowired</p>\n<p>默认按类型装配（这个注解是属于spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>\n</li>\n<li><p>@Resource</p>\n<ul>\n<li><p>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</p>\n</li>\n<li><p>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</p>\n</li>\n<li><p>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</p>\n</li>\n<li><p>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"10-AOP概念（未完）\"><a href=\"#10-AOP概念（未完）\" class=\"headerlink\" title=\"10. AOP概念（未完）\"></a>10. AOP概念（未完）</h2><h2 id=\"11-Spring的声明式事务管理（注解）\"><a href=\"#11-Spring的声明式事务管理（注解）\" class=\"headerlink\" title=\"11. Spring的声明式事务管理（注解）\"></a>11. Spring的声明式事务管理（注解）</h2><ol>\n<li><p>配置数据源</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置数据源--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/jdbc\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置事务管理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置事务管理器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--注入dataSource--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置JdbcTemplate</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置JdbcTemplate--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.core.JdbcTemplate\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--注入dataSource--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启事务注解</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--开启事务注解--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在需要使用事务的方法或类上添加注解，遇到<strong>运行时异常</strong>自动回滚</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transferAccount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String sql = <span class=\"string\">\"update user set amt=amt-1000 where name='tmos'\"</span>;</span><br><span class=\"line\">    jdbcTemplate.update(sql);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">    sql = <span class=\"string\">\"update user set amt=amt+1000 where name='xmos'\"</span>;</span><br><span class=\"line\">    jdbcTemplate.update(sql);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h1 id=\"Spring学习笔记\"><a href=\"#Spring学习笔记\" class=\"headerlink\" title=\"Spring学习笔记\"></a>Spring学习笔记</h1><h2 id=\"1-Spring概念\"><a href=\"#1-Spring概念\" class=\"headerlink\" title=\"1. Spring概念\"></a>1. Spring概念</h2><ul>\n<li>spring是开源的轻量级框架</li>\n<li>spring核心主要两部分<ul>\n<li>aop：面向切面编程，扩展功能不是修改源代码实现</li>\n<li>ioc：控制反转，比如有一个类，在类里面有方法（不是静态的方法），以前调用类里面的方法需要创建类的对象，使用对象来调用方法，创建类对象的过程，需要new出来对象，Ioc就是把对象的创建不是通过new方式实现，而是交给spring配置创建类对象</li>\n</ul>\n</li>\n<li>spring是一站式框架<ul>\n<li>spring在javaee三层结构中，每一层都提供不同的解决技术<ul>\n<li>web层：springMVC</li>\n<li>service层：spring的ioc</li>\n<li>dao层：spring的jdbcTemplate </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Spring的ioc操作\"><a href=\"#2-Spring的ioc操作\" class=\"headerlink\" title=\"2. Spring的ioc操作\"></a>2. Spring的ioc操作</h2><ul>\n<li>把对象的创建交给spring进行管理</li>\n<li>ioc的两种操作方式<ul>\n<li>ioc的配置文件方式</li>\n<li>ioc的注解方式</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-IoC底层原理\"><a href=\"#3-IoC底层原理\" class=\"headerlink\" title=\"3. IoC底层原理\"></a>3. IoC底层原理</h2><ul>\n<li>ioc底层原理使用技术<ul>\n<li>xml配置文件</li>\n<li>dom4j解析xml</li>\n<li>工厂设计模式</li>\n<li>反射<br><img src=\"https://img-blog.csdnimg.cn/20181030001454415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==,size_16,color_FFFFFF,t_70\" alt=\"ioc底层原理\"></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-IoC入门案例\"><a href=\"#4-IoC入门案例\" class=\"headerlink\" title=\"4. IoC入门案例\"></a>4. IoC入门案例</h2><ol>\n<li><p>通过idea创建maven项目，引入spring框架</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- spring版本号 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spring.version</span>&gt;</span>4.3.20.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- log4j日志文件管理包版本 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">slf4j.version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">slf4j.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">log4j.version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">log4j.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- spring核心包 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-oxm<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-webmvc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 日志文件管理包 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- log start --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;log4j.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建类，在类里面创建方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建spring配置文件applicationContext.xml，建议放在src/main/resources下</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:context</span>=<span class=\"string\">\"http://www.springframework.org/schema/context\"</span> <span class=\"attr\">xmlns:tx</span>=<span class=\"string\">\"http://www.springframework.org/schema/tx\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在spring配置文件中配置创建类</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.User\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试创建类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加载spring配置文件，根据bean id创建对象</span></span><br><span class=\"line\">    ApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//得到配置的对象</span></span><br><span class=\"line\">    User user = (User) ctx.getBean(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">    user.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"5-Spring的bean管理（xml方式）\"><a href=\"#5-Spring的bean管理（xml方式）\" class=\"headerlink\" title=\"5. Spring的bean管理（xml方式）\"></a>5. Spring的bean管理（xml方式）</h2><h3 id=\"5-1-bean实例化的方式\"><a href=\"#5-1-bean实例化的方式\" class=\"headerlink\" title=\"5.1 bean实例化的方式\"></a>5.1 bean实例化的方式</h3><ul>\n<li><p>概念：在spring里通过配置文件创建对象</p>\n</li>\n<li><p>bean实例化的三种方式</p>\n<ul>\n<li><p>使用类的无参构造创建（见入门案例）</p>\n</li>\n<li><p>使用静态工厂创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getUser\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用实例工厂创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.UserFactory\"</span> <span class=\"attr\">factory-bean</span>=<span class=\"string\">\"userFactory\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getUser\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-2-bean标签常用属性\"><a href=\"#5-2-bean标签常用属性\" class=\"headerlink\" title=\"5.2 bean标签常用属性\"></a>5.2 bean标签常用属性</h3><ul>\n<li>id：唯一标识bean，根据id值获取对象，不能包含特殊符号</li>\n<li>class：类的全路径</li>\n<li>name：功能和id一致，但可以包含特殊符号</li>\n<li>scope：<ul>\n<li>singleton：单例，默认值</li>\n<li>prototype：多例</li>\n<li>request：把创建的对象放到request域里面</li>\n<li>session：把创建的对象放到session里面</li>\n<li>globalSession：把创建的对象放到globalSession里面</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"6-属性注入（xml方式）\"><a href=\"#6-属性注入（xml方式）\" class=\"headerlink\" title=\"6. 属性注入（xml方式）\"></a>6. 属性注入（xml方式）</h2><ul>\n<li>概念：创建对象的时候，设置类的属性值</li>\n<li>spring属性注入的两种方式<ul>\n<li>set方法注入</li>\n<li>有参构造函数注入</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-1-注入方式\"><a href=\"#6-1-注入方式\" class=\"headerlink\" title=\"6.1 注入方式\"></a>6.1 注入方式</h3><h4 id=\"6-1-1-set注入\"><a href=\"#6-1-1-set注入\" class=\"headerlink\" title=\"6.1.1 set注入\"></a>6.1.1 set注入</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//set注入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user...\"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.User\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"xmos\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-1-2-有参构造注入\"><a href=\"#6-1-2-有参构造注入\" class=\"headerlink\" title=\"6.1.2 有参构造注入\"></a>6.1.2 有参构造注入</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//有参构造注入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"user...\"</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.ssm.model.User\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"xmos\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-注入对象类型\"><a href=\"#6-2-注入对象类型\" class=\"headerlink\" title=\"6.2 注入对象类型\"></a>6.2 注入对象类型</h3><ol>\n<li><p>创建UserService和UserDao类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUserDao</span><span class=\"params\">(UserDao userDao)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.userDao = userDao;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        userDao.add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"add...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过配置文件在userService中注入userDao对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.dao.UserDao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"userService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xmos.service.UserService\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--通过set方法注入userDao对象--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"userDao\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"userDao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"6-3-注入复杂类型属性\"><a href=\"#6-3-注入复杂类型属性\" class=\"headerlink\" title=\"6.3 注入复杂类型属性\"></a>6.3 注入复杂类型属性</h3><ul>\n<li><p>数组</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"arrs\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小王<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小马<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小宋<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>list集合</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"list\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小奥<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小金<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>小普<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span>\t\t\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>map</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"map\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"aa\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"lucy\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"bb\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"mary\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"cc\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"tom\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>properties类型</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"properties\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"driverclass\"</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"7-IoC和DI的区别\"><a href=\"#7-IoC和DI的区别\" class=\"headerlink\" title=\"7. IoC和DI的区别\"></a>7. IoC和DI的区别</h2><ul>\n<li>IoC：控制反转，把对象的创建交给spring进行管理</li>\n<li>DI：依赖注入，设置对象的属性值</li>\n<li>关系：<strong>依赖注入不能单独存在，需要在IoC基础之上完成操作</strong></li>\n</ul>\n<h2 id=\"8-Spring整合web项目\"><a href=\"#8-Spring整合web项目\" class=\"headerlink\" title=\"8. Spring整合web项目\"></a>8. Spring整合web项目</h2><ul>\n<li><p>整合前：在每个servlet中都会执行以下代码获取spring容器中的对象，重复代码多，效率低</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">User user = (User)ctx.getBean(<span class=\"string\">\"user\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现思想：把加载配置文件和创建对象过程放在服务器启动时候完成</p>\n</li>\n<li><p>实现原理</p>\n<ul>\n<li>ServletContext</li>\n<li>ServletContextListener（监听器）</li>\n</ul>\n</li>\n<li><p>具体过程</p>\n<ol>\n<li><p>在服务器启动时候，为每个项目创建一个ServletContext对象</p>\n</li>\n<li><p>当监听器监听到ServletContext对象创建时候，加载spring配置文件</p>\n</li>\n<li><p>创建spring文件配置的类的对象</p>\n</li>\n<li><p>通过ServletContext.setAttribute()方法添加创建出的对象</p>\n</li>\n<li><p>通过ServletContext.getAttribute()获取创建的对象</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--指定监听器加载spring配置文件路径--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--配置监听器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"9-Spring的bean管理（注解）\"><a href=\"#9-Spring的bean管理（注解）\" class=\"headerlink\" title=\"9. Spring的bean管理（注解）\"></a>9. Spring的bean管理（注解）</h2><h3 id=\"9-1-注解介绍\"><a href=\"#9-1-注解介绍\" class=\"headerlink\" title=\"9.1 注解介绍\"></a>9.1 注解介绍</h3><ul>\n<li>代码里面的特殊标记，可以完成某些功能</li>\n<li>注解的写法：@注解名称(属性名=属性值)，只有属性值时，属性名默认是value属性</li>\n<li>注解可以使用在类，方法和属性上面</li>\n</ul>\n<h3 id=\"9-2-注解创建对象\"><a href=\"#9-2-注解创建对象\" class=\"headerlink\" title=\"9.2 注解创建对象\"></a>9.2 注解创建对象</h3><h4 id=\"9-2-1-步骤\"><a href=\"#9-2-1-步骤\" class=\"headerlink\" title=\"9.2.1 步骤\"></a>9.2.1 步骤</h4><ol>\n<li><p>spring配置文件中开启注解扫描</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--开启注解扫描，扫描包里面类、方法、属性上是否有注解--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.xmos.ssm\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--扫描属性上的注解，有了上面就不用配置--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用注解创建对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(value=<span class=\"string\">\"user\"</span>) <span class=\"comment\">//相当于&lt;bean id=\"user\" class=\"\"&gt;&lt;/bean&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ApplicationContext ctx = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">    User user = (User) ctx.getBean(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">    user.show();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"9-2-2-分析\"><a href=\"#9-2-2-分析\" class=\"headerlink\" title=\"9.2.2 分析\"></a>9.2.2 分析</h4><ol>\n<li>创建对象有四个注解，功能都一样<ul>\n<li>@Component</li>\n<li>@Controller：WEB层</li>\n<li>@Service：业务层</li>\n<li>@Repository：持久层</li>\n</ul>\n</li>\n<li>设置创建对象是单实例还是多实例<ul>\n<li>@Scope(“singleton”)：单例</li>\n<li>@Scope(“prototype”)：多例</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"9-3-注解注入属性\"><a href=\"#9-3-注解注入属性\" class=\"headerlink\" title=\"9.3 注解注入属性\"></a>9.3 注解注入属性</h3><ol>\n<li><p>@Autowired</p>\n<p>默认按类型装配（这个注解是属于spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>\n</li>\n<li><p>@Resource</p>\n<ul>\n<li><p>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</p>\n</li>\n<li><p>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</p>\n</li>\n<li><p>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</p>\n</li>\n<li><p>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"10-AOP概念（未完）\"><a href=\"#10-AOP概念（未完）\" class=\"headerlink\" title=\"10. AOP概念（未完）\"></a>10. AOP概念（未完）</h2><h2 id=\"11-Spring的声明式事务管理（注解）\"><a href=\"#11-Spring的声明式事务管理（注解）\" class=\"headerlink\" title=\"11. Spring的声明式事务管理（注解）\"></a>11. Spring的声明式事务管理（注解）</h2><ol>\n<li><p>配置数据源</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置数据源--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/jdbc\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置事务管理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置事务管理器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--注入dataSource--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置JdbcTemplate</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--配置JdbcTemplate--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.core.JdbcTemplate\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--注入dataSource--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启事务注解</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--开启事务注解--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在需要使用事务的方法或类上添加注解，遇到<strong>运行时异常</strong>自动回滚</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transferAccount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String sql = <span class=\"string\">\"update user set amt=amt-1000 where name='tmos'\"</span>;</span><br><span class=\"line\">    jdbcTemplate.update(sql);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">    sql = <span class=\"string\">\"update user set amt=amt+1000 where name='xmos'\"</span>;</span><br><span class=\"line\">    jdbcTemplate.update(sql);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Ubuntu 18.04 开发环境搭建","date":"2018-12-05T07:51:11.000Z","_content":"\n# Ubuntu 18.04 开发环境搭建\n\n## 一. 安装JDK\n\n1. 官网下载jdk-8u191-linux-x64.tar.gz\n2. 解压\n\n```shell\ntar zxvf jdk-8u191-linux-x64.tar.gz \nsudo mv jdk1.8.0_191 /usr/local/java \n```\n\n1. 配置环境变量\n\n```shell\necho 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191\nexport CLASSPATH=.:$JAVA_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin' >> ~/.profile\nsource ~/.profile\n\njava -version正确输出即配置完成\n```\n\n## 二. 安装Toolbox\n\n## 三. 安装npm，nodejs\n\n```shell\nsudo apt install -y nodejs\nsudo apt install -y npm\n```\n\n## 四. 安装vscode\n\n```shell\nsudo snap install vscode --classic\n```\n\n## 五. 安装ss-qt5\n\n```shell\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt install -y shadowsocks-qt5\nhzwhuang-ubuntu-ss-qt5-bionic.list 将里面的bionic 改成xenial \n```\n\n## 六. 安装Typora\n\n```shell\nwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n# add Typora's repository\nsudo add-apt-repository 'deb https://typora.io/linux ./'\nsudo apt-get update\n# install typora\nsudo apt-get install -y typora\n```\n\n## 七. 安装Tomcat\n\n1. 官网下载压缩包\n2. 解压到/usr/local/目录\n\n```shell\n  tar zxvf apache-tomcat-9.0.13\n  sudo mv apache-tomcat-9.0.13 /usr/local/\n```\n\n1. 修改startup.sh，添加CATALINA_HOME=/usr/local/apache-tomcat-9.0.13\n\n```shell\n  echo  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 >> /usr/local/apache-tomcat-9.0.13/bin/startup.sh\n```\n\n1. 在bin目录下建立setenv.sh脚本，添加JAVA_HOME=/usr/local/java/jdk1.8.0_191\n\n```shell\n  touch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\n  echo JAVA_HOME=/usr/local/java/jdk1.8.0_191 >> /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\n```\n\n1. 运行\n\n```shell\n  /usr/local/apache-tomcat-9.0.12/bin/startup.sh\n```\n\n## 八. 安装mysql\n\n1. 官网下载`mysql-apt-config_0.8.11-1_all.deb`\n2. mysql安装设置\n\n```shell\n  sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb\n```\n\n1. 安装mysql\n\n```shell\n  sudo apt update\n  sudo apt install -y mysql-server\n```\n\n1. mysql服务启动/停止\n\n```shell\n  service mysql start\n  service mysql stop\n```\n\n1. 开启mysql远程连接\n\n```shell\n  mysql -u root -p\n  use mysql;\n  update user set host='%' where user='root';\n  flush privileges; \n```\n\n## 九. 安装git\n\n```shell\nsudo apt install -y git\n```\n\n# 美化\n\n## 一. gnome\n\n```shell\nsudo apt install -y gnome-tweak-tool\nsudo apt install -y gnome-shell-extensions\n```\n\n## 二. dash to dock\n\n```shell\nsudo apt install -y gnome-shell-extension-dashtodock\n```\n\n## 三. dash to panel\n\n```shell\nsudo apt install -y gnome-shell-extension-dash-to-panel\n```\n\n## 四. VLC\n\n```shell\nsudo apt -y install vlc\n```\n\n# 自动化安装脚本\n\n> 执行脚本前请下载jdk、mysql、tomcat\n\n```shell\n#!/bin/bash\necho '安装JDK'\ncd ~/Downloads\ntar zxvf jdk-8u191-linux-x64.tar.gz \nsudo mv jdk1.8.0_191 /usr/local/java/ \necho '配置环境变量'\necho 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191\nexport CLASSPATH=.:$JAVA_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin' >> ~/.profile\necho '安装npm'\nsudo apt install -y nodejs\nsudo apt install -y npm\necho '安装git'\nsudo apt install -y git\necho '安装zsh和oh_my_zsh'\nsudo apt install -y zsh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\nsudo chsh -s /bin/zsh\necho '安装vim'\nsudo apt install -y vim\necho '安装mysql'\nsudo dpkg -i mysql-apt-config_0.8.11-1_all.deb\nsudo apt update\nsudo apt install -y mysql-server\necho '安装Tomcat'\ntar zxvf apache-tomcat-9.0.13.tar.gz\nsudo mv apache-tomcat-9.0.13 /usr/local/\necho  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 >> /usr/local/apache-tomcat-9.0.13/bin/startup.sh\ntouch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\necho JAVA_HOME=/usr/local/java/jdk1.8.0_191 >> /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\necho '安装gnome'\nsudo apt install -y gnome-tweak-tool\nsudo apt install -y gnome-shell-extensions\necho '安装dash-to-panel'\nsudo apt install -y gnome-shell-extension-dash-to-panel\necho '安装chrome'\nsudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/\nwget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install -y google-chrome-stable\necho '安装Typora'\nwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\nsudo add-apt-repository 'deb https://typora.io/linux ./'\nsudo apt-get update\nsudo apt-get install -y typora\n```","source":"_posts/Ubuntu-18-04-开发环境搭建.md","raw":"---\ntitle: Ubuntu 18.04 开发环境搭建\ndate: 2018-12-05 15:51:11\ntags: 环境搭建\n---\n\n# Ubuntu 18.04 开发环境搭建\n\n## 一. 安装JDK\n\n1. 官网下载jdk-8u191-linux-x64.tar.gz\n2. 解压\n\n```shell\ntar zxvf jdk-8u191-linux-x64.tar.gz \nsudo mv jdk1.8.0_191 /usr/local/java \n```\n\n1. 配置环境变量\n\n```shell\necho 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191\nexport CLASSPATH=.:$JAVA_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin' >> ~/.profile\nsource ~/.profile\n\njava -version正确输出即配置完成\n```\n\n## 二. 安装Toolbox\n\n## 三. 安装npm，nodejs\n\n```shell\nsudo apt install -y nodejs\nsudo apt install -y npm\n```\n\n## 四. 安装vscode\n\n```shell\nsudo snap install vscode --classic\n```\n\n## 五. 安装ss-qt5\n\n```shell\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt install -y shadowsocks-qt5\nhzwhuang-ubuntu-ss-qt5-bionic.list 将里面的bionic 改成xenial \n```\n\n## 六. 安装Typora\n\n```shell\nwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\n# add Typora's repository\nsudo add-apt-repository 'deb https://typora.io/linux ./'\nsudo apt-get update\n# install typora\nsudo apt-get install -y typora\n```\n\n## 七. 安装Tomcat\n\n1. 官网下载压缩包\n2. 解压到/usr/local/目录\n\n```shell\n  tar zxvf apache-tomcat-9.0.13\n  sudo mv apache-tomcat-9.0.13 /usr/local/\n```\n\n1. 修改startup.sh，添加CATALINA_HOME=/usr/local/apache-tomcat-9.0.13\n\n```shell\n  echo  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 >> /usr/local/apache-tomcat-9.0.13/bin/startup.sh\n```\n\n1. 在bin目录下建立setenv.sh脚本，添加JAVA_HOME=/usr/local/java/jdk1.8.0_191\n\n```shell\n  touch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\n  echo JAVA_HOME=/usr/local/java/jdk1.8.0_191 >> /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\n```\n\n1. 运行\n\n```shell\n  /usr/local/apache-tomcat-9.0.12/bin/startup.sh\n```\n\n## 八. 安装mysql\n\n1. 官网下载`mysql-apt-config_0.8.11-1_all.deb`\n2. mysql安装设置\n\n```shell\n  sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb\n```\n\n1. 安装mysql\n\n```shell\n  sudo apt update\n  sudo apt install -y mysql-server\n```\n\n1. mysql服务启动/停止\n\n```shell\n  service mysql start\n  service mysql stop\n```\n\n1. 开启mysql远程连接\n\n```shell\n  mysql -u root -p\n  use mysql;\n  update user set host='%' where user='root';\n  flush privileges; \n```\n\n## 九. 安装git\n\n```shell\nsudo apt install -y git\n```\n\n# 美化\n\n## 一. gnome\n\n```shell\nsudo apt install -y gnome-tweak-tool\nsudo apt install -y gnome-shell-extensions\n```\n\n## 二. dash to dock\n\n```shell\nsudo apt install -y gnome-shell-extension-dashtodock\n```\n\n## 三. dash to panel\n\n```shell\nsudo apt install -y gnome-shell-extension-dash-to-panel\n```\n\n## 四. VLC\n\n```shell\nsudo apt -y install vlc\n```\n\n# 自动化安装脚本\n\n> 执行脚本前请下载jdk、mysql、tomcat\n\n```shell\n#!/bin/bash\necho '安装JDK'\ncd ~/Downloads\ntar zxvf jdk-8u191-linux-x64.tar.gz \nsudo mv jdk1.8.0_191 /usr/local/java/ \necho '配置环境变量'\necho 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191\nexport CLASSPATH=.:$JAVA_HOME/lib\nexport PATH=$PATH:$JAVA_HOME/bin' >> ~/.profile\necho '安装npm'\nsudo apt install -y nodejs\nsudo apt install -y npm\necho '安装git'\nsudo apt install -y git\necho '安装zsh和oh_my_zsh'\nsudo apt install -y zsh\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\nsudo chsh -s /bin/zsh\necho '安装vim'\nsudo apt install -y vim\necho '安装mysql'\nsudo dpkg -i mysql-apt-config_0.8.11-1_all.deb\nsudo apt update\nsudo apt install -y mysql-server\necho '安装Tomcat'\ntar zxvf apache-tomcat-9.0.13.tar.gz\nsudo mv apache-tomcat-9.0.13 /usr/local/\necho  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 >> /usr/local/apache-tomcat-9.0.13/bin/startup.sh\ntouch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\necho JAVA_HOME=/usr/local/java/jdk1.8.0_191 >> /usr/local/apache-tomcat-9.0.13/bin/setenv.sh\necho '安装gnome'\nsudo apt install -y gnome-tweak-tool\nsudo apt install -y gnome-shell-extensions\necho '安装dash-to-panel'\nsudo apt install -y gnome-shell-extension-dash-to-panel\necho '安装chrome'\nsudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/\nwget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install -y google-chrome-stable\necho '安装Typora'\nwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -\nsudo add-apt-repository 'deb https://typora.io/linux ./'\nsudo apt-get update\nsudo apt-get install -y typora\n```","slug":"Ubuntu-18-04-开发环境搭建","published":1,"updated":"2019-09-02T16:09:10.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck037qbqk000bliydpw5f2s95","content":"<h1 id=\"Ubuntu-18-04-开发环境搭建\"><a href=\"#Ubuntu-18-04-开发环境搭建\" class=\"headerlink\" title=\"Ubuntu 18.04 开发环境搭建\"></a>Ubuntu 18.04 开发环境搭建</h1><h2 id=\"一-安装JDK\"><a href=\"#一-安装JDK\" class=\"headerlink\" title=\"一. 安装JDK\"></a>一. 安装JDK</h2><ol>\n<li>官网下载jdk-8u191-linux-x64.tar.gz</li>\n<li>解压</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf jdk-8u191-linux-x64.tar.gz </span><br><span class=\"line\">sudo mv jdk1.8.0_191 /usr/local/java</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>配置环境变量</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191</span><br><span class=\"line\">export CLASSPATH=.:$JAVA_HOME/lib</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin' &gt;&gt; ~/.profile</span><br><span class=\"line\">source ~/.profile</span><br><span class=\"line\"></span><br><span class=\"line\">java -version正确输出即配置完成</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二-安装Toolbox\"><a href=\"#二-安装Toolbox\" class=\"headerlink\" title=\"二. 安装Toolbox\"></a>二. 安装Toolbox</h2><h2 id=\"三-安装npm，nodejs\"><a href=\"#三-安装npm，nodejs\" class=\"headerlink\" title=\"三. 安装npm，nodejs\"></a>三. 安装npm，nodejs</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y nodejs</span><br><span class=\"line\">sudo apt install -y npm</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四-安装vscode\"><a href=\"#四-安装vscode\" class=\"headerlink\" title=\"四. 安装vscode\"></a>四. 安装vscode</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo snap install vscode --classic</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五-安装ss-qt5\"><a href=\"#五-安装ss-qt5\" class=\"headerlink\" title=\"五. 安装ss-qt5\"></a>五. 安装ss-qt5</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt install -y shadowsocks-qt5</span><br><span class=\"line\">hzwhuang-ubuntu-ss-qt5-bionic.list 将里面的bionic 改成xenial</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六-安装Typora\"><a href=\"#六-安装Typora\" class=\"headerlink\" title=\"六. 安装Typora\"></a>六. 安装Typora</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\"><span class=\"meta\">#</span> add Typora's repository</span><br><span class=\"line\">sudo add-apt-repository 'deb https://typora.io/linux ./'</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"><span class=\"meta\">#</span> install typora</span><br><span class=\"line\">sudo apt-get install -y typora</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七-安装Tomcat\"><a href=\"#七-安装Tomcat\" class=\"headerlink\" title=\"七. 安装Tomcat\"></a>七. 安装Tomcat</h2><ol>\n<li>官网下载压缩包</li>\n<li>解压到/usr/local/目录</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf apache-tomcat-9.0.13</span><br><span class=\"line\">sudo mv apache-tomcat-9.0.13 /usr/local/</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>修改startup.sh，添加CATALINA_HOME=/usr/local/apache-tomcat-9.0.13</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/startup.sh</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在bin目录下建立setenv.sh脚本，添加JAVA_HOME=/usr/local/java/jdk1.8.0_191</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br><span class=\"line\">echo JAVA_HOME=/usr/local/java/jdk1.8.0_191 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>运行</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/apache-tomcat-9.0.12/bin/startup.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八-安装mysql\"><a href=\"#八-安装mysql\" class=\"headerlink\" title=\"八. 安装mysql\"></a>八. 安装mysql</h2><ol>\n<li>官网下载<code>mysql-apt-config_0.8.11-1_all.deb</code></li>\n<li>mysql安装设置</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>安装mysql</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install -y mysql-server</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>mysql服务启动/停止</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service mysql start</span><br><span class=\"line\">service mysql stop</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>开启mysql远程连接</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set host='%' where user='root';</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九-安装git\"><a href=\"#九-安装git\" class=\"headerlink\" title=\"九. 安装git\"></a>九. 安装git</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"美化\"><a href=\"#美化\" class=\"headerlink\" title=\"美化\"></a>美化</h1><h2 id=\"一-gnome\"><a href=\"#一-gnome\" class=\"headerlink\" title=\"一. gnome\"></a>一. gnome</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y gnome-tweak-tool</span><br><span class=\"line\">sudo apt install -y gnome-shell-extensions</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二-dash-to-dock\"><a href=\"#二-dash-to-dock\" class=\"headerlink\" title=\"二. dash to dock\"></a>二. dash to dock</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y gnome-shell-extension-dashtodock</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三-dash-to-panel\"><a href=\"#三-dash-to-panel\" class=\"headerlink\" title=\"三. dash to panel\"></a>三. dash to panel</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y gnome-shell-extension-dash-to-panel</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四-VLC\"><a href=\"#四-VLC\" class=\"headerlink\" title=\"四. VLC\"></a>四. VLC</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt -y install vlc</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自动化安装脚本\"><a href=\"#自动化安装脚本\" class=\"headerlink\" title=\"自动化安装脚本\"></a>自动化安装脚本</h1><blockquote>\n<p>执行脚本前请下载jdk、mysql、tomcat</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\">echo '安装JDK'</span><br><span class=\"line\">cd ~/Downloads</span><br><span class=\"line\">tar zxvf jdk-8u191-linux-x64.tar.gz </span><br><span class=\"line\">sudo mv jdk1.8.0_191 /usr/local/java/ </span><br><span class=\"line\">echo '配置环境变量'</span><br><span class=\"line\">echo 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191</span><br><span class=\"line\">export CLASSPATH=.:$JAVA_HOME/lib</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin' &gt;&gt; ~/.profile</span><br><span class=\"line\">echo '安装npm'</span><br><span class=\"line\">sudo apt install -y nodejs</span><br><span class=\"line\">sudo apt install -y npm</span><br><span class=\"line\">echo '安装git'</span><br><span class=\"line\">sudo apt install -y git</span><br><span class=\"line\">echo '安装zsh和oh_my_zsh'</span><br><span class=\"line\">sudo apt install -y zsh</span><br><span class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class=\"line\">sudo chsh -s /bin/zsh</span><br><span class=\"line\">echo '安装vim'</span><br><span class=\"line\">sudo apt install -y vim</span><br><span class=\"line\">echo '安装mysql'</span><br><span class=\"line\">sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install -y mysql-server</span><br><span class=\"line\">echo '安装Tomcat'</span><br><span class=\"line\">tar zxvf apache-tomcat-9.0.13.tar.gz</span><br><span class=\"line\">sudo mv apache-tomcat-9.0.13 /usr/local/</span><br><span class=\"line\">echo  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/startup.sh</span><br><span class=\"line\">touch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br><span class=\"line\">echo JAVA_HOME=/usr/local/java/jdk1.8.0_191 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br><span class=\"line\">echo '安装gnome'</span><br><span class=\"line\">sudo apt install -y gnome-tweak-tool</span><br><span class=\"line\">sudo apt install -y gnome-shell-extensions</span><br><span class=\"line\">echo '安装dash-to-panel'</span><br><span class=\"line\">sudo apt install -y gnome-shell-extension-dash-to-panel</span><br><span class=\"line\">echo '安装chrome'</span><br><span class=\"line\">sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/</span><br><span class=\"line\">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install -y google-chrome-stable</span><br><span class=\"line\">echo '安装Typora'</span><br><span class=\"line\">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\">sudo add-apt-repository 'deb https://typora.io/linux ./'</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install -y typora</span><br></pre></td></tr></table></figure>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h1 id=\"Ubuntu-18-04-开发环境搭建\"><a href=\"#Ubuntu-18-04-开发环境搭建\" class=\"headerlink\" title=\"Ubuntu 18.04 开发环境搭建\"></a>Ubuntu 18.04 开发环境搭建</h1><h2 id=\"一-安装JDK\"><a href=\"#一-安装JDK\" class=\"headerlink\" title=\"一. 安装JDK\"></a>一. 安装JDK</h2><ol>\n<li>官网下载jdk-8u191-linux-x64.tar.gz</li>\n<li>解压</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf jdk-8u191-linux-x64.tar.gz </span><br><span class=\"line\">sudo mv jdk1.8.0_191 /usr/local/java</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>配置环境变量</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191</span><br><span class=\"line\">export CLASSPATH=.:$JAVA_HOME/lib</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin' &gt;&gt; ~/.profile</span><br><span class=\"line\">source ~/.profile</span><br><span class=\"line\"></span><br><span class=\"line\">java -version正确输出即配置完成</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二-安装Toolbox\"><a href=\"#二-安装Toolbox\" class=\"headerlink\" title=\"二. 安装Toolbox\"></a>二. 安装Toolbox</h2><h2 id=\"三-安装npm，nodejs\"><a href=\"#三-安装npm，nodejs\" class=\"headerlink\" title=\"三. 安装npm，nodejs\"></a>三. 安装npm，nodejs</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y nodejs</span><br><span class=\"line\">sudo apt install -y npm</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四-安装vscode\"><a href=\"#四-安装vscode\" class=\"headerlink\" title=\"四. 安装vscode\"></a>四. 安装vscode</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo snap install vscode --classic</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五-安装ss-qt5\"><a href=\"#五-安装ss-qt5\" class=\"headerlink\" title=\"五. 安装ss-qt5\"></a>五. 安装ss-qt5</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt install -y shadowsocks-qt5</span><br><span class=\"line\">hzwhuang-ubuntu-ss-qt5-bionic.list 将里面的bionic 改成xenial</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六-安装Typora\"><a href=\"#六-安装Typora\" class=\"headerlink\" title=\"六. 安装Typora\"></a>六. 安装Typora</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\"><span class=\"meta\">#</span> add Typora's repository</span><br><span class=\"line\">sudo add-apt-repository 'deb https://typora.io/linux ./'</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"><span class=\"meta\">#</span> install typora</span><br><span class=\"line\">sudo apt-get install -y typora</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七-安装Tomcat\"><a href=\"#七-安装Tomcat\" class=\"headerlink\" title=\"七. 安装Tomcat\"></a>七. 安装Tomcat</h2><ol>\n<li>官网下载压缩包</li>\n<li>解压到/usr/local/目录</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar zxvf apache-tomcat-9.0.13</span><br><span class=\"line\">sudo mv apache-tomcat-9.0.13 /usr/local/</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>修改startup.sh，添加CATALINA_HOME=/usr/local/apache-tomcat-9.0.13</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/startup.sh</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>在bin目录下建立setenv.sh脚本，添加JAVA_HOME=/usr/local/java/jdk1.8.0_191</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">touch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br><span class=\"line\">echo JAVA_HOME=/usr/local/java/jdk1.8.0_191 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>运行</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/apache-tomcat-9.0.12/bin/startup.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"八-安装mysql\"><a href=\"#八-安装mysql\" class=\"headerlink\" title=\"八. 安装mysql\"></a>八. 安装mysql</h2><ol>\n<li>官网下载<code>mysql-apt-config_0.8.11-1_all.deb</code></li>\n<li>mysql安装设置</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>安装mysql</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install -y mysql-server</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>mysql服务启动/停止</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service mysql start</span><br><span class=\"line\">service mysql stop</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>开启mysql远程连接</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br><span class=\"line\">use mysql;</span><br><span class=\"line\">update user set host='%' where user='root';</span><br><span class=\"line\">flush privileges;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九-安装git\"><a href=\"#九-安装git\" class=\"headerlink\" title=\"九. 安装git\"></a>九. 安装git</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"美化\"><a href=\"#美化\" class=\"headerlink\" title=\"美化\"></a>美化</h1><h2 id=\"一-gnome\"><a href=\"#一-gnome\" class=\"headerlink\" title=\"一. gnome\"></a>一. gnome</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y gnome-tweak-tool</span><br><span class=\"line\">sudo apt install -y gnome-shell-extensions</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二-dash-to-dock\"><a href=\"#二-dash-to-dock\" class=\"headerlink\" title=\"二. dash to dock\"></a>二. dash to dock</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y gnome-shell-extension-dashtodock</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三-dash-to-panel\"><a href=\"#三-dash-to-panel\" class=\"headerlink\" title=\"三. dash to panel\"></a>三. dash to panel</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install -y gnome-shell-extension-dash-to-panel</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四-VLC\"><a href=\"#四-VLC\" class=\"headerlink\" title=\"四. VLC\"></a>四. VLC</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt -y install vlc</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"自动化安装脚本\"><a href=\"#自动化安装脚本\" class=\"headerlink\" title=\"自动化安装脚本\"></a>自动化安装脚本</h1><blockquote>\n<p>执行脚本前请下载jdk、mysql、tomcat</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\">echo '安装JDK'</span><br><span class=\"line\">cd ~/Downloads</span><br><span class=\"line\">tar zxvf jdk-8u191-linux-x64.tar.gz </span><br><span class=\"line\">sudo mv jdk1.8.0_191 /usr/local/java/ </span><br><span class=\"line\">echo '配置环境变量'</span><br><span class=\"line\">echo 'export JAVA_HOME=/usr/local/java/jdk1.8.0_191</span><br><span class=\"line\">export CLASSPATH=.:$JAVA_HOME/lib</span><br><span class=\"line\">export PATH=$PATH:$JAVA_HOME/bin' &gt;&gt; ~/.profile</span><br><span class=\"line\">echo '安装npm'</span><br><span class=\"line\">sudo apt install -y nodejs</span><br><span class=\"line\">sudo apt install -y npm</span><br><span class=\"line\">echo '安装git'</span><br><span class=\"line\">sudo apt install -y git</span><br><span class=\"line\">echo '安装zsh和oh_my_zsh'</span><br><span class=\"line\">sudo apt install -y zsh</span><br><span class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class=\"line\">sudo chsh -s /bin/zsh</span><br><span class=\"line\">echo '安装vim'</span><br><span class=\"line\">sudo apt install -y vim</span><br><span class=\"line\">echo '安装mysql'</span><br><span class=\"line\">sudo dpkg -i mysql-apt-config_0.8.11-1_all.deb</span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt install -y mysql-server</span><br><span class=\"line\">echo '安装Tomcat'</span><br><span class=\"line\">tar zxvf apache-tomcat-9.0.13.tar.gz</span><br><span class=\"line\">sudo mv apache-tomcat-9.0.13 /usr/local/</span><br><span class=\"line\">echo  CATALINA_HOME=/usr/local/apache-tomcat-9.0.13 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/startup.sh</span><br><span class=\"line\">touch  /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br><span class=\"line\">echo JAVA_HOME=/usr/local/java/jdk1.8.0_191 &gt;&gt; /usr/local/apache-tomcat-9.0.13/bin/setenv.sh</span><br><span class=\"line\">echo '安装gnome'</span><br><span class=\"line\">sudo apt install -y gnome-tweak-tool</span><br><span class=\"line\">sudo apt install -y gnome-shell-extensions</span><br><span class=\"line\">echo '安装dash-to-panel'</span><br><span class=\"line\">sudo apt install -y gnome-shell-extension-dash-to-panel</span><br><span class=\"line\">echo '安装chrome'</span><br><span class=\"line\">sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/</span><br><span class=\"line\">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add -</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install -y google-chrome-stable</span><br><span class=\"line\">echo '安装Typora'</span><br><span class=\"line\">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class=\"line\">sudo add-apt-repository 'deb https://typora.io/linux ./'</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install -y typora</span><br></pre></td></tr></table></figure>"},{"title":"Java学习笔记","date":"2018-12-05T08:18:01.000Z","_content":"\n# 计算机的基础知识\n\n## 1. 计算机概述(了解)\n```java\n(1)计算机\n(2)计算机硬件\n(3)计算机软件\n\t系统软件：window,linux,mac\n\t应用软件：qq,yy,飞秋\n(4)软件开发(理解)\n\t软件：是由数据和指令组成的。(计算器)\n\t开发：就是把软件做出来。\n\t如何实现软件开发呢?\n\t\t就是使用开发工具和计算机语言做出东西来\n(5)语言\n\t自然语言：人与人交流沟通的\n\t计算机语言：人与计算机交流沟通的\n\t\tC,C++,C#,Java\n(6)人机交换\n\t图形界面：操作方便只管\n\tDOS命令：需要记忆一些常见的命令\n```\n## 2. 键盘功能键的认识和快捷键(掌握)\n```java\n(1)功能键的认识\n\ttab\n\tshift\n\tctrl\n\talt\n\twindos\n\t空格\n\t上下左右\n\t回车\n\t截图\n(2)快捷键\n\t全选\tCtrl+A\n\t复制\tCtrl+C\n\t粘贴\tCtrl+V\n\t剪切\tCtrl+X\n\t撤销\tCtrl+Z\n\t保存\tCtrl+S\n```\n\n## 3. 常见的DOS命令(掌握)\n```java\n(1)常见的如下\n\t盘符的切换\n\t\td:回车\n\t目录的进入\n\t\tcd javase\n\t\tcd javase\\day01\\code\n\t目录的回退\n\t\tcd..\n\t\tcd\\\n\t清屏\n\t\tcls\n\t退出\n\t\texit\n(2)其他的几个(了解)\n\t创建目录\n\t\tmkdir\n\t删除目录\n\t\trmdir\n\t创建文件\n\t\tedit\n\t删除文件\n\t\tdel\n\t显示目录下的内容\n\t\tdir\n\t删除带内容的目录\n\t\trd /s/q\n```\n## 4. Java语言概述(了解)\n```java\n(1)Java语言的发展史\n\tJava之父\n\tJDK1.4.2\n\tJDK5\n\tJDK7\n(2)Java语言的特点\n\t有很多小特点，重点有两个开源，跨平台\n(3)Java语言是跨平台的，请问是如何保证的呢?(理解)\n\t我们是通过翻译的案例讲解的。\n\t\n\t针对不同的操作系统，提供不同的jvm来实现的。\n(4)Java语言的平台\n\tJavaSE\n\tJavaME--Android\n\tJavaEE\n```\n## 5. JDK,JRE,JVM的作用及关系(掌握)\n```java\n(1)作用\n\tJVM：保证Java语言跨平台\n\tJRE：Java程序的运行环境\n\tJDK：Java程序的开发环境\n(2)关系\n\tJDK：JRE+工具\n\tJRE：JVM+类库\n```\n## 6. JDK的下载,安装,卸载(掌握)\n```java\n(1)下载到官网。\n\tA:也可以到百度搜索即可。\n\tB:我给你。\n(2)安装\n\tA:绿色版\t解压就可以使用\n\tB:安装版\t必须一步一步的安装，一般只要会点击下一步即可\n\t\n\t注意：\n\t\t建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。\n(3)卸载\n\tA:绿色版\t直接删除文件夹\n\tB:安装版\t\n\t\ta:控制面板 -- 添加删除程序\n\t\tb:通过专业的软件卸载工具。(比如360的软件管家卸载)\n```\n## 7. 第一个程序：HelloWorld案例(掌握)\n```java\nclass HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"HelloWorld\");\n\t}\n}\n\n(1)程序解释：\n\tA:Java程序的最基本单位是类，所以我们要定义一个类。\n\t\t格式：class 类名\n\t\t举例：class HelloWorld\n\tB:在类中写内容的时候，用大括号括起来。\n\tC:Java程序要想执行，必须有main方法。\n\t\t格式：public static void main(String[] args)\n\tD:要指向哪些东西呢，也用大括号括起来。\n\tE:你要做什么呢?今天我们仅仅做了一个简单的输出\n\t\t格式：System.out.println(\"HelloWorld\");\n\t\t注意：\"\"里面的内容是可以改动的。\n\n(2)Java程序的开发执行流程：\n\tA:编写java源程序(.java)\n\tB:通过javac命令编译生成.class文件\n\tC:通过java命令运行.class文件\n```\n## 8. 常见的问题(掌握)\n```java\n(1)扩展名被隐藏\n\t如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾\n(2)我要求文件名称和类名一致。\n\t实际上不这样做也是可以的。\n\t但是，注意：\n\t\tjavac后面跟的是文件名+扩展名\n\t\tjava后面跟的类名不带扩展名\n(3)Java语言严格区分大小写，请注意。\n\t 还有就是单词不要写错了。\n(4)见到非法字符: \\65307肯定是中文问题。\n\t我们写程序要求标点符号必须全部是英文状态。\n(5)括号的配对问题。\n\t一般来说，括号都是成对出现的。\n(6)遇到\n\t在类 HelloWorld 中找不到主方法, 请将主方法定义为\n\tpublic static void main(String[] args)\n\t肯定是主方法的格式问题。\n```\n## 9. path环境变量(掌握)\n```java\n(1)path环境变量的作用\n\t保证javac命令可以在任意目录下运行。\n\t同理可以配置qq等\n(2)path配置的两种方案：\n\tA:方案1(了解)\n\tB:方案2\n\t\t找到环境变量的位置，在系统变量里面\n\t\t新建：\n\t\t\t变量名：JAVA_HOME\n\t\t\t变量值：D:\\develop\\Java\\jdk1.7.0_60\n\t\t修改：\n\t\t\t变量名：Path\n\t\t\t变量值：%JAVA_HOME%\\bin;以前的内容\n```\n## 10. classpath环境变量(理解)\n```java\n(1)classpath环境变量的作用\n\t保证class文件可以在任意目录下运行\n(2)classpath环境变量的配置\n\t找到环境变量的位置，在系统变量里面\n\t新建：\n\t\t变量名：classpath\n\t\t变量值：E:\\JavaSE\\day01\\code\\HelloWorld案例\n```\n# Java语言基础\n\n## 1. 关键字(掌握)\n```java\n(1)被Java语言赋予特定含义的单词\n(2)特点：\n\t全部小写。\n(3)注意事项：\n\tA:goto和const作为保留字存在。\n\tB:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记\n```\n## 2. 标识符(掌握)\n```java\n(1)就是给类，接口，方法，变量等起名字的字符序列\n(2)组成规则：\n\tA:英文大小写字母\n\tB:数字\n\tC:$和_\n(3)注意事项：\n\tA:不能以数字开头\n\tB:不能是java中的关键字\n\tC:区分大小写\n(4)常见的命名规则(见名知意)\n\tA:包\t全部小写\n\t\t单级包：小写\n\t\t\t举例：liuyi,com\n\t\t多级包：小写，并用.隔开\n\t\t\t举例：cn.itcast,com.baidu\t\t\t\t\n\tB:类或者接口\n\t\t一个单词：首字母大写\n\t\t\t举例：Student,Demo\n\t\t多个单词：每个单词首字母大写\n\t\t\t举例：HelloWorld,StudentName\n\tC:方法或者变量\n\t\t一个单词：首字母小写\n\t\t\t举例：name,main\n\t\t多个单词：从第二个单词开始，每个单词首字母大写\n\t\t\t举例：studentAge,showAllNames()\n\tD:常量\n\t\t全部大写\n\t\t一个单词：大写\n\t\t\t举例：PI\n\t\t多个单词：大写，并用_隔开\n\t\t\t举例：STUDENT_MAX_AGE\n```\n## 3. 注释(掌握)\n```java\n(1)就是对程序进行解释说明的文字\n(2)分类：\n\tA:单行注释\t//\n\tB:多行注释\t/**/\n\tC:文档注释(后面讲) /** */\n(3)把HelloWorld案例写了一个带注释的版本。\n\t后面我们要写一个程序的过程。\n\t需求：\n\t分析：\n\t实现：\n\t代码体现：\n(4)注释的作用\n\tA:解释说明程序，提高了代码的阅读性。\n\tB:可以帮助我们调试程序。\n\t\t后面我们会讲解一个更高端的一个调试工具\n```\n\n## 4. 常量(掌握)\n```java\n(1)在程序执行的过程中，其值不发生改变的量\n(2)分类：\n\tA:字面值常量\n\tB:自定义常量(后面讲)\n(3)字面值常量\n\tA:字符串常量 \"hello\"\n\tB:整数常量\t12,23\n\tC:小数常量\t12.345\n\tD:字符常量\t'a','A','0'\n\tE:布尔常量\ttrue,false\n\tF:空常量\tnull(后面讲)\n(4)在Java中针对整数常量提供了四种表现形式\n\tA:二进制\t由0，1组成。以0b开头。\n\tB:八进制\t由0，1，...7组成。以0开头。\n\tC:十进制\t由0，1，...9组成。整数默认是十进制。\n\tD:十六进制\t由0，1，...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。\n```\n## 5. 进制转换(了解)\n```java\n(1)其他进制到十进制\n\t系数：就是每一个位上的数值\n\t基数：x进制的基数就是x\n\t权：对每一个位上的数据，从右，并且从0开始编号，对应的编号就是该数据的权。\n\t\n\t结果：系数*基数^权次幂之和。\n(2)十进制到其他进制\n\t除基取余，直到商为0，余数反转。\n(3)进制转换的快速转换法\n\tA:十进制和二进制间的转换\n\t\t8421码。\n\tB:二进制到八进制，十六进制的转换\n```\n## 6. 变量(掌握)\n```java\n(1)在程序的执行过程中，其值在某个范围内可以发生改变的量\n(2)变量的定义格式：\n\tA:数据类型 变量名 = 初始化值;\n\tB:数据类型 变量名;\n\t  变量名 = 初始化值;\n```\n## 7. 数据类型(掌握)\n\n\t(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。\n\t(2)分类：\n\t\tA:基本数据类型：4类8种\n\t\tB:引用数据类型：类，接口，数组。\n\t(3)基本数据类型\n\t\tA:整数\t\t\t占用字节数\n\t\t\tbyte\t\t\t1\n\t\t\tshort\t\t\t2\n\t\t\tint \t\t\t4\n\t\t\tlong\t\t\t8\n\t\tB:浮点数\n\t\t\tfloat\t\t\t4\n\t\t\tdouble\t\t\t8\n\t\tC:字符\n\t\t\tchar\t\t\t2\n\t\tD:布尔\n\t\t\tboolean\t\t\t1\n\t\t\t\n\t\t注意：\n\t\t\t整数默认是int类型，浮点数默认是double。\n\t\t\t\n\t\t\t长整数要加L或者l。\n\t\t\t单精度的浮点数要加F或者f。\n\n\n## 8. 数据类型转换(掌握)\n\n\t(1)boolean类型不参与转换\n\t(2)默认转换\n\t\tA:从小到大\n\t\tB:byte,short,char -- int -- long -- float -- double\n\t\tC:byte,short,char之间不相互转换，直接转成int类型参与运算。\n\t(3)强制转换\n\t\tA:从大到小\n\t\tB:可能会有精度的损失，一般不建议这样使用。\n\t\tC:格式：\n\t\t\t目标数据类型 变量名 = (目标数据类型) (被转换的数据);\n\t(4)思考题和面试题：\n\t\tA:下面两种方式有区别吗?\n\t\t\t\n\t\t\tfloat f1 = 12.345f;//本来就是float\n\t\t\tfloat f2 = (float)12.345;//double转float\n\t\n\t\tB:下面的程序有问题吗，如果有，在哪里呢?\n\t\t\t\n\t\t\tbyte b1 = 3;\n\t\t\tbyte b2 = 4;\n\t\t\tbyte b3 = b1 + b2;//b1+b2是int,需要强转(byte)(b1 + b2)\n\t\t\tbyte b4 = 3 + 4;//会先判断3+4的值是否在byte区间内,区间内就没问题\n\t\n\t\tC:下面的操作结果是什么呢?\n\t\t\tbyte b = (byte)130;//-126\n\t\t\t\n\t\tD:字符参与运算\n\t\t\t是查找ASCII里面的值\n\t\t\t'a'\t\t97\n\t\t\t'A'\t\t65\n\t\t\t'0'\t\t48\n\t\n\t\t\tSystem.out.println('a');//a\n\t\t\tSystem.out.println('a' + 1);//98\n\t\n\t\tE:字符串参与运算\n\t\t\t这里其实是字符串的连接\t\t\n\t\n\t\t\tSystem.out.println(\"hello\"+'a'+1);//helloa1\n\t\t\tSystem.out.println('a'+1+\"hello\");//98hello\n\t\t\tSystem.out.println(\"5+5=\"+5+5);//5+5=55\n\t\t\tSystem.out.println(5+5+\"=5+5\");//10=5+5\n\n## 1. 运算符(掌握)\n\n\t(1)算术运算符\n\t\tA:+,-,*,/,%,++,--\n\t\tB:+的用法\n\t\t\ta:加法\n\t\t\tb:正号\n\t\t\tc:字符串连接符\n\t\tC:/和%的区别\n\t\t\t数据做除法操作的时候，/取得是商，%取得是余数\n\t\tD:++和--的用法\n\t\t\ta:他们的作用是自增或者自减\n\t\t\tb:使用\n\t\t\t\t**单独使用\n\t\t\t\t\t放在操作数据的前面和后面效果一样。\n\t\t\t\t\ta++或者++a效果一样。\n\t\t\t\t**参与操作使用\n\t\t\t\t\t放在操作数的前面：先自增或者自减，再参与操作\n\t\t\t\t\t\tint a = 10;\n\t\t\t\t\t\tint b = ++a;\n\t\t\t\t\t放在操作数的后面：先参与操作，再自增或者自减\n\t\t\t\t\t\tint a = 10;\n\t\t\t\t\t\tint b = a++;\n\t(2)赋值运算符\n\t\tA:=,+=,-=,*=,/=,%=等\n\t\tB:=叫做赋值运算符，也是最基本的赋值运算符\n\t\t\tint x = 10; 把10赋值给int类型的变量x。\n\t\tC:扩展的赋值运算符的特点\n\t\t\t隐含了自动强制转换。\n\t\t\t\n\t面试题：\n\t\n\tshort s = 1;\n\ts = s + 1;//有问题,需要强转(short)(s + 1)\n\t\n\tshort s = 1;\n\ts += 1;//没问题,隐含了自动强制转换\n\t\n\t请问上面的代码哪个有问题?\n\t\n\t(3)比较运算符\n\t\tA:==,!=,>,>=,<,<=\n\t\tB:无论运算符两端简单还是复杂最终结果是boolean类型。\n\t\tC:千万不要把==写成了=\n\t(4)逻辑运算符\n\t\tA:&,|,^,!,&&,||\n\t\tB:逻辑运算符用于连接boolean类型的式子\n\t\tC:结论\n\t\t\t&:有false则false\n\t\t\t|:有true则true\n\t\t\t^:相同则false，不同则true。\n\t\t\t\t情侣关系。\n\t\t\t!:非true则false，非false则true\n\t\t\t\n\t\t\t&&:结果和&是一样的，只不过有短路效果。左边是false，右边不执行。\n\t\t\t||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。\n\t(5)位运算符(了解)\n\t\tA:^的特殊用法\n\t\t\t一个数据针对另一个数据位异或两次，该数不变\n\t\tB:面试题\n\t\t\ta:请实现两个变量的交换\n\t\t\t\t**采用第三方变量\n\t\t\t\t**用位异或运算符\n\t\t\t\t\t左边a,b,a\n\t\t\t\t\t右边a^b\n\t\t\tb:请用最有效率的方式计算出2乘以8的结果\n\t\t\t\t2<<3\n\t(6)三元运算符\n\t\tA:格式\n\t\t\t比较表达式?表达式1:表达式2;\n\t\tB:执行流程：\n\t\t\t首先计算比较表达式的值，看是true还是false。\n\t\t\t如果是true，表达式1就是结果。\n\t\t\t如果是false，表达式2就是结果。\n\t\tC:案例：\n\t\t\ta:比较两个数据是否相等\n\t\t\t\tSystem.out.println(a == b ? true : false);\n\t\t\tb:获取两个数据中的最大值\n\t\t\t\tSystem.out.println(a > b ? a : b);\n\t\t\tc:获取三个数据中的最大值\n\t\t\t\tSystem.out.println((a>b?a:b)>c?(a>b?a:b):c);\n## 2. 键盘录入(掌握)\n\n\t(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。\n\t(2)如何实现呢?目前就记住\n\t\tA:导包\n\t\t\timport java.util.Scanner;\n\t\t\t位置：在class的上边\n\t\tB:创建对象\n\t\t\tScanner sc = new Scanner(System.in);\n\t\tC:获取数据\n\t\t\tint x = sc.nextInt();\n\t(3)把三元运算符的案例加入键盘录入改进。\n\t\tScanner sc = new Scanner(System.in);\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    System.out.println(a > b ? a : b);\n\n## 3. 流程控制语句\n\n\t(1)顺序结构 从上往下，依次执行\n\t(2)选择结构\t按照不同的选择，执行不同的代码\n\t(3)循环结构 做一些重复的代码\n\n\n## 4. if语句(掌握)\n\n\t(1)三种格式\n\t\tA:格式1\n\t\t\tif(比较表达式) {\n\t\t\t\t语句体;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\t判断比较表达式的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体\n\t\t\t\t如果是false，就不执行语句体\n\t\t\n\t\tB:格式2\n\t\t\tif(比较表达式) {\n\t\t\t\t语句体1;\n\t\t\t}else {\n\t\t\t\t语句体2;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\t判断比较表达式的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体1\n\t\t\t\t如果是false，就执行语句体2\n\t\t\t\t\n\t\tC:格式3\n\t\t\tif(比较表达式1) {\n\t\t\t\t语句体1;\n\t\t\t}else if(比较表达式2){\n\t\t\t\t语句体2;\n\t\t\t}\n\t\t\t...\n\t\t\telse {\n\t\t\t\t语句体n+1;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\t判断比较表达式1的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体1\n\t\t\t\t如果是false，就继续判断比较表达式2的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体2\n\t\t\t\t如果是false，就继续判断比较表达式3的值，看是true还是false\n\t\t\t\t...\n\t\t\t\t如果都不满足，就执行语句体n+1\n\t(2)注意事项\n\t\tA:比较表达式无论简单还是复杂，结果是boolean类型\n\t\tB:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。\n\t\t\t建议：永远不要省略。\n\t\tC:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。\n\t\tD:else后面如果没有if，是不会出现比较表达式的。\n\t\tE:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。\n\t(3)案例：\n\t\tA:比较两个数是否相等\n\t\t\t\n\t\t\tif (a == b) {\n\t\t\t    System.out.println(\"a == b\");\n\t\t    }\n\t\n\t\tB:获取两个数中的最大值\n\t\t\t\n\t\t\tif (a > b) {\n\t            System.out.println(a);\n\t\t    } else if (a < b) {\n\t\t        System.out.println(b);\n\t\t    }\n\t\n\t\tC:获取三个数中的最大值(if语句的嵌套)\n\t\t\tif (a > b) {\n\t            if (a > c) {\n\t                System.out.println(a);\n\t            } else if (c > a) {\n\t                System.out.println(c);\n\t            } else if (b > a) {\n\t\t            if (b > c) {\n\t\t                System.out.println(b);\n\t\t            } else if (c > b) {\n\t\t                System.out.println(c);\n\t\t            }\n\t\t        }\n\t\n\t\tD:根据成绩输出对应的等级\n\t\t\tif (score > 0 && score < 60) {\n\t            System.out.println(\"不及格\");\n\t        } else if (score >= 60 && score < 90) {\n\t            System.out.println(\"合格\");\n\t        } else if (score >= 90 && score <= 100) {\n\t            System.out.println(\"优秀\");\n\t        }\n\t\tE:根据月份，输出对应的季节\n\t\tF:根据x计算对应y的值并输出\n\t(4)三元运算符和if语句第二种格式的关系\n\t\t所有的三元运算符能够实现的，if语句的第二种格式都能实现。\n\t\t反之不成立。\n\t\t\n\t\t如果if语句第二种格式控制的语句体是输出语句，就不可以。\n\t\t因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。\n\n## 1. switch语句(掌握)\n\n\t(1)格式：\n\t\tswitch(表达式) {\n\t\t\tcase 值1:\n\t\t\t\t语句体1;\n\t\t\t\tbreak;\n\t\t\tcase 值2:\n\t\t\t\t语句体2;\n\t\t\t\tbreak;\n\t\t\t...\n\t\t\tdefault:\n\t\t\t\t语句体n+1;\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t格式解释说明：\n\t\t\tswitch:说明这是switch语句。\n\t\t\t表达式:可以是byte,short,int,char\n\t\t\t\tJDK5以后可以是枚举\n\t\t\t\tJDK7以后可以是字符串\n\t\t\tcase:后面的值就是要和表达式进行比较的值\n\t\t\tbreak:表示程序到这里中断，跳出switch语句\n\t\t\tdefault:如果所有的情况都不匹配,就执行这里,相当于if语句中的else\n\t(2)面试题\n\t\tswitch语句的表达式可以是byte吗?可以是long吗?可以是String吗?\n\t\t\t可以,不可以,JDK7以后可以\n\t(3)执行流程:\n\t\tA:首先计算表达式的值\n\t\tB:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。\n\t\tC:如果没有匹配，就执行default的语句体n+1。\n\t(4)注意事项:\n\t\tA:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的\n\t\tB:default可以省略吗?\n\t\t\t可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。\n\t\t\t特殊情况：\n\t\t\t\tcase就可以把值固定。\n\t\t\t\tA,B,C,D\n\t\tC:break可以省略吗?\n\t\t\t可以省略，但是结果可能不是我们想要的。\n\t\t\t会出现一个现象：case穿透。\n\t\t\t最终我们建议不要省略\n\t\tD:default一定要在最后吗?\n\t\t\t不是，可以在任意位置。但是建议在最后。\n\t\tE:switch语句的结束条件\n\t\t\ta:遇到break就结束了\n\t\t\tb:执行到末尾就结束了\n\t(5)案例：\n\t\tA:键盘录入一个数字(1-7),输出对应的星期几。\n\t\t\tScanner sc = new Scanner(System.in);\n\t\n\t\t        switch (sc.nextInt()) {\n\t            case ## 1. \n\t                System.out.println(\"Monday\");\n\t                break;\n\t            case ## 2. \n\t                System.out.println(\"Tuesday\");\n\t                break;\n\t            case ## 3. \n\t                System.out.println(\"Wednesday\");\n\t                break;\n\t            case ## 4. \n\t                System.out.println(\"Thursday\");\n\t                break;\n\t            case ## 5. \n\t                System.out.println(\"Friday\");\n\t                break;\n\t            case ## 6. \n\t                System.out.println(\"Saturday\");\n\t                break;\n\t            case ## 7. \n\t                System.out.println(\"Sunday\");\n\t                break;\n\t            default:\n\t                System.out.println(\"wrong\");\n\t        }\n\t\tB:单项选择题\n\t\tC:键盘录入一个字符串的问题\n\t\t\tString s = sc.nextLine();\n\t\tD:根据给定的月份,输出对应的季节\n\t(6)if语句和switch语句各自的场景\n\t\tA:if\n\t\t\t针对boolean类型的判断\n\t\t\t针对一个范围的判断\n\t\t\t针对几个常量的判断\n\t\tB:switch\n\t\t\t针对几个常量的判断\n\n\n## 2. 循环语句(掌握)\n\n\t(1)有三种:for,while,do...while\n\t(2)for循环语句\n\t\tA:格式\n\t\t\tfor(初始化语句;判断条件语句;控制条件语句){\n\t\t\t\t循环体语句;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\ta:执行初始化语句\n\t\t\t\tb:执行判断条件语句\n\t\t\t\t\t如果这里是true，就继续\n\t\t\t\t\t如果这里是false，循环就结束\n\t\t\t\tc:执行循环体语句\n\t\t\t\td:执行控制条件语句\n\t\t\t\te:回到b\n\t\tB:注意事项\n\t\t\ta:判断条件语句无论简单还是复杂，结果是boolean类型\n\t\t\tb:循环体语句如果是一条，可以省略大括号，但是不建议\n\t\t\tc:有分号就没有左大括号，有左大括号就没有分号\n\t\tC:案例\n\t\t\ta:输出10次HelloWorld\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t            System.out.println(\"HelloWorld\");\n\t\t        }\n\t\t\tb:输出1-10的数据\n\t\t\t\tfor (int i = 1; i < 11; i++) {\n\t\t            System.out.println(i);\n\t\t        }\n\t\t\tc:输出10-1的数据\n\t\t\t\tfor (int i = 10; i > 0; i--) {\n\t\t            System.out.println(i);\n\t\t        }\n\t\t\td:求1-10的和\n\t\t\t\tint sum = 0;\n\t\t        for (int i = 1; i < 11; i++) {\n\t\t            sum += i;\n\t\t        }\n\t\t        System.out.println(sum);\n\t\t\te:求1-100的和,求1-100的偶数和,求1-100的奇数和\n\t\t\t\tint sum = 0;\n\t\t        int oddSum = 0;\n\t\t        int evenSum = 0;\n\t\t\n\t\t        for (int i = 1; i < 101; i++) {\n\t\t            sum += i;\n\t\t        }\n\t\t        System.out.println(\"sum:\" + sum);\n\t\t\n\t\t        for (int i = 1; i < 101; i+=2) {\n\t\t            oddSum += i;\n\t\t        }\n\t\t        System.out.println(\"oddSum:\" + oddSum);\n\t\t\n\t\t        for (int i = 2; i < 101; i+=2) {\n\t\t            evenSum += i;\n\t\t        }\n\t\t        System.out.println(\"evenSum:\" + evenSum);\n\t\t\tf:求5的阶乘\n\t\t\t\tint sum = 1;\n\t\t        for (int i = 5; i > 0; i--) {\n\t\t            sum *= i;\n\t\t        }\n\t\t        System.out.println(sum);\n\t\t\tg:在控制台打印水仙花数(个位,十位,百位的立方和等于该数)\n\t\t\t\tfor (int i = 100; i < 1000; i++) {\n\t\t            int ge = i % 10;\n\t\t            int shi = i / 10 % 10;\n\t\t            int bai = i / 100 % 10;\t\t\n\t\t            if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n\t\t                System.out.println(i);\n\t\t            }\n\t\t        }\n\t\t\th:统计水仙花个数\n\t\t\t\tint flag = 0;\n\t\t        for (int i = 100; i < 1000; i++) {\n\t\t            int ge = i % 10;\n\t\t            int shi = i / 10 % 10;\n\t\t            int bai = i / 100 % 10;\n\t\t            if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n\t\t                flag++;\n\t\t            }\n\t\t        }\n\t\t        System.out.println(flag);\n\t\t\ti:改进版的回文数\n\t\t\t\t一个五位数\n\t\t\t\t个位 = 万位\n\t\t\t\t十位 = 千位\n\t\t\t\t个位 + 十位 + 千位 + 万位 = 百位\n\t\t\t\tfor (int i = 10000; i < 100000; i++) {\n\t\t            int ge = i % 10;\n\t\t            int shi = i / 10 %10;\n\t\t            int bai = i / 100 % 10;\n\t\t            int qian = i /1000 % 10;\n\t\t            int wan = i / 10000 % 10;\n\t\t            if (ge == wan && shi == qian && (ge + shi + qian + wan) == bai) {\n\t\t                System.out.println(i);\n\t\t            }\n\t\t        }\n\t\t\tj:统计1-1000之间同时满足如下条件的数据有多少个\n\t\t\t\tx%3==2\n\t\t\t\tx%5==3\n\t\t\t\tx%7==2\n\t\t\t\tint flag = 0;\n\t\t        for (int i = 1; i < 1001; i++) {\n\t\t            if (i % 3 == 2 && i % 5 == 3 && i % 7 == 2) {\n\t\t                flag++;\n\t\t            }\n\t\t        }\n\t\t        System.out.println(flag);\n\t(3)while循环\n\t\tA:基本格式\n\t\t\twhile(判断条件语句) {\n\t\t\t\t循环体语句;\n\t\t\t}\n\t\t\t\n\t\t\t扩展格式：\n\t\t\t初始化语句;\n\t\t\twhile(判断条件语句){\n\t\t\t\t循环体语句;\n\t\t\t\t控制条件语句;\n\t\t\t}\n\t\t\t\n\t\t\t通过查看这个格式，我们就知道while循环可以和for循环等价转换。\n\t\tB:while的练习\n\t\t\t把for语句的练习用while改进\n\t\tC:for和while的区别\n\t\t\ta:使用上的区别\n\t\t\t\tfor语句的那个控制条件变量,在循环结束后不能在使用了。\n\t\t\t\t而while的可以继续使用。\n\t\t\tb:理解上的区别\n\t\t\t\tfor适合于一个范围的判断\n\t\t\t\twhile适合次数不明确的\n\t\t\t\t\t举例:吃葡萄\n\t\tD:案例：\n\t\t\ta:珠穆朗玛峰问题\n\t\t\tb:小芳存钱问题(break以后才能做)\n\t(4)do...while循环\n\t\tA:基本格式\n\t\t\tdo {\n\t\t\t\t循环体语句;\n\t\t\t}while(判断条件语句);\n\t\t\t\n\t\t\t扩展格式：\n\t\t\t初始化语句;\n\t\t\tdo {\n\t\t\t\t循环体语句;\n\t\t\t\t控制条件语句;\n\t\t\t}while(判断条件语句);\n\t\t\t\n\t\t\t通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。\n\t\tB:三种循环的区别\n\t\t\ta:do...while循环至少执行一次循环体\n\t\t\tb:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体\n\t(5)循环使用的注意事项(死循环)\n\t\tA:一定要注意修改控制条件,否则容易出现死循环。\n\t\tB:最简单的死循环格式\n\t\t\ta:while(true){...}\n\t\t\t\n\t\t\tb:for(;;){}\n\n## 3. 控制跳转语句(掌握)\n\n\t(1)break:中断的意思\n\t\tA:用在循环和switch语句中，离开此应用场景无意义。\n\t\tB:作用\n\t\t\ta:跳出单层循环\n\t\t\tb:跳出多层循环，需要标签语句的配合\n\t(2)continue:继续\n\t\tA:用在循环中，离开此应用场景无意义。\n\t\tB:作用\n\t\t\ta:跳出单层循环的一次，可以继续下一次\n\t\tC:填空题\n\t\t\tfor(int x=1; x<=10; x++) {\n\t\t\t\tif(x%3 == 0) {\n\t\t\t\t\t//补齐代码\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"Java基础班\");\n\t\t\t}\n\t\t\t如何让控制台输出2次：Java基础班\n\t\t\t\tbreak;\n\t\t\t如何让控制台输出7次：Java基础班\n\t\t\t\tcontinue;\n\t\t\t如何让控制台输出13次：Java基础班\n\t\t\t\tSystem.out.println(\"Java基础班\");\n\t(3)return:返回\n\t\tA:用于结束方法的，后面还会在继续讲解和使用。\n\t\tB:一旦遇到return,程序就不会在继续往后执行。\n\n\n\n## 1. 方法(掌握)\n\n\t(1)方法：就是完成特定功能的代码块。\n\t\t注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。\n\t(2)格式：\n\t\t修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {\n\t\t\t方法体语句;\n\t\t\treturn 返回值;\n\t\t}\n\n\n\t\t修饰符：目前就用 public static。后面再详细讲解其他修饰符\n\t\t返回值类型：就是功能结果的数据类型\n\t\t方法名：就是起了一个名字，方便我们调用该方法。\n\t\t参数类型：就是参数的数据类型\n\t\t参数名：就是变量\n\t\t参数分类：\n\t\t\t实参：实际参与运算的数据\n\t\t\t形参：方法上定义的，用于接收实际参数的变量\n\t\t方法体语句：就是完成功能的代码块\n\t\treturn：结束方法\n\t\t返回值：就是功能的结果，由return带给调用者。\n\t(3)两个明确：\n\t\t返回值类型：结果的数据类型\n\t\t参数列表：参数的个数及对应的数据类型\n\t(4)方法调用\n\t\tA:有明确返回值的方法\n\t\t\ta:单独调用，没有意义\n\t\t\tb:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。\n\t\t\tc:赋值调用，推荐方案\n\t\tB:void类型修饰的方法\n\t\t\ta:单独调用\n\t(5)案例：\n\t\tA:求和方案\n\t\t\tpublic static void sum(int a, int b) {\n\t\t        System.out.println(\"a + b = \" + (a + b));\n\t\t    }\n\t\tB:获取两个数中的较大值\n\t\t\tpublic static void max(int a, int b) {\n\t\t        if (a > b) {\n\t\t            System.out.println(a);\n\t\t        } else if (b > a) {\n\t\t            System.out.println(b);\n\t\t        }\n\t\t    }\n\t\tC:比较两个数据是否相同\n\t\t\tpublic static void isEquals(int a, int b) {\n\t\t        if (a == b) {\n\t\t            System.out.println(\"a == b\");\n\t\t        }\n\t\t    }\n\t\tD:获取三个数中的最大值\n\t\t\tpublic static void max(int a, int b, int c) {\n\t\t        if (a > b) {\n\t\t            if (a > c) {\n\t\t                System.out.println(a);\n\t\t            } else if (c > a) {\n\t\t                System.out.println(c);\n\t\t            }\n\t\t        } else if (b > a) {\n\t\t            if (b > c) {\n\t\t                System.out.println(b);\n\t\t            } else if (c > b) {\n\t\t                System.out.println(c);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\tE:输出m行n列的星形\n\t\t\tpublic static void printStar(int row, int column) {\n\t\t        for (int m = 0; m < row; m++) {\n\t\t            String star = \"\";\n\t\t            for (int n = 0; n < column; n++) {\n\t\t                star += \"*\";\n\t\t            }\n\t\t            System.out.println(star);\n\t\t        }\n\t\t        System.out.println(\"--------------\");\n\t\t        for (int m = 0; m < row; m++) {\n\t\t            String star = \"\";\n\t\t            for (int n = 0; n <= m; n++) {\n\t\t                star += \"*\";\n\t\t            }\n\t\t            System.out.println(star);\n\t\t        }\n\t\t        System.out.println(\"---------------\");\n\t\t        for (int m = row; m > 0; m--) {\n\t\t            String star = \"\";\n\t\t            for (int n = 0; n < m; n++) {\n\t\t                star += \"*\";\n\t\t            }\n\t\t            System.out.println(star);\n\t\t        }\n\t\t    }\n\t\tF:输出nn乘法表\n\t\t\tpublic static void chengfabiao(int n) {\n\t\t        for (int i = 1; i <= n; i++) {\n\t\t            for (int j = 1; j <= i; j++) {\n\t\t                System.out.print(j + \" * \" + i + \" = \" + (j * i) + \"\\t\");\n\t\t            }\n\t\t            System.out.println();\n\t\t        }\n\t\t    }\n\t(6)方法的注意事项\n\t\tA:方法不调用不执行\n\t\tB:方法之间是平级关系，不能嵌套定义\n\t\tC:方法定义的时候，参数是用，隔开的\n\t\tD:方法在调用的时候，不用在传递数据类型\n\t\tE:如果方法有明确的返回值类型，就必须有return语句返回。\n\t(7)方法重载\n\t\t在同一个类中，方法名相同，参数列表不同。与返回值无关。\n\t\t\n\t\t参数列表不同：\n\t\t\t参数的个数不同。\n\t\t\t参数的对应的数据类型不同。\n\t(8)方法重载案例\n\t\t不同的类型的多个同名方法的比较。\n\n## 2. 数组(掌握)\n\n\t(1)数组：存储同一种数据类型的多个元素的容器。\n\t(2)特点：每一个元素都有编号，从0开始，最大编号是长度-1。\n\t         编号的专业叫法：索引\n\t(3)定义格式\n\t\tA:数据类型[] 数组名;\n\t\tB:数据类型 数组名[];\n\t\t\n\t\t推荐是用A方式，B方法就忘了吧。\n\t\t但是要能看懂\n\t(4)数组的初始化\n\t\tA:动态初始化\n\t\t\t只给长度，系统给出默认值\n\t\t\t\n\t\t\t举例：int[] arr = new int[3];\n\t\tB:静态初始化\n\t\t\t给出值，系统决定长度\n\t\t\t\n\t\t\t举例：int[] arr = new int[]{1,2,3};\n\t\t\t简化版：int[] arr = {1,2,3};\n\t(5)Java的内存分配\n\t\tA:栈 存储局部变量\n\t\tB:堆 存储所有new出来的\n\t\tC:方法区(面向对象部分详细讲解)\n\t\tD:本地方法区(系统相关)\n\t\tE:寄存器(CPU使用)\n\t\t\n\t\t注意：\n\t\t\ta:局部变量 在方法定义中或者方法声明上定义的变量。\n\t\t\tb:栈内存和堆内存的区别\n\t\t\t\t栈：数据使用完毕，就消失。\n\t\t\t\t堆：每一个new出来的东西都有地址\n\t\t\t\t    每一个变量都有默认值\n\t\t\t\t\t\tbyte,short,int,long 0\n\t\t\t\t\t\tfloat,double 0.0\n\t\t\t\t\t\tchar '\\u0000'\n\t\t\t\t\t\tboolean false\n\t\t\t\t\t\t引用类型 null\n\t\t\t\t    数据使用完毕后，在垃圾回收器空闲的时候回收。\n\t(6)数组内存图\n\t\tA:一个数组\n\t\tB:二个数组\n\t\tC:三个数组(两个栈变量指向同一个堆内存)\n\t(7)数组的常见操作\n\t\tA:遍历\n\t\t\t方式1：\n\t\t\t\tpublic static void printArray(int[] arr) {\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tSystem.out.println(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t方式2：\n\t\t\t\tpublic static void printArray(int[] arr) {\n\t\t\t\t\tSystem.out.print(\"[\");\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tif(x == arr.length-1) {\n\t\t\t\t\t\t\tSystem.out.println(arr[x]+\"]\");\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(arr[x]+\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tB:最值\n\t\t\t最大值：\n\t\t\t\tpublic static int getMax(int[] arr) {\n\t\t\t\t\tint max = arr[0];\n\t\t\t\t\t\n\t\t\t\t\tfor(int x=1; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] > max) {\n\t\t\t\t\t\t\tmax = arr[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn max;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t最小值：\n\t\t\t\tpublic static int getMin(int[] arr) {\n\t\t\t\t\tint min = arr[0];\n\t\t\t\t\t\n\t\t\t\t\tfor(int x=1; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] < min) {\n\t\t\t\t\t\t\tmin = arr[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn min;\n\t\t\t\t}\n\t\tC:逆序\n\t\t\t方式1：\n\t\t\t\tpublic static void reverse(int[] arr) {\n\t\t\t\t\tfor(int x=0; x<arr.length/2; x++) {\n\t\t\t\t\t\tint temp = arr[x];\n\t\t\t\t\t\tarr[x] = arr[arr.length-1-x];\n\t\t\t\t\t\tarr[arr.length-1-x] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t方式2：\n\t\t\t\tpublic static void reverse(int[] arr) {\n\t\t\t\t\tfor(int start=0,end=arr.length-1; start<=end; start++,end--) {\n\t\t\t\t\t\tint temp = arr[start];\n\t\t\t\t\t\tarr[start] = arr[end];\n\t\t\t\t\t\tarr[end] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tD:查表\n\t\t\t\tpublic static String getString(String[] strArray,int index) {\n\t\t\t\t\treturn strArray[index];\n\t\t\t\t}\n\t\tE:基本查找\n\t\t\t方式1：\n\t\t\t\tpublic static int getIndex(int[] arr,int value) {\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] == value) {\n\t\t\t\t\t\t\treturn x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t方式2：\n\t\t\t\tpublic static int getIndex(int[] arr,int value) {\n\t\t\t\t\tint index = -1;\n\t\t\t\t\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] == value) {\n\t\t\t\t\t\t\tindex = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\n\n\n# Java面向对象\n\n## 1. 成员变量和局部变量的区别(理解)\n\n\t(1)在类中的位置不同\n\t\t成员变量：类中方法外\n\t\t局部变量：方法定义中或者方法声明上\n\t(2)在内存中的位置不同\n\t\t成员变量：在堆中\n\t\t局部变量：在栈中\n\t(3)生命周期不同\n\t\t成员变量：随着对象的创建而存在，随着对象的消失而消失\n\t\t局部变量：随着方法的调用而存在，随着方法的调用完毕而消失\n\t(4)初始化值不同\n\t\t成员变量：有默认值\n\t\t局部变量：没有默认值，必须定义，赋值，然后才能使用\n\n## 2. 类作为形式参数的问题?(理解)\n\n\t(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。\n\n\n## 3. 匿名对象(理解)\n\n\t(1)没有名字的对象\n\t(2)应用场景\n\t\tA:调用方法，仅仅只调用一次的时候。\n\t\tb:可以作为实际参数传递。\n\n## 4. 封装(理解)\n\n\t(1)隐藏实现细节，提供公共的访问方式\n\t(2)好处：\n\t\tA:隐藏实现细节，提供公共的访问方式\n\t\tB:提高代码的复用性\n\t\tC:提高代码的安全性\n\t(3)设计原则\n\t\t把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式\n\t(4)private是封装的一种体现。\n\t\t封装：类，方法，private修饰成员变量\n\n\n## 5. private关键字(掌握)\n\n\t(1)私有的意义，可以修饰成员变量和成员方法\n\t(2)特点：\n\t\t被private修饰的后的成员只能在本类中被访问\n\t(3)private的应用：\n\t\t以后再写一个类的时候：\n\t\t\t把所有的成员变量给private了\n\t\t\t提供对应的getXxx()/setXxx()方法\n\n\n## 6. this关键字(掌握)\n\n\t(1)代表当前类的引用对象\n\t\t记住：哪个对象调用方法，该方法内部的this就代表那个对象\n\t(2)this的应用场景：\n\t\tA:解决了局部变量隐藏成员变量的问题\n\t\tB:其实this还有其他的应用，明天讲解。\n\n\n## 7. 构造方法(掌握)\n\n\t(1)作用：用于对对象的数据进行初始化\n\t(2)格式：\n\t\tA:方法名和类名相同\n\t\tB:没有返回值类型，连void都不能有\n\t\tC:没有返回值\n\t\t\n\t\t思考题：构造方法中可不可以有return语句呢?\n\t\t可以。只要我们写成这个样子就OK了：return;\n\t\t其实，在任何的void类型的方法的最后你都可以写上：return;\n\t(3)构造方法的注意事项\n\t\tA:如果我们没写构造方法，系统将提供一个默认的无参构造方法\n\t\tB:如果我们给出了构造方法，系统将不再提供默认构造方法\n\t\t\t如果这个时候，我们要使用无参构造方法，就必须自己给出。\n\t\t\t推荐：永远手动自己给出无参构造方法。\n\t(4)给成员变量赋值的方式\n\t\tA:setXxx()\n\t\tB:带参构造方法\n\t(5)标准案例\n\t\tclass Student {\n\t\t\tprivate String name;\n\t\t\tprivate int age;\n\t\t\t\n\t\t\tpublic Student(){}\n\t\t\t\n\t\t\tpublic Student(String name,int age) {\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.age = age;\n\t\t\t}\n\t\t\t\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t\n\t\t\tpublic void setName(String name) {\n\t\t\t\tthis.name = name;\n\t\t\t}\n\t\t\t\n\t\t\tpublic int getAge() {\n\t\t\t\treturn age;\n\t\t\t}\n\t\t\t\n\t\t\tpublic void setAge(int age) {\n\t\t\t\tthis.age = age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t测试：\n\t\tclass StudentDemo {\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\t//方式1\n\t\t\t\tStudent s1 = new Student();\n\t\t\t\ts1.setName(\"林青霞\");\n\t\t\t\ts1.setAge(27);\n\t\t\t\tSystem.out.println(s1.getName()+\"---\"+s1.getAge());\n\t\t\t\t\n\t\t\t\t//方式2\n\t\t\t\tStudent s2 = new Student(\"刘意\",30);\n\t\t\t\tSystem.out.println(s2.getName()+\"---\"+s2.getAge());\n\t\t\t}\n\t\t}\n\n\n\n## 8. 代码：Student s = new Student();做了哪些事情?(理解)\n\n\t(1)把Student.class文件加载到内存\n\t(2)在栈内存为s开辟空间\n\t(3)在堆内存为学生对象申请空间\n\t(4)给学生的成员变量进行默认初始化。null,0\n\t(5)给学生的成员变量进行显示初始化。林青霞,27\n\t(6)通过构造方法给成员变量进行初始化。刘意,30\n\t(7)对象构造完毕，把地址赋值给s变量\n\n## 9. 面向对象的练习题(掌握)\n\n\t(1)标准的手机类的定义和测试\n\t(2)Demo类有求和方法，Test类进行测试。\n\t\t什么时候定义成员变量?\n\t\t当该变量是用来描述一个类的时候。\n\t(3)长方形案例\n\t(4)员工案例\n\t(5)MyMath案例(自己提供加减乘除并测试)\n\t\tpublic class MyMath {\n\t\t    public MyMath() {\n\t\t    }\n\t\t\n\t\t    public static void add(int a, int b) {\n\t\t        System.out.println(\"add\" + (a + b));\n\t\t    }\n\t\t\n\t\t    public static void subtract(int a, int b) {\n\t\t        System.out.println(\"subtract\" + (a - b));\n\t\t    }\n\t\t\n\t\t    public static void multiply(int a, int b) {\n\t\t        System.out.println(\"multiply\" + (a * b));\n\t\t    }\n\t\t\n\t\t    public static void divide(int a, int b) {\n\t\t        System.out.println(\"divide\" + (a / b));\n\t\t    }\n\t\t}\n\n## 10. static关键字(理解)\n\n\t(1)静态的意思。可以修饰成员变量和成员方法。\n\t(2)静态的特点：\n\t\tA:随着类的加载而加载\n\t\tB:优先于对象存在\n\t\tC:被类的所有对象共享\n\t\t\t这其实也是我们判断该不该使用静态的依据。\n\t\t\t举例：饮水机和水杯的问题思考\n\t\tD:可以通过类名调用\n\t\t\t既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。\n\t(3)静态的内存图\n\t\t静态的内容在方法区的静态区\n\t(4)静态的注意事项；\n\t\tA:在静态方法中没有this对象\n\t\tB:静态只能访问静态(代码测试过)\n\t(5)静态变量和成员变量的区别\n\t\tA:所属不同\n\t\t\t静态变量：属于类，类变量\n\t\t\t成员变量：属于对象，对象变量，实例变量\n\t\tB:内存位置不同\n\t\t\t静态变量：方法区的静态区\n\t\t\t成员变量：堆内存\n\t\tC:生命周期不同\n\t\t\t静态变量：静态变量是随着类的加载而加载，随着类的消失而消失\n\t\t\t成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失\n\t\tD:调用不同\n\t\t\t静态变量：可以通过对象名调用，也可以通过类名调用\n\t\t\t成员变量：只能通过对象名调用\n\t(6)main方法是静态的\n\t\tpublic:权限最大\n\t\tstatic:不用创建对象调用\n\t\tvoid:返回值给jvm没有意义\n\t\tmain:就是一个常见的名称。\n\t\tString[] args:可以接收数据，提供程序的灵活性\n\t\t\t格式：java MainDemo hello world java\n\t\t\t\t  java MainDemo 10 20 30\n\n## 1. 如何制作帮助文档(了解)\n\n\t(1)写一个类\n\t(2)加入文档注释\n\t(3)通过javadoc工具生成即可\n\t\tjavadoc -d 目录 -author -version ArrayTool.java\n\n\n## 2. 通过JDK提供的API学习了Math类(掌握)\n\n\t(1)API(Application Programming Interface)\n\t\t应用程序编程接口(帮助文档)\n\t(2)如何使用呢?\n\t\t请参照\n\t\t\tday08\\code\\02_如何使用JDK提供的帮助文档\\如何使用帮助文档.txt\n\t(3)Math类\n\t\tA:是针对数学进行操作的类\n\t\tB:没有构造方法，因为它的成员都是静态的\n\t\tC:产生随机数\n\t\t\tpublic static double random(): [0.0,1.0)\n\t\tD:如何产生一个1-100之间的随机数\n\t\t\tint number = (int)(Math.random()*100)+1;\n\t\tE:猜数字小游戏\n\n\n## 3. 代码块(理解)\n\n\t(1)用{}括起来的代码。\n\t(2)分类：\n\t\tA:局部代码块\n\t\t\t用于限定变量的生命周期，及早释放，提高内存利用率。\n\t\tB:构造代码块\n\t\t\t把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。\n\t\tC:静态代码块\n\t\t\t对类的数据进行初始化，仅仅只执行一次。\n\t(3)静态代码块,构造代码块,构造方法的顺序问题?\n\t\t静态代码块 > 构造代码块 > 构造方法\n\n## 4. 继承(掌握)\n\n\t(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，\n\t   这多个类就具备了这些内容。这个关系叫继承。\n\t(2)Java中如何表示继承呢?格式是什么呢?\n\t\tA:用关键字extends表示\n\t\tB:格式：\n\t\t\tclass 子类名 extends 父类名 {}\n\t(3)继承的好处：\n\t\tA:提高了代码的复用性\n\t\tB:提高了代码的维护性\n\t\tC:让类与类产生了一个关系，是多态的前提\n\t(4)继承的弊端：\n\t\tA:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。\n\t\t\t原则：低耦合，高内聚。\n\t\t\t耦合：类与类的关系\n\t\t\t内聚：自己完成某件事情的能力\n\t\tB:打破了封装性\n\t(5)Java中继承的特点\n\t\tA:Java中类只支持单继承\n\t\tB:Java中可以多层(重)继承(继承体系)\n\t(6)继承的注意事项：\n\t\tA:子类不能继承父类的私有成员\n\t\tB:子类不能继承父类的构造方法，但是可以通过super去访问\n\t\tC:不要为了部分功能而去继承\n\t(7)什么时候使用继承呢?\n\t\tA:继承体现的是：is a的关系。\n\t\tB:采用假设法\n\t(8)Java继承中的成员关系\n\t\tA:成员变量\n\t\t\ta:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单\n\t\t\tb:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?\n\t\t\t\t子类的方法访问变量的查找顺序：\n\t\t\t\t\t在子类方法的局部范围找，有就使用。\n\t\t\t\t\t在子类的成员范围找，有就使用。\n\t\t\t\t\t在父类的成员范围找，有就使用。\n\t\t\t\t\t找不到，就报错。\n\t\tB:构造方法\n\t\t\ta:子类的构造方法默认会去访问父类的无参构造方法\n\t\t\t\t是为了子类访问父类数据的初始化\n\t\t\tb:父类中如果没有无参构造方法，怎么办?\n\t\t\t\t子类通过super去明确调用带参构造\n\t\t\t\t子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造\n\t\t\t\t让父类提供无参构造\n\t\tC:成员方法\n\t\t\ta:子类的成员方法和父类中的成员方法名称不一样，这个太简单\n\t\t\tb:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?\n\t\t\t\t通过子类对象访问一个方法的查找顺序：\n\t\t\t\t\t在子类中找，有就使用\n\t\t\t\t\t在父类中找，有就使用\n\t\t\t\t\t找不到，就报错\n\t(9)两个面试题：\n\t\tA:Override和Overload的区别?Overload是否可以改变返回值类型?\n\t\tB:this和super的区别和各自的作用?\n\t(10)数据初始化的面试题\n\t\tA:一个类的初始化过程\n\t\tB:子父类的构造执行过程\n\t\tC:分层初始化\n\t(11)案例：\n\t\tA:学生和老师案例\n\t\t\t继承前\n\t\t\t继承后\n\t\tB:猫狗案例的分析和实现\n\n## 1. final关键字(掌握)\n\n\t(1)是最终的意思，可以修饰类，方法，变量。\n\t(2)特点：\n\t\tA:它修饰的类，不能被继承。\n\t\tB:它修饰的方法，不能被重写。\n\t\tC:它修饰的变量，是一个常量。\n\t(3)面试相关：\n\t\tA:局部变量\n\t\t\ta:基本类型 值不能发生改变\n\t\t\tb:引用类型 地址值不能发生改变，但是对象的内容是可以改变的\n\t\tB:初始化时机\n\t\t\ta:只能初始化一次。\n\t\t\tb:常见的给值\n\t\t\t\t定义的时候。(推荐)\n\t\t\t\t构造方法中。\n\n## 2. 多态(掌握)\n\n\t(1)同一个对象在不同时刻体现出来的不同状态。\n\t(2)多态的前提：\n\t\tA:有继承或者实现关系。\n\t\tB:有方法重写。\n\t\tC:有父类或者父接口引用指向子类对象。\n\t\t\n\t\t多态的分类：\n\t\t\ta:具体类多态\n\t\t\t\tclass Fu {}\n\t\t\t\tclass Zi extends Fu {}\n\t\t\t\t\n\t\t\t\tFu f = new Zi();\n\t\t\tb:抽象类多态\n\t\t\t\tabstract class Fu {}\n\t\t\t\tclass Zi extends Fu {}\n\t\t\t\t\n\t\t\t\tFu f = new Zi();\n\t\t\tc:接口多态\n\t\t\t\tinterface Fu {}\n\t\t\t\tclass Zi implements Fu {}\n\t\t\t\t\n\t\t\t\tFu f = new Zi();\n\t(3)多态中的成员访问特点\n\t\tA:成员变量\n\t\t\t编译看左边，运行看左边\n\t\tB:构造方法\n\t\t\t子类的构造都会默认访问父类构造\n\t\tC:成员方法\n\t\t\t编译看左边，运行看右边\n\t\tD:静态方法\n\t\t\t编译看左边，运行看左边\n\t\t\t\n\t\t为什么?\n\t\t\t因为成员方法有重写。\n\t(4)多态的好处：\n\t\tA:提高代码的维护性(继承体现)\n\t\tB:提高代码的扩展性(多态体现)\n\t(5)多态的弊端：\n\t\t父不能使用子的特有功能。\n\t\t\n\t\t现象：\n\t\t\t子可以当作父使用，父不能当作子使用。\n\t(6)多态中的转型\n\t\tA:向上转型\n\t\t\t从子到父\n\t\tB:向下转型\n\t\t\t从父到子\n\t(7)孔子装爹的案例帮助大家理解多态\n\t(8)多态的练习\n\t\tA:猫狗案例\n\t\tB:老师和学生案例\n\n\n## 3. 抽象类(掌握)\n\n\t(1)把多个共性的东西提取到一个类中，这是继承的做法。\n\t   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。\n\t   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。\n\t   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。\n\t   而一个没有具体的方法体的方法是抽象的方法。\n\t   在一个类中如果有抽象方法，该类必须定义为抽象类。\n\t(2)抽象类的特点\n\t\tA:抽象类和抽象方法必须用关键字abstract修饰\n\t\tB:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类\n\t\tC:抽象类不能实例化\n\t\tD:抽象类的子类\n\t\t\ta:是一个抽象类。\n\t\t\tb:是一个具体类。这个类必须重写抽象类中的所有抽象方法。\n\t(3)抽象类的成员特点：\n\t\tA:成员变量\n\t\t\t有变量，有常量\n\t\tB:构造方法\n\t\t\t有构造方法\n\t\tC:成员方法\n\t\t\t有抽象，有非抽象\n\t(4)抽象类的练习\n\t\tA:猫狗案例练习\n\t\tB:老师案例练习\n\t\tC:学生案例练习\n\t\tD:员工案例练习\n\t(5)抽象类的几个小问题\n\t\tA:抽象类有构造方法，不能实例化，那么构造方法有什么用?\n\t\t\t用于子类访问父类数据的初始化\n\t\tB:一个类如果没有抽象方法,却定义为了抽象类，有什么用?\n\t\t\t为了不让创建对象\n\t\tC:abstract不能和哪些关键字共存\n\t\t\ta:final\t冲突\n\t\t\tb:private 冲突\n\t\t\tc:static 无意义\n\n\n## 4. 接口(掌握)\n\n\t(1)回顾猫狗案例，它们仅仅提供一些基本功能。\n\t   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，\n\t   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。\n\t(2)接口的特点：\n\t\tA:接口用关键字interface修饰\n\t\t\tinterface 接口名 {}\n\t\tB:类实现接口用implements修饰\n\t\t\tclass 类名 implements 接口名 {}\n\t\tC:接口不能实例化\n\t\tD:接口的实现类\n\t\t\ta:是一个抽象类。\n\t\t\tb:是一个具体类，这个类必须重写接口中的所有抽象方法。\n\t(3)接口的成员特点：\n\t\tA:成员变量\n\t\t\t只能是常量\n\t\t\t默认修饰符：public static final\n\t\tB:构造方法\n\t\t\t没有构造方法\n\t\tC:成员方法\n\t\t\t只能是抽象的\n\t\t\t默认修饰符：public abstract\n\t(4)类与类,类与接口,接口与接口\n\t\tA:类与类\n\t\t\t继承关系，只能单继承，可以多层继承\n\t\tB:类与接口\n\t\t\t实现关系，可以单实现，也可以多实现。\n\t\t\t还可以在继承一个类的同时，实现多个接口\n\t\tC:接口与接口\n\t\t\t继承关系，可以单继承，也可以多继承\n\t(5)抽象类和接口的区别(自己补齐)?\n\t\tA:成员区别\n\t\t\t抽象类：可以是变量可以是常量\n\t\t\t接口：只能是常量\n\t\tB:关系区别:\n\t\t\t类与类：继承\n\t\t\t类与接口：实现\n\t\t\t接口与接口：继承\n\t\tC:设计理念不同\n\t\t\t抽象类：is a，抽象类中定义的是共性功能。\n\t\t\t接口：like a，接口中定义的是扩展功能。\n\t(6)练习：\n\t\tA:猫狗案例，加入跳高功能\n\t\tB:老师和学生案例，加入抽烟功能0\n\n\n\n## 1. 形式参数和返回值的问题(理解)\n\n\t(1)形式参数：\n\t\t类名：需要该类的对象\n\t\t抽象类名：需要该类的子类对象\n\t\t接口名：需要该接口的实现类对象\n\t(2)返回值类型：\n\t\t类名：返回的是该类的对象\n\t\t抽象类名：返回的是该类的子类对象\n\t\t接口名：返回的是该接口的实现类的对象\n\t(3)链式编程\n\t\t对象.方法1().方法2().......方法n();\n\t\t\n\t\t这种用法：其实在方法1()调用完毕后，应该一个对象；\n\t\t\t      方法2()调用完毕后，应该返回一个对象。\n\t\t\t\t  方法n()调用完毕后，可能是对象，也可以不是对象。\n\n\n## 2. 包(理解)\n\n\t(1)其实就是文件夹\n\t(2)作用：\n\t\tA:区分同名的类\n\t\tB:对类进行分类管理\n\t\t\ta:按照功能分\n\t\t\tb:按照模块分\n\t(3)包的定义(掌握)\n\t\tpackage 包名;\n\t\t多级包用.分开。\n\t(4)注意事项：(掌握)\n\t\tA:package语句必须在文件中的第一条有效语句\n\t\tB:在一个java文件中，只能有一个package\n\t\tC:如果没有package，默认就是无包名\n\t(5)带包的编译和运行\n\t\tA:手动式\n\t\tB:自动式(掌握)\n\t\t\tjavac -d . HelloWorld.java\n\n## 3. 导包(掌握)\n\n\t(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。\n\t(2)格式：\n\t\timport 包名...类名;\n\t\t另一种：\n\t\t\timport 包名...*;(不建议)\n\t(3)package,import,class的顺序\n\t\tpackage > import > class\n\n## 4. 权限修饰符(掌握)\n\n\t(1)权限修饰符\n\t\t\t\t\t本类\t同一个包下\t不同包下的子类\t不同包下的无关类\n\t\tprivate\t\tY\n\t\t\t默认\t\tY\t\tY\n\t\tprotected\tY\t\tY\t\t\t Y\n\t\tpublic\t\tY\t\tY\t\t\t Y\t\t\t\t  Y\n\t(2)这四种权限修饰符在任意时刻只能出现一种。\n\t\tpublic class Demo {}\t\t\n\n\n## 5. 常见的修饰符(理解)\n\n\t(1)分类：\n\t\t权限修饰符：private,默认,protected,public\n\t\t状态修饰符：static,final\n\t\t抽象修饰符：abstract\n\t(2)常见的类及其组成的修饰\n\t\t类：\n\t\t\t默认,public,final,abstract\n\t\t\t常用的：public\n\t\t成员变量：\n\t\t\tprivate,默认,protected,public,static,final\n\t\t\t常用的：private\n\t\t构造方法：\n\t\t\tprivate,默认,protected,public\n\t\t\t常用的：public\n\t\t成员方法：\n\t\t\tprivate,默认,protected,public,static,final,abstract\n\t\t\t常用的：public\n\t(3)另外比较常见的：\n\t\tpublic static final int X = 10;\n\t\tpublic static void show() {}\n\t\tpublic final void show() {}\n\t\tpublic abstract void show();\n\n\n## 6. 内部类(理解)\n\n\t(1)把类定义在另一个类的内部，该类就被称为内部类。\n\t\t举例：把类B定义在类A中，类B就被称为内部类。\n\t(2)内部类的访问规则\n\t\tA:可以直接访问外部类的成员，包括私有\n\t\tB:外部类要想访问内部类成员，必须创建对象\n\t(3)内部类的分类\n\t\tA:成员内部类\n\t\tB:局部内部类\n\t(4)成员内部类\n\t\tA:private 为了数据的安全性\n\t\tB:static 为了访问的方便性\t\t\n\t成员内部类不是静态的：\n\t\t外部类名.内部类名 对象名 = new 外部类名.new 内部类名();\n\t成员内部类是静态的：\n\t\t外部类名.内部类名 对象名 = new 外部类名.内部类名();\n(5)成员内部类的面试题(填空)\n\n\t30,20,10\n\tclass Outer {\n\t\tpublic int num = 10;\n\t\t\tclass Inner {\n\t\t\t\tpublic int num = 20;\n\t\t\t\tpublic viod show() {\n\t\t\t\tint num  = 30;\n\t\t\t\tSystem.out.println(num);\n\t\t\t\tSystem.out.println(this.num);\n\t\t\t\tSystem.out.println(Outer.this.num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n(6)局部内部类\n\n\tA:局部内部类访问局部变量必须加final修饰。\n\tB:为什么呢?\n\t\t因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。\n\t\t所以，堆内存还是用该变量，而改变量已经没有了。\n\t\t为了让该值还存在，就加final修饰。\n\t\t通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。\n(7)匿名内部类(掌握)\n\n\tA:是局部内部类的简化形式\n\tB:前提\n\t\t存在一个类或者接口\n\tC:格式:\n\t\tnew 类名或者接口名() {\n\t\t\t重写方法;\n\t\t}\n\tD:本质：\n\t\t其实是继承该类或者实现接口的子类匿名对象\n(8)匿名内部类在开发中的使用\n\n\t我们在开发的时候，会看到抽象类，或者接口作为参数。\n\t而这个时候，我们知道实际需要的是一个子类对象。\n\t如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。\n\t\n\tinterface Person {\n\t\tpublic abstract void study();\n\t}\n\t\n\tclass PersonDemo {\n\t\tpublic void method(Person p) {\n\t\t\tp.study();\n\t\t}\n\t}\n\t\n\tclass PersonTest {\n\t\tpublic static void main(String[] args) {\n\t\t\tPersonDemo pd = new PersonDemo();\n\t\t\tpd.method(new Person() {\n\t\t\t\tpublic void study() {\n\t\t\t\t\tSystem.out.println(\"好好学习，天天向上\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n(9)匿名内部类的面试题(补齐代码)\n\n\tinterface Inter {\n\t\tvoid show();\n\t}\n\t\n\tclass Outer {\n\t\tpublic static Inter method() {\n\t\t\treturn new Inter() {\n\t\t\t\tpublic void show() {\n\t\t\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t\t\t}\t\n\t\t\t};\n\t\t}\n\t}\n\t\n\tclass OuterDemo {\n\t\tpublic static void main(String[] args) {\n\t\t\tOuter.method().show(); //\"HelloWorld\"\n\t\t}\n\t\n\t}\n\nJava开发工具\n\n\t## 1. Eclipse的概述使用(掌握)\n\t\t请参照ppt和课堂练习.txt\n\t\t\n\t## 2. API的概述(了解)\n\t\t(1)应用程序编程接口。\n\t\t(2)就是JDK提供给我们的一些提高编程效率的java类。\n\n\n​\t\n\t## 3. Object类(掌握)\n\t\t(1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。\n\t\t(2)Object类的构造方法有一个，并且是无参构造\n\t\t\t这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造\n\t\t(3)要掌握的方法：\n\t\t\tA:toString()\n\t\t\t\t返回对象的字符串表示，默认是由类的全路径+'@'+哈希值的十六进制表示。\n\t\t\t\t这个表示其实是没有意义的，一般子类都会重写该方法。\n\t\t\t\t如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。\n\t\t\t\t但是最终还是自动生成。\n\t\t\tB:equals()\n\t\t\t\t比较两个对象是否相同。默认情况下，比较的是地址值是否相同。\n\t\t\t\t而比较地址值是没有意义的，所以，一般子类也会重写该方法。\n\t\t\t\t重写过程，我也详细的讲解和分析了。\n\t\t\t\t但是最终还是自动生成。\n\t\t(4)要了解的方法：\n\t\t\tA:hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。\n\t\t\tB:getClass() 返回对象的字节码文件对象，反射中我们会详细讲解\t\n\t\t\tC:finalize() 用于垃圾回收，在不确定的时间\n\t\t\tD:clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。\n\t\t(5)两个注意问题；\n\t\t\tA:直接输出一个对象名称，其实默认调用了该对象的toString()方法。\n\t\t\tB:面试题 \n\t\t\t\t==和equals()的区别?\n\t\t\t\tA:==\n\t\t\t\t\t基本类型：比较的是值是否相同\n\t\t\t\t\t引用类型：比较的是地址值是否相同\n\t\t\t\tB:equals()\n\t\t\t\t\t只能比较引用类型。默认情况下，比较的是地址值是否相同。\n\t\n\t\t\t\t但是，我们可以根据自己的需要重写该方法。\n\n# Java常见对象\n\n## 1. Scanner的使用(了解)\n\t\t(1)在JDK5以后出现的用于键盘录入数据的类。\n\t\t(2)构造方法：\n\t\t\tA:讲解了System.in这个东西。\n\t\t\t\t它其实是标准的输入流,对应于键盘录入\n\t\t\tB:构造方法\n\t\t\t\tInputStream is = System.in;\n\t\t\t\tScanner(InputStream is)\n\t\t\tC:常用的格式\n\t\t\t\tScanner sc = new Scanner(System.in);\n\t(3)基本方法格式：\n\t\tA:hasNextXxx() 判断是否是某种类型的\n\t\tB:nextXxx()\t返回某种类型的元素\n\t(4)要掌握的两个方法\n\t\tA:public int nextInt()\n\t\tB:public String nextLine()\n\t(5)需要注意的小问题\n\t\tA:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。\n\t\tB:解决方案：\n\t\t\ta:重新定义一个Scanner对象\n\t\t\tb:把所有的数据都用字符串获取，然后再进行相应的转换\n\n## 2. String类的概述和使用(掌握)\n\n\t(1)多个字符组成的一串数据。\n\t\t其实它可以和字符数组进行相互转换。\n\t(2)构造方法：\n\t\tA:public String()\n\t\tB:public String(byte[] bytes)\n\t\tC:public String(byte[] bytes,int offset,int length)\n\t\tD:public String(char[] value)\n\t\tE:public String(char[] value,int offset,int count)\n\t\tF:public String(String original)\n\t\t下面的这一个虽然不是构造方法，但是结果也是一个字符串对象\n\t\tG:String s = \"hello\";\n\t(3)字符串的特点\n\t\tA:字符串一旦被赋值，就不能改变。\n\t\t\t注意：这里指的是字符串的内容不能改变，而不是引用不能改变。\n\t\tB:字面值作为字符串对象和通过构造方法创建对象的不同\n\t\t\tString s = new String(\"hello\");和String s = \"hello\"的区别?\n\t\t\tnew String(\"hello\")会在堆内存开辟空间,另一种不会,但是最终的值都在字符串缓存区.\n\t(4)字符串的面试题(看程序写结果)\n\t\tA:==和equals()\n\t\t\tString s1 = new String(\"hello\");\n\t\t\tString s2 = new String(\"hello\");\n\t\t\tSystem.out.println(s1 == s2);// false\n\t\t\tSystem.out.println(s1.equals(s2));// true\n\n\n\t\t\tString s3 = new String(\"hello\");\n\t\t\tString s4 = \"hello\";\n\t\t\tSystem.out.println(s3 == s4);// false\n\t\t\tSystem.out.println(s3.equals(s4));// true\n\n\n\t\t\tString s5 = \"hello\";\n\t\t\tString s6 = \"hello\";\n\t\t\tSystem.out.println(s5 == s6);// true(常量会先去缓存区找,存在就不创建新的对象)\n\t\t\tSystem.out.println(s5.equals(s6));// true\n\t\tB:字符串的拼接\n\t\t\tString s1 = \"hello\";\n\t\t\tString s2 = \"world\";\n\t\t\tString s3 = \"helloworld\";\n\t\t\tSystem.out.println(s3 == s1 + s2);// false\n\t\t\tSystem.out.println(s3.equals((s1 + s2)));// true\n\n\n\t\t\tSystem.out.println(s3 == \"hello\" + \"world\");// false 这个我们错了，应该是true\n\t\t\tSystem.out.println(s3.equals(\"hello\" + \"world\"));// true\n\t(5)字符串的功能(自己补齐方法中文意思)\n\t\tA:判断功能\n\t\t\tboolean equals(Object obj)\n\t\t\tboolean equalsIgnoreCase(String str)\n\t\t\tboolean contains(String str)\n\t\t\tboolean startsWith(String str)\n\t\t\tboolean endsWith(String str)\n\t\t\tboolean isEmpty()\n\t\tB:获取功能\n\t\t\tint length()\n\t\t\tchar charAt(int index)\n\t\t\tint indexOf(int ch)\n\t\t\tint indexOf(String str)\n\t\t\tint indexOf(int ch,int fromIndex)\n\t\t\tint indexOf(String str,int fromIndex)\n\t\t\tString substring(int start)\n\t\t\tString substring(int start,int end)\n\t\tC:转换功能\n\t\t\tbyte[] getBytes()\n\t\t\tchar[] toCharArray()\n\t\t\tstatic String valueOf(char[] chs)\n\t\t\tstatic String valueOf(int i)\n\t\t\tString toLowerCase()\n\t\t\tString toUpperCase()\n\t\t\tString concat(String str)\n\t\tD:其他功能\n\t\t\ta:替换功能 \n\t\t\t\tString replace(char old,char new)\n\t\t\t\tString replace(String old,String new)\n\t\t\tb:去空格功能\n\t\t\t\tString trim()\n\t\t\tc:按字典比较功能\n\t\t\t\tint compareTo(String str)\n\t\t\t\tint compareToIgnoreCase(String str) \n\t(6)字符串的案例\n\t\tA:模拟用户登录\n\t\t\tpublic static void login(String userName, String passwd) {\n\t\t        if (userName == \"Xmos\" && passwd == \"123\") {\n\t\t            System.out.println(\"login success\");\n\t\t        }\n\t\t    }\n\t\tB:字符串遍历\n\t\t\tpublic static void printString(String s) {\n\t\t        char[] c = s.toCharArray();\n\t\t        for (int i = 0; i < c.length; i++) {\n\t\t            System.out.print(c[i]);\n\t\t        }\n\t\t    }\n\t\tC:统计字符串中大写，小写及数字字符的个数\n\t\t\tpublic static void method(String s) {\n\t\t        char[] c = s.toCharArray();\n\t\t        int lowerCaseNum = 0;\n\t\t        int upperCaseNum = 0;\n\t\t        int num = 0;\n\t\t        for (char c1 : c) {\n\t\t            if (c1 >= 'a' && c1 <= 'z') {\n\t\t                lowerCaseNum++;\n\t\t            } else if (c1 >= 'A' && c1 <= 'Z') {\n\t\t                upperCaseNum++;\n\t\t            } else if (c1 >= '0' && c1 <= '9') {\n\t\t                num++;\n\t\t            }\n\t\t        }\n\t\t        \n\t\tD:把字符串的首字母转成大写，其他小写\n\t\t\tpublic static void method1(String s) {\n\t\t        String s1 = s.substring(0, 1);\n\t\t        String s2 = s.substring(1, s.length());\n\t\t        String s3 = s1.toUpperCase() + s2.toLowerCase();\n\t\t\n\t\t        System.out.println(s3);\n\t\t    }\t\t\n\t\tE:把int数组拼接成一个指定格式的字符串\n\t\t\t//方法一\n\t\t\tpublic static void method3(int[] i) {\n\t\t        String s = Arrays.toString(i);\n\t\t        System.out.println(s);\n\t\t    }\n\t\t    //方法二\n\t\t\tpublic static void method3(int[] i) {\n\t\t\t        String s = \"\";\n\t\t\t        for (int i1 : i) {\n\t\t\t            s += String.valueOf(i1);\n\t\t\t        }\n\t\t\t        System.out.println(s);\n\t\t\t    }\n\t\tF:字符串反转\n\t\t\tpublic static void revers(String s) {\n\t\t        char[] c = s.toCharArray();\n\t\t        for (int i = 0; i < c.length / 2; i++) {\n\t\t            char tmp = c[i];\n\t\t            c[i] = c[c.length - 1 - i];\n\t\t            c[c.length - 1 - i] = tmp;\n\t\t        }\n\t\t        System.out.println(String.valueOf(c));\n\t\t    }\t\t\n\t\tG:统计大串中小串出现的次数\n\n\n## 1. StringBuffer(掌握)\n\n\t(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了\n\t   一个字符串缓冲区类。StringBuffer供我们使用。\n\t(2)StringBuffer的构造方法\n\t\tA:StringBuffer()\n\t\tB:StringBuffer(int size)\n\t\tC:StringBuffer(String str)\n\t(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)\n\t\tA:添加功能\n\t\t\tappen();\n\t\tB:删除功能\n\t\t\tdelete();\n\t\tC:替换功能\n\t\t\treplace()\n\t\tD:反转功能\n\t\t\treverse()\n\t\tE:截取功能(注意这个返回值)\n\t\t\tString substring()\n\t(4)StringBuffer的练习(做一遍)\n\t\tA:String和StringBuffer相互转换\n\t\t\tString -- StringBuffer\n\t\t\t\t构造方法\n\t\t\tStringBuffer -- String\n\t\t\t\ttoString()方法\n\t\tB:字符串的拼接\n\t\t\tStringBuffer sb = new StringBuffer(\"hello\");\n\t        StringBuffer sb2 = new StringBuffer(\"world\");\n\t        \n\t        StringBuffer sb3 = sb.append(sb2);\n\t\tC:把字符串反转\n\t\t\tStringBuffer sb = new StringBuffer(\"abc\");\n\t        StringBuffer sb1 = sb.reverse();\n\t\tD:判断一个字符串是否对称\n\t\t\tpublic static void method(StringBuffer sb) {\n\t\t        if (sb.toString().equals(sb.reverse().toString())) {\n\t\t            System.out.println(true);\n\t\t        } else {\n\t\t            System.out.println(false);\n\t\t        }\n\t\t    }\n\t\t\t\n\t(5)面试题\n\t\t小细节：\n\t\t\tStringBuffer：同步的，数据安全，效率低。\n\t\t\tStringBuilder：不同步的，数据不安全，效率高。\n\t\tA:String,StringBuffer,StringBuilder的区别\n\t\t\tString 字符串常量\n\t\t\tStringBuffer 字符串变量（线程安全）\n\t\t\tStringBuilder 字符串变量（非线程安全）\n\t\tB:StringBuffer和数组的区别?\n\t\t\tStringBuffer : 可以存放任意类型的数据\n\t\t\t数组 : 只能存放同类型的数据\n\t(6)注意的问题：\n\t\tString作为形式参数，StringBuffer作为形式参数。\n\t\t\tString : 不会受影响\n\t\t\tStringBuffer : 除了=操作，其他操作会受影响\n## 2. 数组高级以及Arrays(掌握)\n\t(1)排序\n\t\tA:冒泡排序\n\t\t\t相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。\n\t\t\t\n\t\t\tpublic static void bubbleSort(int[] arr) {\n\t\t\t\tfor(int x=0; x<arr.length-1; x++) {\n\t\t\t\t\tfor(int y=0; y<arr.length-1-x; y++) {\n\t\t\t\t\t\tif(arr[y] > arr[y+1]) {\n\t\t\t\t\t\t\tint temp = arr[y];\n\t\t\t\t\t\t\tarr[y] = arr[y+1];\n\t\t\t\t\t\t\tarr[y+1] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tB:选择排序\n\t\t\t把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。\n\t\t\t\n\t\t\tpublic static void selectSort(int[] arr) {\n\t\t\t\tfor(int x=0; x<arr.length-1; x++) {\n\t\t\t\t\tfor(int y=x+1; y<arr.length; y++) {\n\t\t\t\t\t\tif(arr[y] < arr[x]) {\n\t\t\t\t\t\t\tint temp = arr[x];\n\t\t\t\t\t\t\tarr[x] = arr[y];\n\t\t\t\t\t\t\tarr[y] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t(2)查找\n\t\tA:基本查找\n\t\t\t针对数组无序的情况\n\t\t\t\n\t\t\tpublic static int getIndex(int[] arr,int value) {\n\t\t\t\tint index = -1;\n\t\t\t\t\n\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\tif(arr[x] == value) {\n\t\t\t\t\t\tindex = x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn index;\n\t\t\t}\n\t\tB:二分查找(折半查找)\n\t\t\t针对数组有序的情况(千万不要先排序，在查找)\n\t\t\t\n\t\t\tpublic static int binarySearch(int[] arr,int value) {\n\t\t\t\tint min = 0;\n\t\t\t\tint max = arr.length-1;\n\t\t\t\tint mid = (min+max)/2;\n\t\t\t\t\n\t\t\t\twhile(arr[mid] != value) {\n\t\t\t\t\tif(arr[mid] > value) {\n\t\t\t\t\t\tmax = mid - 1;\n\t\t\t\t\t}else if(arr[mid] < value) {\n\t\t\t\t\t\tmin = mid + 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(min > max) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmid = (min+max)/2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn mid;\n\t\t\t}\n\t(3)Arrays工具类\n\t\tA:是针对数组进行操作的工具类。包括排序和查找等功能。\n\t\tB:要掌握的方法(自己补齐方法)\n\t\t\t把数组转成字符串：\n\t\t\t\tArrays.toString();\n\t\t\t排序：\n\t\t\t\tArrays.sort();\n\t\t\t二分查找：\n\t\t\t\tArrays.binarySearch();\n\t(4)Arrays工具类的源码解析\n\t(5)把字符串中的字符进行排序\n\t\t举例：\n\t\t\t\"edacbgf\"\n\t\t\t得到结果\n\t\t\t\"abcdefg\"\n\t\t\tString s = \"edacbgf\";\n\t        char[] c = s.toCharArray();\n\t        Arrays.sort(c);\n\t        System.out.println(Arrays.toString(c));\n\n\n## 3. Integer(掌握)\n\n\t(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型\n\t\tbyte \t\tByte\n\t\tshort\t\tShort\n\t\tint\t\t\tInteger\n\t\tlong\t\tLong\n\t\tfloat\t\tFloat\n\t\tdouble\t\tDouble\n\t\tchar\t\tCharacter\n\t\tboolean\t\tBoolean\n\t(2)Integer的构造方法\n\t\tA:Integer i = new Integer(100);\n\t\tB:Integer i = new Integer(\"100\");\n\t\t\t注意：这里的字符串必须是由数字字符组成\n\t(3)String和int的相互转换\n\t\tA:String -- int\n\t\t\tInteger.parseInt(\"100\");\n\t\tB:int -- String\n\t\t\tString.valueOf(100);\n\t(4)其他的功能(了解)\n\t\t进制转换\n\t\t\tInteger.toBinaryString();\n\t        Integer.toHexString();\n\t        Integer.toOctalString();\n\t(5)JDK5的新特性\n\t\t自动装箱\t基本类型--引用类型\n\t\t自动拆箱\t引用类型--基本类型\n\t\t\n\t\t把下面的这个代码理解即可：\n\t\t\tInteger i = 100;\n\t\t\ti += 200;\n\t(6)面试题\n\t\t-128到127之间的数据缓冲池问题\n\n## 4. Character(了解)\n\n\t(1)Character构造方法\t\n\t\tCharacter ch = new Character('a');\n\t(2)要掌握的方法：(自己补齐)\n\t\tA:判断给定的字符是否是大写\n\t\t\tisUpperCase();\n\t\tB:判断给定的字符是否是小写\n\t\t\tisLowerCase();\n\t\tC:判断给定的字符是否是数字字符\n\t\t\tisDigit();\n\t\tD:把给定的字符转成大写\n\t\t\ttoUpperCase();\n\t\tE:把给定的字符转成小写\n\t\t\ttoLowerCase();\n\t(3)案例：\n\t\n\t\t统计字符串中大写，小写及数字字符出现的次数\n\t\t\tString s = \"abcDEF123\";\n\t        char[] c = s.toCharArray();\n\t        int lowerCaseNum = 0;\n\t        int upperCaseNum = 0;\n\t        int digitNum = 0;\n\t\n\t        for (char c1 : c) {\n\t            if (Character.isLowerCase(c1)) {\n\t                lowerCaseNum++;\n\t            } else if (Character.isUpperCase(c1)) {\n\t                upperCaseNum++;\n\t            } else if (Character.isDigit(c1)) {\n\t                digitNum++;\n\t            }\n\t        }\n\t\n\t        System.out.println(\"lowerCase:\" + lowerCaseNum + \"\\t\" + \"upperCase:\" + upperCaseNum + \"\\t\" + \"digit:\" + digitNum);\n\n\n## 1. 正则表达式(理解)\n\n\t(1)就是符合一定规则的字符串\n\t(2)常见规则\n\t\tA:字符\n\t\t\tx 字符 x。举例：'a'表示字符a\n\t\t\t\\\\ 反斜线字符。\n\t\t\t\\n 新行（换行）符 ('\\u000A') \n\t\t\t\\r 回车符 ('\\u000D')\n\t\t\t\n\t\tB:字符类\n\t\t\t[abc] a、b 或 c（简单类） \n\t\t\t[^abc] 任何字符，除了 a、b 或 c（否定） \n\t\t\t[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） \n\t\t\t[0-9] 0到9的字符都包括\n\t\t\t\n\t\tC:预定义字符类\n\t\t\t. 任何字符。我的就是.字符本身，怎么表示呢? \\.\n\t\t\t\\d 数字：[0-9]\n\t\t\t\\w 单词字符：[a-zA-Z_0-9]\n\t\t\t\t在正则表达式里面组成单词的东西必须有这些东西组成\n\t\t\t\t\n\t\tD:边界匹配器\n\t\t\t^ 行的开头 \n\t\t\t$ 行的结尾 \n\t\t\t\\b 单词边界\n\t\t\t\t就是不是单词字符的地方。\n\t\t\t\t举例：hello world?haha;xixi\n\t\t\t\n\t\tE:Greedy 数量词 \n\t\t\tX? X，一次或一次也没有\n\t\t\tX* X，零次或多次\n\t\t\tX+ X，一次或多次\n\t\t\tX{n} X，恰好 n 次 \n\t\t\tX{n,} X，至少 n 次 \n\t\t\tX{n,m} X，至少 n 次，但是不超过 m 次 \n\t(3)常见功能：(分别用的是谁呢?)\n\t\tA:判断功能\n\t\t\tString类的public boolean matches(String regex)\n\t\tB:分割功能\n\t\t\tString类的public String[] split(String regex)\n\t\tC:替换功能\n\t\t\tString类的public String replaceAll(String regex,String replacement)\n\t\tD:获取功能\n\t\t\tPattern和Matcher\n\t\t\t\tPattern p = Pattern.compile(\"a*b\");\n\t\t\t\tMatcher m = p.matcher(\"aaaaab\");\n\t\t\t\t\n\t\t\t\tfind():查找存不存在\n\t\t\t\tgroup():获取刚才查找过的数据\n\t(4)案例\n\t\tA:判断电话号码和邮箱\n\t\t\t//普安段邮箱\n\t\t\tpublic static boolean checkMail(String s){\n\t\t        String regex = \"\\\\d*\\\\w*@sina\\\\.com\";\n\t\t        return s.matches(regex);\n\t\t    }\n\t\t    //判断电话号码\n\t\t    public static boolean checkPhoneNum(String s) {\n\t\t        String regex = \"\\\\d{11}\";\n\t\t        return s.matches(regex);\n\t\t    }\n\t\tB:按照不同的规则分割数据\n\t\t\tpublic static String[] split(String s) {\n\t\t        String regex = \",\";\n\t\t        String[] result = s.split(regex);\n\t\t        return result;\n\t\t    }\n\t\tC:把论坛中的数字替换为*\n\t\t\t//替换为和数字等量的*\n\t\t\tpublic static String replaceStar(String s) {\n\t\t        String regex = \"\\\\d\";\n\t\t        return s.replaceAll(regex, \"*\");\n\t\t    }\n\t\t    //所有相连数字替换为一个*\n\t\t    public static String replaceStar(String s) {\n\t\t        String regex = \"\\\\d+\";\n\t\t        return s.replaceAll(regex, \"*\");\n\t\t    }\n\t\tD:获取字符串中由3个字符组成的单词\n\t\t\tpublic static List<String> method(String s) {\n\t\t        Pattern p = Pattern.compile(\"a\\\\d{3}b\");\n\t\t        Matcher m = p.matcher(s);\n\t\t        List<String> result = new ArrayList<String>();\n\t\t        \n\t\t        while (m.find()) {\n\t\t            result.add(m.group());\n\t\t        }\n\t\t        return  result;\n\t\t    }\n\n## 2. Math(掌握)\n\n\t(1)针对数学运算进行操作的类\n\t(2)常见方法(自己补齐)\n\t\tA:绝对值\n\t\t\tMath.abs();\n\t\tB:向上取整\n\t\t\tMath.ceil();\n\t\tC:向下取整\n\t\t\tMath.floor();\n\t\tD:两个数据中的大值\n\t\t\tMath.max();\n\t\tE:a的b次幂\n\t\t\tMath.pow(a, b);\n\t\tF:随机数\n\t\t\tMath.random();\n\t\tG:四舍五入\n\t\t\tMath.round();\n\t\tH:正平方根\n\t\t\tMath.sqrt();\n\t(3)案例：\n\t\tA:猜数字小游戏\n\t\t\tScanner sc = new Scanner(System.in);\n\t        int i = (int)(Math.random() * 100) + 1;\n\t        int answer;\n\t        while ((answer = sc.nextInt()) != i) {\n\t            if (answer > i) {\n\t                System.out.println(\"bigger than result,go on\");\n\t            } else if (answer < i) {\n\t                System.out.println(\"smaller than result,go on\");\n\t            }\n\t        }\n\t        System.out.println(\"you are right\");\n\t\tB:获取任意范围的随机数\n\t\t\tScanner sc = new Scanner(System.in);\n\t        System.out.println(\"请输入起始:\");\n\t        int start = sc.nextInt();\n\t        System.out.println(\"请输入结束:\");\n\t        int end = sc.nextInt();\n\t\n\t        int i = (int)(Math.random() * (end - start)) + start;\n\t        System.out.println(i);\n## 3. Random(理解)\n\n\t(1)用于产生随机数的类\n\t(2)构造方法:\n\t\tA:Random() 默认种子，每次产生的随机数不同\n\t\tB:Random(long seed) 指定种子，每次种子相同，随机数就相同\n\t(3)成员方法:\n\t\tA:int nextInt() 返回int范围内的随机数\n\t\tB:int nextInt(int n) 返回[0,n)范围内的随机数\n\n\n## 4. System(掌握)\n\n\t(1)系统类,提供了一些有用的字段和方法\n\t(2)成员方法(自己补齐)\n\t\tA:运行垃圾回收器\n\t\t\tSystem.gc();\n\t\tB:退出jvm\n\t\t\tSystem.exit(0);\n\t\tC:获取当前时间的毫秒值\n\t\t\tSystem.currentTimemillis();\n\t\tD:数组复制\n\t\t\tSystem.arraycopy();\n\n## 5. BigInteger(理解)\n\n\t(1)针对大整数的运算\n\t(2)构造方法\t\n\t\tA:BigInteger(String s)\n\t(3)成员方法(自己补齐)\n\t\tA:加\n\t\t\tadd();\n\t\tB:减\n\t\t\tsubtract();\n\t\tC:乘\n\t\t\tmultiply();\n\t\tD:除\n\t\t\tdivide();\n\t\tE:商和余数\n\t\t\tdivideAndRemainder();\n\n## 6. BigDecimal(理解)\n\n\t(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)\n\t(2)构造方法\n\t\tA:BigDecimal(String s)\n\t(3)成员方法：\n\t\tA:加\n\t\t\tadd();\n\t\tB:减\n\t\t\tsubtract();\n\t\tC:乘\n\t\t\tmultiply();\n\t\tD:除\n\t\t\tdivide();\n\t\tE:自己保留小数几位\n\t\t\tsetScale();\n\n## 7. Date/DateFormat(掌握)\n\n\t(1)Date是日期类，可以精确到毫秒。\n\t\tA:构造方法\n\t\t\tDate()\n\t\t\tDate(long time)\n\t\tB:成员方法\n\t\t\tgetTime()\n\t\t\tsetTime(long time)\n\t\tC:日期和毫秒值的相互转换\n\t\t案例：你来到这个世界多少天了?\n\t(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat\n\t\tA:SimpleDateFormat(String pattern) 给定模式\n\t\t\tyyyy-MM-dd HH:mm:ss\n\t\tB:日期和字符串的转换\n\t\t\ta:Date -- String\n\t\t\t\tformat()\n\t\t\t\t\n\t\t\tb:String -- Date\n\t\t\t\tparse()\n\t\tC:案例：\n\t\t\t制作了一个针对日期操作的工具类。\n\t\t\t\tDate d = new Date();\n\t\t        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t        System.out.println(sdf.format(d));\n\n## 8. Calendar(掌握)\n\n\t(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。\n\t(2)如何得到一个日历对象呢?\n\t\tCalendar rightNow = Calendar.getInstance();\n\t\t本质返回的是子类对象\n\t(3)成员方法\n\t\tA:根据日历字段得到对应的值\n\t\t\tCalendar c =Calendar.getInstance();\n\t        System.out.println(c.get(Calendar.YEAR));\n\t        System.out.println(c.get(Calendar.MONTH));\n\t        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n\t\tB:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值\n\t\t\tadd(Calendar.DAY_OF_MONTH, +3);\n\t\tC:设置日历对象的年月日\n\t\t\tset(2018,5,30);\n\t\t\tset(Calendar.YEAR, 2018);\n\t\t\tset(Calendar.MONTH, 2018);\n\t\t\tset(Calendar.DAY_OF_MONTH, 2018);\n\t(4)案例：\n\t\t计算任意一年的2月份有多少天?\n\t\t\tScanner sc = new Scanner(System.in);\n\t        Calendar c =Calendar.getInstance();\n\t\n\t        c.set(Calendar.YEAR, sc.nextInt());\n\t        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n\n# Java集合框架\n\n# JavaIO流\n\n## 1. 异常(理解)\n\n\t(1)程序出现的不正常的情况。\n\t(2)异常的体系\n\t\tThrowable\n\t\t\t|--Error\t严重问题，我们不处理。\n\t\t\t|--Exception\n\t\t\t\t|--RuntimeException\t运行期异常，我们需要修正代码\n\t\t\t\t|--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过\n\t(3)异常的处理：\n\t\tA:JVM的默认处理\n\t\t\t把异常的名称,原因,位置等信息输出在控制台，但是程序不能继续执行了。\n\t\tB:自己处理\n\t\t\ta:try...catch...finally\n\t\t\t\t自己编写处理代码,后面的程序可以继续执行\n\t\t\tb:throws\n\t\t\t\t把自己处理不了的，在方法上声明，告诉调用者，这里有问题\n\t(4)面试题\n\t\tA:编译期异常和运行期异常的区别?\n\t\t\t编译期异常 必须要处理的，否则编译不通过\n\t\t\t运行期异常 可以不处理，也可以处理\n\t\tB:throw和throws是的区别\n\t\t\tthrow:\n\t\t\t\t在方法体中,后面跟的是异常对象名,并且只能是一个\n\t\t\t\tthrow抛出的是一个异常对象，说明这里肯定有一个异常产生了\n\t\t\tthrows:\n\t\t\t\t在方法声明上,后面跟的是异常的类名,可以是多个\n\t\t\t\tthrows是声明方法有异常，是一种可能性，这个异常并不一定会产生\n\t(5)finally关键字及其面试题\n\t\tA:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了\n\t\tB:面试题\n\t\t\ta:final,finally,finalize的区别?\n\t\t\t\tfinal : 关键字,修饰类、方法、变量,被修饰的类无法被继承,方法无法重写,变量值不能改变.\n\t\t\t\tfinally : try...catch...finally,一定会执行.\n\t\t\t\tfinalize : 对象被垃圾回收器回收时执行的方法.\n\t\t\tb:如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后\n\t\t\t\t会，前。\n\t\t\t\t\n\t\t\t\t实际上在中间。这个上课我们讲过\n\t\tC:异常处理的变形\n\t\t\ttry...catch...finally\n\t\t\ttry...catch...\n\t\t\ttry...catch...catch...\n\t\t\ttry...catch...catch...fianlly\n\t\t\ttry...finally\n\t(6)自定义异常\n\t\t继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可\n\t\t\tpublic class MyException extends RuntimeException {\n\t\t\t    public MyException(String message) {\n\t\t\t        super(message);\n\t\t\t    }\n\t\t\t\n\t\t\t    public MyException() {\n\t\t\t        super();\n\t\t\t    }\n\t\t\t}\n\t(7)异常的注意实现\n\t\tA:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 \n\t\tB:父的方法没有异常抛出,子的重写方法不能有异常抛出\n\t\tC:父的方法抛出多个异常,子的重写方法必须比父少或者小\n\n## 2. File(掌握)\n\n\t(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件\n\t(2)构造方法\n\t\tA:File file = new File(\"e:\\\\demo\\\\a.txt\");\n\t\tB:File file = new File(\"e:\\\\demo\",\"a.txt\");\n\t\tC:File file = new File(\"e:\\\\demo\");\n\t\t  File file2 = new File(file,\"a.txt\");\n\t(3)File类的功能(自己补齐)\n\t\tA:创建功能\n\t\t\tcreateNewFile();\n\t\t\tmkdir();\n\t\t\tmkdirs();\n\t\tB:删除功能\n\t\t\tdelete();\n\t\tC:重命名功能\n\t\t\trenameTo();\n\t\tD:判断功能\n\t\t\tisFile();\n\t        isDirectory();\n\t        exists();\n\t        canRea();\n\t        canWrite();\n\t        isAbsolute();\n\t        isHidden();\n\t\tE:获取功能\n\t\t\tgetAbsoluteFile();\n\t        getAbsolutePath();\n\t        getPath();\n\t        getParent();\n\t        getParentFile();\n\t        getName();\n\t        length();\n\t        lastModified();\n\t\tF:高级获取功能\n\t\t\tlist();\n\t\t\tlistFiles();\n\t\tG:过滤器功能\n\t\t\tlist(FilenameFilter filter);\n\t\t\t\tString[] s = file1.list(new FilenameFilter() {\n\t            @Override\n\t            public boolean accept(File dir, String name) {\n\t                return new File(dir, name).isFile() && name.endsWith(\".jpg\");\n\t            }\n\t        });\n\t\t\tlistFiles(FilenameFilter filter);\n\t(4)案例：\n\t\tA:输出指定目录下指定后缀名的文件名称\n\t\t\ta:先获取所有的，在遍历的时候判断，再输出\n\t\t\t\tFile file = new File(\"D:\\\\Movie\\\\M\");\n\t\t        String[] s = file.list();\n\t\t\n\t\t        for (String result : s) {\n\t\t            if (result.endsWith(\".mp4\")) {\n\t\t                System.out.println(result);\n\t\t            }\n\t\t        }\n\t\t\tb:先判断，再获取，最后直接遍历输出即可\n\t\t\t\tString[] s1 = file.list(new FilenameFilter() {\n\t\t            @Override\n\t\t            public boolean accept(File dir, String name) {\n\t\t                return name.endsWith(\".mp4\");\n\t\t            }\n\t\t        });\n\t\t        for (String result : s1) {\n\t\t            System.out.println(result);\n\t\t        }\n\t\tB:批量修改文件名称\n\t\t\tFile file = new File(\"D:\\\\Movie\");\n\t        String[] s = file.list(new FilenameFilter() {\n\t            @Override\n\t            public boolean accept(File dir, String name) {\n\t                return name.startsWith(\"相对宇宙\");\n\t            }\n\t        });\n\t        for (String result : s) {\n\t            System.out.println(\"beforeRename : \" + result);\n\t            File file1 = new File(file,result.replaceAll(\"WEB.*影视\\\\.\", \"\"));\n\t            File file2 = new File(file, result);\n\t            file2.renameTo(file1);\n\t            System.out.println(\"afterRename : \" + file1.exists() + \", \" + file1.getName());\n\t        }\n\t        ## 1. 递归(理解)\n\t\n\t(1)方法定义中调用方法本身的现象\n\t\t举例：老和尚给小和尚讲故事，我们学编程\n\t(2)递归的注意事项；\n\t\tA:要有出口，否则就是死递归\n\t\tB:次数不能过多，否则内存溢出\n\t\tC:构造方法不能递归使用\n\t(3)递归的案例：\n\t\tA:递归求阶乘\n\t\t\tpublic static int method(int i) {\n\t\t        while (i > 1) {\n\t\t            return i * method(--i);\n\t\t        }\n\t\t        return 1;\n\t\t    }\n\t\tB:兔子问题\n\t\tC:递归输出指定目录下所有指定后缀名的文件绝对路径\n\t\t\tpublic static void method(File filePath, String suffix) {\n\t\t        File[] files = filePath.listFiles();\n\t\t        for (File file : files) {\n\t\t            if (file.isDirectory()) {\n\t\t                method(file, suffix);\n\t\t            } else if (file.getName().endsWith(suffix)){\n\t\t                System.out.println(file.getName());\n\t\t            }\n\t\t        }\n\t\t    }\n\t\tD:递归删除带内容的目录(小心使用)\n\t\t\tpublic static void method(File filePath) {\n\t\t        File[] files = filePath.listFiles();\n\t\t        for (File file : files) {\n\t\t            if (file.isDirectory()) {\n\t\t                method(file);\n\t\t            } else {\n\t\t                file.delete();\n\t\t            }\n\t\t        }\n\t\t        filePath.delete();\n\t\t    }\n\n## 2. IO流(掌握)\n\n\t(1)IO用于在设备间进行数据传输的操作\t\n\t(2)分类：\n\t\tA:流向\n\t\t\t输入流\t读取数据\n\t\t\t输出流\t写出数据\n\t\tB:数据类型\n\t\t\t字节流\t\n\t\t\t\t\t字节输入流\n\t\t\t\t\t字节输出流\n\t\t\t字符流\n\t\t\t\t\t字符输入流\n\t\t\t\t\t字符输出流\n\t\t注意：\n\t\t\ta:如果我们没有明确说明按照什么分，默认按照数据类型分。\n\t\t\tb:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。\n\t(3)FileOutputStream写出数据\n\t\tA:操作步骤\n\t\t\ta:创建字节输出流对象\n\t\t\tb:调用write()方法\n\t\t\tc:释放资源\n\t\t\t\n\t\tB:代码体现：\n\t\t\tFileOutputStream fos = new FileOutputStream(\"fos.txt\");\n\t\t\t\n\t\t\tfos.write(\"hello\".getBytes());\n\t\t\t\n\t\t\tfos.close();\n\t\t\t\n\t\tC:要注意的问题?\n\t\t\ta:创建字节输出流对象做了几件事情?\n\t\t\t\t调用系统功能去创建文件\n\t\t\t\t创建fos对象\n\t\t\t\t把fos对象指向这个文件\n\t\t\tb:为什么要close()?\n\t\t\t\t关闭此文件输出流并释放与此流有关的所有系统资源。\n\t\t\tc:如何实现数据的换行?\n\t\t\t\twindows:\\r\\n\n\t\t\t\tlinux:\\n\n\t\t\t\tMac:\\r\n\t\t\td:如何实现数据的追加写入?\n\t\t\t\tFileOutputStream fos = new FileOutputStream(\"F:\\\\\", true);\n\t(4)FileInputStream读取数据\n\t\tA:操作步骤\n\t\t\ta:创建字节输入流对象\n\t\t\tb:调用read()方法\n\t\t\tc:释放资源\n\t\t\t\n\t\tB:代码体现：\n\t\t\tFileInputStream fis = new FileInputStream(\"fos.txt\");\n\t\t\t\n\t\t\t//方式1\n\t\t\tint by = 0;\n\t\t\twhile((by=fis.read())!=-1) {\n\t\t\t\tSystem.out.print((char)by);\n\t\t\t}\n\t\t\t\n\t\t\t//方式2\n\t\t\tbyte[] bys = new byte[1024];\n\t\t\tint len = 0;\n\t\t\twhile((len=fis.read(bys))!=-1) {\n\t\t\t\tSystem.out.print(new String(bys,0,len));\n\t\t\t}\n\t\t\t\n\t\t\tfis.close();\n\t(5)案例：2种实现\n\t\tA:复制文本文件\n\t\t\tFileInputStream fis = new FileInputStream(\"a.txt\");\n\t        FileOutputStream fos = new FileOutputStream(\"b.txt\");\n\t\t\t//方式一\n\t        int i = 0;\n\t        while ((i = fis.read()) != -1) {\n\t            fos.write(i);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t        //方式二\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tB:复制图片\n\t\t\tFileInputStream fis = new FileInputStream(\"a.jpg\");\n\t        FileOutputStream fos = new FileOutputStream(\"b.jpg\");\n\t\t\t//方式一\n\t        int i = 0;\n\t        while ((i = fis.read()) != -1) {\n\t            fos.write(i);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t        //方式二\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tC:复制视频\n\t\t\tFileInputStream fis = new FileInputStream(\"a.mp4\");\n\t        FileOutputStream fos = new FileOutputStream(\"b.mp4\");\n\t\t\t//方式一\n\t        int i = 0;\n\t        while ((i = fis.read()) != -1) {\n\t            fos.write(i);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t        //方式二\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t(6)字节缓冲区流\n\t\tA:BufferedOutputStream\n\t\tB:BufferedInputStream\n\t(7)案例：4种实现\n\t\tA:复制文本文件\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.txt\"));\n\t        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.txt\"));\n\t\n\t        //方式三\n\t        int i = 0;\n\t        while ((i = bis.read()) != -1) {\n\t            bos.write(i);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n\t        //方式四\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tB:复制图片\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.jpg\"));\n\t        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.jpg\"));\n\t\n\t        //方式三\n\t        int i = 0;\n\t        while ((i = bis.read()) != -1) {\n\t            bos.write(i);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n\t        //方式四\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tC:复制视频\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.mp4\"));\n\t        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.mp4\"));\n\t\n\t        //方式三\n\t        int i = 0;\n\t        while ((i = bis.read()) != -1) {\n\t            bos.write(i);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n\t        //方式四\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n## 3. 自学字符流\n\n\tIO流分类\n\t\t字节流：\n\t\t\tInputStream\n\t\t\t\tFileInputStream\n\t\t\t\tBufferedInputStream\n\t\t\tOutputStream\n\t\t\t\tFileOutputStream\n\t\t\t\tBufferedOutputStream\n\t\t\n\t\t字符流：\n\t\t\tReader\n\t\t\t\tFileReader\n\t\t\t\tBufferedReader\n\t\t\tWriter\n\t\t\t\tFileWriter\n\t\t\t\tBufferedWriter\n## 1. 字符流(掌握)\n\n\t(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。\n\t   转换流的作用就是把字节流转换字符流来使用。\n\t(2)转换流其实是一个字符流\n\t\t字符流 = 字节流 + 编码表\n\t(3)编码表\n\t\tA:就是由字符和对应的数值组成的一张表\n\t\tB:常见的编码表\n\t\t\tASCII\n\t\t\tISO-8859-1\n\t\t\tGB2312\n\t\t\tGBK\n\t\t\tGB18030\n\t\t\tUTF-8\n\t\tC:字符串中的编码问题\n\t\t\t编码\n\t\t\t\tString -- byte[]\n\t\t\t解码\n\t\t\t\tbyte[] -- String\n\t(4)IO流中的编码问题\n\t\tA:OutputStreamWriter\n\t\t\tOutputStreamWriter(OutputStream os):默认编码，GBK\n\t\t\tOutputStreamWriter(OutputStream os,String charsetName):指定编码。\n\t\tB:InputStreamReader\n\t\t\tInputStreamReader(InputStream is):默认编码，GBK\n\t\t\tInputStreamReader(InputStream is,String charsetName):指定编码\n\t\tC:编码问题其实很简单\n\t\t\t编码只要一致即可\n\t(5)字符流\n\t\tReader\n\t\t\t|--InputStreamReader\n\t\t\t\t|--FileReader\n\t\t\t|--BufferedReader\n\t\tWriter\n\t\t\t|--OutputStreamWriter\n\t\t\t\t|--FileWriter\n\t\t\t|--BufferedWriter\n\t(6)复制文本文件(5种方式)\n\t\tpublic class CopyDemo {\n\t    public static void main(String[] args) throws IOException {\n\t        File srcFile = new File(\"a.txt\");\n\t        File destFile = new File(\"b.txt\");\n\t\n\t        method1(srcFile, destFile);\n\t        method2(srcFile, destFile);\n\t        method3(srcFile, destFile);\n\t        method4(srcFile, destFile);\n\t        method5(srcFile, destFile);\n\t    }\n\t\n\t    private static void method5(File srcFile, File destFile) throws IOException{\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        String s = null;\n\t        while ((s = br.readLine()) != null) {\n\t            bw.write(s);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method4(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int len = 0;\n\t        char[] chars = new char[1024];\n\t        while ((len = br.read(chars)) != -1) {\n\t            bw.write(chars, 0, len);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method3(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int by = 0;\n\t        while ((by = br.read()) != -1) {\n\t            bw.write(by);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method2(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int len = 0;\n\t        char[] bytes = new char[1024];\n\t        while ((len = fr.read(bytes)) != -1) {\n\t            fw.write(bytes, 0, len);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\t\n\t    private static void method1(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int by = 0;\n\t        while ((by = fr.read()) != -1) {\n\t            fw.write(by);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\n## 2. IO流小结(掌握)\n\n\tIO流\n\t\t|--字节流\n\t\t\t|--字节输入流\n\t\t\t\tInputStream\n\t\t\t\t\tint read():一次读取一个字节\n\t\t\t\t\tint read(byte[] bys):一次读取一个字节数组\n\t\t\t\t\n\t\t\t\t\t|--FileInputStream\n\t\t\t\t\t|--BufferedInputStream\n\t\t\t|--字节输出流\n\t\t\t\tOutputStream\n\t\t\t\t\tvoid write(int by):一次写一个字节\n\t\t\t\t\tvoid write(byte[] bys,int index,int len):一次写一个字节数组的一部分\n\t\t\t\t\t\n\t\t\t\t\t|--FileOutputStream\n\t\t\t\t\t|--BufferedOutputStream\n\t\t|--字符流\n\t\t\t|--字符输入流\n\t\t\t\tReader\n\t\t\t\t\tint read():一次读取一个字符\n\t\t\t\t\tint read(char[] chs):一次读取一个字符数组\n\t\t\t\t\t\n\t\t\t\t\t|--InputStreamReader\n\t\t\t\t\t\t|--FileReader\n\t\t\t\t\t|--BufferedReader\n\t\t\t\t\t\tString readLine():一次读取一个字符串\n\t\t\t|--字符输出流\n\t\t\t\tWriter\n\t\t\t\t\tvoid write(int ch):一次写一个字符\n\t\t\t\t\tvoid write(char[] chs,int index,int len):一次写一个字符数组的一部分\n\t\t\t\t\t\n\t\t\t\t\t|--OutputStreamWriter\n\t\t\t\t\t\t|--FileWriter\n\t\t\t\t\t|--BufferedWriter\n\t\t\t\t\t\tvoid newLine():写一个换行符\n\t\t\t\t\t\t\n\t\t\t\t\t\tvoid write(String line):一次写一个字符串\n\n## 3. 案例(理解 练习一遍)\n\n\tA:复制文本文件 5种方式(掌握)\n\t\tprivate static void method5(File srcFile, File destFile) throws IOException{\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        String s = null;\n\t        while ((s = br.readLine()) != null) {\n\t            bw.write(s);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method4(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int len = 0;\n\t        char[] chars = new char[1024];\n\t        while ((len = br.read(chars)) != -1) {\n\t            bw.write(chars, 0, len);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method3(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int by = 0;\n\t        while ((by = br.read()) != -1) {\n\t            bw.write(by);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method2(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int len = 0;\n\t        char[] bytes = new char[1024];\n\t        while ((len = fr.read(bytes)) != -1) {\n\t            fw.write(bytes, 0, len);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\t\n\t    private static void method1(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int by = 0;\n\t        while ((by = fr.read()) != -1) {\n\t            fw.write(by);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\tB:复制图片(二进制流数据) 4种方式(掌握)\n\t\tprivate static void method4(File srcFile, File destFile) throws IOException{\n\t        BufferedInputStream bis = new BufferedInputStream(\n\t        \tnew FileInputStream(srcFile));\n\t        BufferedOutputStream bos = new BufferedOutputStream(\n\t        \tnew FileOutputStream(destFile));\n\t\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t        bis.close();\n\t        bos.close();\n\t    }\n\t\n\t    private static void method3(File srcFile, File destFile) throws IOException{\n\t        BufferedInputStream bis = new BufferedInputStream(\n\t        \tnew FileInputStream(srcFile));\n\t        BufferedOutputStream bos = new BufferedOutputStream(\n\t        \tnew FileOutputStream(destFile));\n\t\n\t        int by = 0;\n\t        while ((by = bis.read()) != -1) {\n\t            bos.write(by);\n\t        }\n\t        bis.close();\n\t        bos.close();\n\t    }\n\t\n\t    private static void method2(File srcFile, File destFile) throws IOException{\n\t        FileInputStream fis = new FileInputStream(srcFile);\n\t        FileOutputStream fos = new FileOutputStream(destFile);\n\t\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes,0,len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t    }\n\t\n\t    private static void method1(File srcFile, File destFile) throws IOException{\n\t        FileInputStream fis = new FileInputStream(srcFile);\n\t        FileOutputStream fos = new FileOutputStream(destFile);\n\t\n\t        int by = 0;\n\t        while ((by = fis.read()) != -1) {\n\t            fos.write(by);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t    }\n\tC:把集合中的数据存储到文本文件\n\t\tFile srcFile = new File(\"a.txt\");\n\t    List<String> list = new ArrayList<String>();\n\t\n\t    list.add(\"hello\");\n\t    list.add(\"world\");\n\t    list.add(\"java\");\n\t\t//方式一\n\t    FileOutputStream fos = new FileOutputStream(srcFile);\n\t    for (String s : list) {\n\t        fos.write((s).getBytes());\n\t    }\n\t    fos.close();\n\t    //方式二\n\t    FileWriter fw = new FileWriter(srcFile);\n\t    for (String s : list) {\n\t        fw.write(s.toCharArray());\n\t        fw.flush();\n\t    }\n\t    fw.close();\n\t    //方式三\n\t    BufferedWriter bw = new BufferedWriter(new FileWriter(srcFile));\n\t    for (String s : list) {\n\t        bw.write(s);\n\t        bw.flush();\n\t    }\n\t    bw.close();\n\tD:把文本文件中的数据读取到集合并遍历集合\n\t\tFile srcFile = new File(\"a.txt\");\n\t    List<String> list = new ArrayList<String>();\n\t\n\t    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t    String s = null;\n\t    while ((s = br.readLine()) != null) {\n\t        list.add(s);\n\t    }\n\t    br.close();\n\tE:复制单级文件夹\n\t\tFile srcPath = new File(\"F:\\\\struts-1.2.7\");\n\t    File destPath = new File(\"F:\\\\test1\");\n\t\n\t    File[] srcFiles = srcPath.listFiles();\n\t    BufferedInputStream bis = null;\n\t    BufferedOutputStream bos = null;\n\t    if (!destPath.exists()) {\n\t        destPath.mkdir();\n\t    }\n\t    for (File srcFile : srcFiles) {\n\t        if (srcFile.isFile()) {\n\t             bis = new BufferedInputStream(new FileInputStream(srcFile));\n\t             bos = new BufferedOutputStream(\n\t             \tnew FileOutputStream(new File(destPath,srcFile.getName())));\n\t            int len = 0;\n\t            byte[] bytes = new byte[1024];\n\t            while ((len = bis.read(bytes)) != -1) {\n\t                bos.write(bytes, 0, len);\n\t                bos.flush();\n\t            }\n\t        }\n\t    }\n\t    bis.close();\n\t    bos.close();\n\tF:复制单级文件夹中指定的文件\n\t\tFile srcPath = new File(\"F:\\\\test\");\n\t    File destPath = new File(\"F:\\\\test1\");\n\t\n\t    File[] srcFiles = srcPath.listFiles(new FilenameFilter(){\n\t\n\t        @Override\n\t        public boolean accept(File dir, String name) {\n\t            return dir.isFile()&&name.endsWith(\".java\");\n\t        }\n\t    });\n\t    BufferedInputStream bis = null;\n\t    BufferedOutputStream bos = null;\n\t    if (!destPath.exists()) {\n\t        destPath.mkdir();\n\t    }\n\t    for (File srcFile : srcFiles) {\n\t        if (srcFile.isFile()) {\n\t             bis = new BufferedInputStream(new FileInputStream(srcFile));\n\t             bos = new BufferedOutputStream(\n\t             \tnew FileOutputStream(new File(destPath,srcFile.getName())));\n\t            int len = 0;\n\t            byte[] bytes = new byte[1024];\n\t            while ((len = bis.read(bytes)) != -1) {\n\t                bos.write(bytes, 0, len);\n\t                bos.flush();\n\t            }\n\t        }\n\t    }\n\t    bis.close();\n\t    bos.close();\n\tG:复制多级文件夹\n\t\tpublic class CopyDemo {\n\t    public static void main(String[] args) throws IOException {\n\t        File srcPath = new File(\"F:\\\\test\");\n\t        File destPath = new File(\"F:\\\\test1\");\n\t\n\t        copyFolder(srcPath,destPath);\n\t\n\t    }\n\t\n\t    public static void copyFolder(File srcPath, File destPath) throws IOException{\n\t        if (!destPath.exists()) {\n\t            destPath.mkdir();\n\t        }\n\t        File[] files = srcPath.listFiles();\n\t        for (File file : files) {\n\t            if (file.isDirectory()) {\n\t\n\t                copyFolder(file,new File(destPath,file.getName()));\n\t            } else if (file.isFile()) {\n\t                BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));\n\t                BufferedOutputStream bos = new BufferedOutputStream(\n\t                \tnew FileOutputStream(new File(destPath,file.getName())));\n\t                int len = 0;\n\t                byte[] bytes = new byte[1024];\n\t                while ((len = bis.read(bytes)) != -1) {\n\t                    bos.write(bytes,0,len);\n\t                    bos.flush();\n\t                }\n\t                bis.close();\n\t                bos.close();\n\t            }\n\t        }\n\t\n\t    }\n\t\n\t}\n\tH:键盘录入学生信息按照总分从高到低存储到文本文件\n\t\tpublic class CopyDemo {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Scanner sc = new Scanner(System.in);\n\t\t        //比较器返回-1降序，返回1升序\n\t\t        TreeSet<Student> studentList = new TreeSet<Student>(new Comparator<Student>() {\n\t\t            @Override\n\t\t            public int compare(Student o1, Student o2) {\n\t\t                int sum1 = o1.getChinese() + o1.getEnglish() + o1.getMath();\n\t\t                int sum2 = o2.getChinese() + o2.getEnglish() + o2.getMath();\n\t\t                if (sum1 > sum2) {\n\t\t                    return -1;\n\t\t                } else if (sum1 == sum2) {\n\t\t                    if (o1.getName().compareTo(o2.getName()) >=0 ) {\n\t\t                        return -1;\n\t\t                    } else {\n\t\t                        return 1;\n\t\t                    }\n\t\t                } else {\n\t\t                    return 1;\n\t\t                }\n\t\t            }\n\t\t        });\n\t\t        for (int i = 0; i < 3; i++) {\n\t\t            Student st = new Student();\n\t\t            System.out.println(\"请输入学生信息:\");\n\t\t            System.out.println(\"姓名: \");\n\t\t            st.setName(sc.nextLine());\n\t\t            System.out.println(\"语文: \");\n\t\t            st.setChinese(Integer.valueOf(sc.nextLine()));\n\t\t            System.out.println(\"数学: \");\n\t\t            st.setEnglish(Integer.valueOf(sc.nextLine()));\n\t\t            System.out.println(\"英语: \");\n\t\t            st.setMath(Integer.valueOf(sc.nextLine()));\n\t\t            studentList.add(st);\n\t\t        }\n\t\t        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(\"a.txt\")));\n\t\t        for (Student student : studentList) {\n\t\t            bw.write(\"name: \" + student.getName());\n\t\t            bw.newLine();\n\t\t            bw.write(\"chinese: \"+student.getChinese());\n\t\t            bw.newLine();\n\t\t            bw.write(\"english: \" + student.getEnglish());\n\t\t            bw.newLine();\n\t\t            bw.write(\"math: \"+student.getMath());\n\t\t            bw.newLine();\n\t\t            bw.write(\"---------------------\");\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t        bw.close();\n\t\t    }\n\t}\n\t\n\tclass Student {\n\t    private String name;\n\t    private int chinese;\n\t    private int math;\n\t    private int english;\n\t\n\t    public String getName() {\n\t        return name;\n\t    }\n\t\n\t    public void setName(String name) {\n\t        this.name = name;\n\t    }\n\t\n\t    public int getChinese() {\n\t        return chinese;\n\t    }\n\t\n\t    public void setChinese(int chinese) {\n\t        this.chinese = chinese;\n\t    }\n\t\n\t    public int getMath() {\n\t        return math;\n\t    }\n\t\n\t    public void setMath(int math) {\n\t        this.math = math;\n\t    }\n\t\n\t    public int getEnglish() {\n\t        return english;\n\t    }\n\t\n\t    public void setEnglish(int english) {\n\t        this.english = english;\n\t    }\n\t}\n\tI:把某个文件中的字符串排序后输出到另一个文本文件中\n\t\tFile srcFile = new File(\"a.txt\");\n\t    File destFile = new File(\"b.txt\");\n\t\n\t    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t    BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t    StringBuilder sb = new StringBuilder();\n\t    String s = null;\n\t    while ((s = br.readLine()) != null) {\n\t        sb.append(s);\n\t    }\n\t    char[] ch = sb.toString().toCharArray();\n\t    Arrays.sort(ch);\n\t    bw.write(ch);\n\t    bw.close();\n\t    br.close();\n\tJ:用Reader模拟BufferedReader的特有功能\n\tK:模拟LineNumberReader的特有功能\n# Java多线程\n\n## 1. 多线程(理解)\n\n\t(1)多线程：一个应用程序有多条执行路径\n\t\t进程：正在执行的应用程序\n\t\t线程：进程的执行单元，执行路径\n\t\t单线程：一个应用程序只有一条执行路径\n\t\t多线程：一个应用程序有多条执行路径\n\t\t\n\t\t多进程的意义?\n\t\t\t提高CPU的使用率\n\t\t多线程的意义?\n\t\t\t提高应用程序的使用率\n\t(2)Java程序的运行原理及JVM的启动是多线程的吗?\n\t\tA:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。\n\t\tB:JVM的启动是多线程的，因为它至少有两个线程启动了，主线程和垃圾回收线程。\n\t(3)多线程的实现方案(自己补齐步骤及代码\t掌握)\n\t\tA:继承Thread类\n\t\tpublic class MyThread extends Thread {\n\t\t    @Override\n\t\t    public void run() {\n\t\t        for (int i = 0; i < 10; i++) {\n\t\t            System.out.println(getName() + \":\" + i);\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class MyThreadTest {\n\t\t        public static void main(String[] args) {\n\t\t            MyThread mt = new MyThread();\n\t\t            mt.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t\tB:实现Runnable接口\n\t\tpublic class MyRunnable implements Runnable {\n\t\t    @Override\n\t\t    public void run() {\n\t\t        for (int i = 0; i < 10; i++) {\n\t\t            System.out.println(Thread.currentThread().getName() + \":\" + i);\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class MyRunnableTest {\n\t\t        public static void main(String[] args) {\n\t\t            MyRunnable mr = new MyRunnable();\n\t\t            Thread td = new Thread(mr);\n\t\t\n\t\t            td.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t(4)线程的调度和优先级问题\n\t\tA:线程的调度\n\t\t\ta:分时调度\n\t\t\tb:抢占式调度 (Java采用的是该调度方式)\n\t\tB:获取和设置线程优先级\n\t\t\ta:默认是5\n\t\t\tb:范围是1-10（Thread.MIN_PRIORITY，Thread.MAX_PRIORITY）\n\t(5)线程的控制(常见方法)\n\t\tA:休眠线程：sleep()\n\t\tB:加入线程：join()\n\t\tC:礼让线程：yield()\n\t\tD:后台线程：setDaemon()\n\t\tE:终止线程(掌握)：interrupt()\n\t(6)线程的生命周期(参照\t线程生命周期图解.bmp)\n\t\tA:新建\n\t\tB:就绪\n\t\tC:运行\n\t\tD:阻塞\n\t\tE:死亡\n![线程生命周期图解](https://img-blog.csdn.net/20181003115703845?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\t(7)电影院卖票程序的实现\n\t\tA:继承Thread类\n\t\tpublic class ThreadTicket extends Thread {\n\t\t    private static int ticket = 100;\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t       while (true) {\n\t\t            if (ticket > 0) {\n\t\t                System.out.println(getName() + \"正在售出第\" + ticket-- + \"张票\");\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class ThreadTicketTest {\n\t\t        public static void main(String[] args) {\n\t\t            ThreadTicket threadTicket = new ThreadTicket();\n\t\t            ThreadTicket threadTicket1 = new ThreadTicket();\n\t\t            ThreadTicket threadTicket2 = new ThreadTicket();\n\t\t\n\t\t            threadTicket.start();\n\t\t            threadTicket1.start();\n\t\t            threadTicket2.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t\tB:实现Runnable接口\n\t\tpublic class RunnableTicket implements Runnable {\n\t\t    private int ticket = 100;\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        while (true) {\n\t\t            if (ticket > 0) {\n\t\t                System.out.println(getName() + \"正在售出第\" + ticket-- + \"张票\");\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class RunnableTicketTest {\n\t\t        public static void main(String[] args) {\n\t\t            RunnableTicket rt = new RunnableTicket();\n\t\t            Thread thread = new Thread(rt);\n\t\t            Thread thread1 = new Thread(rt);\n\t\t            Thread thread2 = new Thread(rt);\n\t\t\n\t\t            thread.start();\n\t\t            thread1.start();\n\t\t            thread2.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t(8)电影院卖票程序出问题\n\t\tA:为了更符合真实的场景，加入了休眠100毫秒。\n\t\tB:卖票问题\n\t\t\ta:同票多次\n\t\t\tb:负数票\n\t(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)\n\t\tA:是否有多线程环境\n\t\tB:是否有共享数据\n\t\tC:是否有多条语句操作共享数据\n\t(10)同步解决线程安全问题\n\t\tA:同步代码块\n\t\t\tsynchronized(对象) {\n\t\t\t\t需要被同步的代码;\n\t\t\t}\n\t\t\t\n\t\t\t这里的锁对象可以是任意对象。\n\t\t\t\n\t\tB:同步方法\n\t\t\t把同步加在方法上。\n\t\t\t\n\t\t\t这里的锁对象是this\n\t\t\t\n\t\tC:静态同步方法\n\t\t\t把同步加在方法上。\n\t\t\t\n\t\t\t这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)\n\t(11)回顾以前的线程安全的类\n\t\tA:StringBuffer\n\t\tB:Vector\n\t\tC:Hashtable\n\t\tD:如何把一个线程不安全的集合类变成一个线程安全的集合类\n\t\t\t用Collections工具类的方法即可。\n\t\t\tList<String> list = Collections.synchronizedList(new ArrayList<String>());\n## 1. 多线程(理解)\n\n\t(1)JDK5以后的针对线程的锁定操作和释放操作\n\t\tLock锁\n\t\tpublic class RunnableTicket implements Runnable {\n\t\t    private int ticket = 100;\n\t\t    private ReentrantLock lock = new ReentrantLock();\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        while (true) {\n\t\t            lock.lock();\n\t\t            if (ticket > 0) {\n\t\t            System.out.println(Thread.currentThread().getName() + \"正在售出第\" + ticket-- + \"张票\");\n\t\t                try {\n\t\t                    Thread.sleep(100);\n\t\t                } catch (InterruptedException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t            }\n\t\t            lock.unlock();\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class RunnableTicketTest {\n\t\t        public static void main(String[] args) {\n\t\t            RunnableTicket rt = new RunnableTicket();\n\t\t            Thread thread = new Thread(rt);\n\t\t            Thread thread1 = new Thread(rt);\n\t\t            Thread thread2 = new Thread(rt);\n\t\t\n\t\t            thread.start();\n\t\t            thread1.start();\n\t\t            thread2.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t(2)死锁问题的描述和代码体现\n\tpublic class DeadLockDemo implements Runnable {\n\t\t    boolean flag;\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        if (flag) {\n\t\t            synchronized (Lock.object1) {\n\t\t                System.out.println(Thread.currentThread().getName() + \"获取了锁object1\");\n\t\t                try {\n\t\t                    Thread.sleep(100);\n\t\t                } catch (InterruptedException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t                synchronized (Lock.object2) {\n\t\t                    System.out.println(Thread.currentThread().getName() + \"获取了锁object2\");\n\t\t                }\n\t\t            }\n\t\t        } else {\n\t\t            synchronized (Lock.object2) {\n\t\t                System.out.println(Thread.currentThread().getName() + \"获取了锁object2\");\n\t\t                try {\n\t\t                    Thread.sleep(100);\n\t\t                } catch (InterruptedException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t                synchronized (Lock.object1) {\n\t\t                    System.out.println(Thread.currentThread().getName() + \"获取了锁object1\");\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static void main(String[] args) {\n\t\t        DeadLockDemo lockDemo = new DeadLockDemo();\n\t\t        DeadLockDemo lockDemo1 = new DeadLockDemo();\n\t\t        lockDemo.flag = true;\n\t\t        Thread td1 = new Thread(lockDemo);\n\t\t        Thread td2 = new Thread(lockDemo1);\n\t\t\n\t\t        td1.start();\n\t\t        td2.start();\n\t\t    }\n\t\t}\n\t\t\n\t\tclass Lock {\n\t\t    public static Object object1 = new Object();\n\t\t    public static Object object2 = new Object();\n\t\t}\n\t(3)生产者和消费者多线程体现(线程间通信问题)\n\t\t以学生作为资源来实现的\n\t\t\n\t\t资源类：Student\n\t\t设置数据类：SetThread(生产者)\n\t\t获取数据类：GetThread(消费者)\n\t\t测试类：StudentDemo\n\t\t\n\t\t代码：\n\t\t\tA:最基本的版本，只有一个数据。\n\t\t\t\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    String name;\n\t\t\t\t    int age;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        student.name = \"xmos\";\n\t\t\t\t        student.age = 23;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            System.out.println(student.name + \":\" + student.age);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tB:改进版本，给出了不同的数据，并加入了同步机制\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    String name;\n\t\t\t\t    int age;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t    private int x;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        while (true) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                if (x % 2 == 0) {\n\t\t\t\t                    student.name = \"xmos\";\n\t\t\t\t                    student.age = 23;\n\t\t\t\t                } else {\n\t\t\t\t                    student.name = \"tmos\";\n\t\t\t\t                    student.age = 22;\n\t\t\t\t                }\n\t\t\t\t\n\t\t\t\t                x++;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                System.out.println(student.name + \":\" + student.age);\n\t\t\t\t            }\n\t\t\t\t\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tC:等待唤醒机制改进该程序，让数据能够实现依次的出现\n\t\t\t\twait()\n\t\t\t\tnotify()\n\t\t\t\tnotifyAll() (多生产多消费)\n\t\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    String name;\n\t\t\t\t    int age;\n\t\t\t\t    boolean flag;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t    private int x;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        while (true) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                if (student.flag) {\n\t\t\t\t                    try {\n\t\t\t\t                        student.wait();\n\t\t\t\t                    } catch (InterruptedException e) {\n\t\t\t\t                        e.printStackTrace();\n\t\t\t\t                    }\n\t\t\t\t                }\n\t\t\t\t                if (x % 2 == 0) {\n\t\t\t\t                    student.name = \"xmos\";\n\t\t\t\t                    student.age = 23;\n\t\t\t\t                } else {\n\t\t\t\t                    student.name = \"tmos\";\n\t\t\t\t                    student.age = 22;\n\t\t\t\t                }\n\t\t\t\t                x++;\n\t\t\t\t                student.flag = true;\n\t\t\t\t                student.notify();\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                if (!student.flag) {\n\t\t\t\t                    try {\n\t\t\t\t                        student.wait();\n\t\t\t\t                    } catch (InterruptedException e) {\n\t\t\t\t                        e.printStackTrace();\n\t\t\t\t                    }\n\t\t\t\t                }\n\t\t\t\t                System.out.println(student.name + \":\" + student.age);\n\t\t\t\t                student.flag = false;\n\t\t\t\t                student.notify();\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tD:等待唤醒机制的代码优化。把数据及操作都写在了资源类中\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    private String name;\n\t\t\t\t    private int age;\n\t\t\t\t    private int x;\n\t\t\t\t    private boolean flag;\n\t\t\t\t\n\t\t\t\t    synchronized void setStudent() {\n\t\t\t\t        while (true) {\n\t\t\t\t            if (flag) {\n\t\t\t\t                try {\n\t\t\t\t                    wait();\n\t\t\t\t                } catch (InterruptedException e) {\n\t\t\t\t                    e.printStackTrace();\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t            if (x % 2 == 0) {\n\t\t\t\t                name = \"xmos\";\n\t\t\t\t                age = 23;\n\t\t\t\t            } else {\n\t\t\t\t                name = \"tmos\";\n\t\t\t\t                age = 22;\n\t\t\t\t            }\n\t\t\t\t            x++;\n\t\t\t\t            flag = true;\n\t\t\t\t            notify();\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    synchronized void getStudent() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            if (!flag) {\n\t\t\t\t                try {\n\t\t\t\t                    wait();\n\t\t\t\t                } catch (InterruptedException e) {\n\t\t\t\t                    e.printStackTrace();\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t            System.out.println(name + \":\" + age);\n\t\t\t\t            flag = false;\n\t\t\t\t            notify();\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        student.setStudent();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        student.getStudent();\n\t\t\t\t    }\n\t\t\t\t}\n\t(4)线程组\n\t\tpublic class ThreadGroupDemo {\n\t\t   public static void main(String[] args) {\n\t\t        ThreadGroup tg = new ThreadGroup(\"MyThreadGroup\");\n\t\t        MyRunnable mr = new MyRunnable();\n\t\t        Thread th1 = new Thread(tg, mr, \"xmos\");\n\t\t        Thread th2 = new Thread(tg, mr, \"tmos\");\n\t\t\n\t\t        th1.start();\n\t\t        th2.start();\n\t\t\n\t\t    }\n\t\t}\n\t\t\n\t\tclass MyRunnable implements Runnable {\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        System.out.println(Thread.currentThread().getThreadGroup().getName() + \":\" \n\t\t        \t+ Thread.currentThread().getName());\n\t\t    }\n\t\t}\n\t\t(5)线程池\n\t\t\tpublic class ThreadPoolDemo {\n\t\t\t    public static void main(String[] args) {\n\t\t\t        ExecutorService pool = Executors.newFixedThreadPool(3);\n\t\t\t        MyRunnable mr = new MyRunnable();\n\t\t\t        pool.submit(mr);\n\t\t\t        pool.submit(mr);\n\t\t\t\n\t\t\t        pool.shutdown();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass MyRunnable implements Runnable{\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void run() {\n\t\t\t        System.out.println(Thread.currentThread().getName());\n\t\t\t    }\n\t\t\t}\n\t(6)多线程实现的第三种方案\n\t\tpublic class ThreadPoolDemo {\n\t\t    public static void main(String[] args) {\n\t\t        ExecutorService pool = Executors.newFixedThreadPool(3);\n\t\t        MyCallable mc = new MyCallable();\n\t\t        pool.submit(mc);\n\t\t        pool.submit(mc);\n\t\t\n\t\t        pool.shutdown();\n\t\t    }\n\t\t}\n\t\t\n\t\tclass MyCallable implements Callable {\n\t\t    @Override\n\t\t    public Object call() throws Exception {\n\t\t        System.out.println(Thread.currentThread().getName());\n\t\t        return null;\n\t\t    }\n\t\t}\n\t(7)定时器\n\t\t案例1：\n\t\t\tpublic class TimerDemo {\n\t\t\t    public static void main(String[] args) throws ParseException {\n\t\t\t        Timer t = new Timer();\n\t\t\t        String s = new String(\"2018-10-03 12:46:00\");\n\t\t\t        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\t        Date date = sdf.parse(s);\n\t\t\t        t.schedule(new Boom(), date, 100);\n\t\t\t\n\t\t\t        t.cancel();\n\n\n​\t\t\t\n\t\t\t    }\n\t\t\t}\n\t\t\n\t\tclass Boom extends TimerTask {\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        System.out.println(\"Boom!\");\n\t\t    }\n\t\t}\n\t\t案例2：\n\t\t\tpublic class TimerDemo {\n\t\t\t    public static void main(String[] args) throws ParseException {\n\t\t\t        Timer t = new Timer();\n\t\t\t        t.schedule(new Boom(t), 300, 100);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Boom extends TimerTask {\n\t\t\t    private Timer t;\n\t\t\t    int i = 0;\n\t\t\t\n\t\t\t    public Boom(Timer t) {\n\t\t\t        this.t = t;\n\t\t\t    }\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void run() {\n\t\t\t        System.out.println(\"Boom---\" + ++i);\n\t\t\t\n\t\t\t        if (i == 30) {\n\t\t\t            t.cancel();\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t(8)多线程的面试题\n\t\t## 1. 多线程有几种实现方案，分别是哪几种?\n\t\t两种。\n\t\t\n\t\t继承Thread类\n\t\t实现Runnable接口\n\t\t\n\t\t扩展一种：实现Callable接口。这个得和线程池结合。\n\t\n\t\t## 2. 同步有几种方式，分别是什么?\n\t\t\t两种。\n\t\t\t\n\t\t\t同步代码块\n\t\t\t同步方法\n\t\t\n\t\t## 3. 启动一个线程是run()还是start()?它们的区别?\n\t\t\tstart();\n\t\t\t\n\t\t\trun():封装了被线程执行的代码,直接调用仅仅是普通方法的调用\n\t\t\tstart():启动线程，并由JVM自动调用run()方法\n\t\t\n\t\t## 4. sleep()和wait()方法的区别\n\t\t\tsleep():必须指时间;不释放锁。\n\t\t\twait():可以不指定时间，也可以指定时间;释放锁。\n\t\t\n\t\t## 5. 为什么wait(),notify(),notifyAll()等方法都定义在Object类中\n\t\t\t因为这些方法的调用是依赖于锁对象的，而同步代码块的锁对象是任意锁。\n\t\t\t而Object代码任意的对象，所以，定义在这里面。\n\t\t\n\t\t## 6. 线程的生命周期图\n\t\t\t新建 -- 就绪 -- 运行 -- 死亡\n\t\t\t新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡\n\t\t\t建议：画图解释。\n\n\n## 2. 设计模式(理解)\n\n\t(1)面试对象的常见设计原则\n\t\t单一\n\t\t开闭\n\t\t里氏\n\t\t依赖注入\n\t\t接口\n\t\t迪米特\n\t(2)设计模式概述和分类\n\t\tA:经验的总结\n\t\tB:三类\n\t\t\t创建型\n\t\t\t结构型\n\t\t\t行为型\n\t(3)改进的设计模式\n\t\tA:简单工厂模式（Simple Factory Pattern）\n\t\t\tpublic abstract class Animal {\n\t\t\t    public abstract void eat();\n\t\t\t\n\t\t\t    public static Animal getDog() {\n\t\t\t        return new Dog();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static Animal getCat() {\n\t\t\t        return new Cat();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static void main(String[] args) {\n\t\t\t        Animal dog = Animal.getDog();\n\t\t\t        Animal cat = Animal.getCat();\n\t\t\t\n\t\t\t        dog.eat();\n\t\t\t        cat.eat();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Dog extends Animal{\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat(){\n\t\t\t        System.out.println(\"eat bone\");\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Cat extends Animal{\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat() {\n\t\t\t        System.out.println(\"eat fish\");\n\t\t\t    }\n\t\t\t}\n\t\tB:工厂方法模式（Factory Method Pattern）\n\t\t\tpublic abstract class Animal {\n\t\t\t    public abstract void eat();\n\t\t\t\n\t\t\t    public static Animal getDog() {\n\t\t\t        return new Dog();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static Animal getCat() {\n\t\t\t        return new Cat();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static void main(String[] args) {\n\t\t\t        Animal dog = new DogFactory().getAnimal();\n\t\t\t        Animal cat = new CatFactory().getAnimal();\n\t\t\t\n\t\t\t        dog.eat();\n\t\t\t        cat.eat();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tinterface AnimalFactory {\n\t\t\t    Animal getAnimal();\n\t\t\t}\n\t\t\t\n\t\t\tclass DogFactory implements AnimalFactory {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public Animal getAnimal() {\n\t\t\t        return new Dog();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass CatFactory implements AnimalFactory {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public Animal getAnimal() {\n\t\t\t        return new Cat();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Dog extends Animal {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat() {\n\t\t\t        System.out.println(\"eat bone\");\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Cat extends Animal {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat() {\n\t\t\t        System.out.println(\"eat fish\");\n\t\t\t    }\n\t\t\t}\n\t\tC:单例模式(Singleton Pattern掌握)\n\t\t\ta:饿汉式（开发常用）\n\t\t\t\tpublic class TeacherDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Teacher t1 = Teacher.getTeacher();\n\t\t\t\t        Teacher t2 = Teacher.getTeacher();\n\t\t\t\t\n\t\t\t\t        System.out.println(t1 == t2);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Teacher {\n\t\t\t\t    private static Teacher teacher = new Teacher();\n\t\t\t\t\n\t\t\t\t    private Teacher() {\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    public static Teacher getTeacher() {\n\t\t\t\t        return teacher;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tb:懒汉式（面试常用，容易有线程安全问题，需要线程同步）\n\t\t\t\tpublic class StudentDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student s1 = Student.getStudent();\n\t\t\t\t        Student s2 = Student.getStudent();\n\t\t\t\t\n\t\t\t\t        System.out.println(s1 == s2);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    private static Student student = null;\n\t\t\t\t\n\t\t\t\t    private Student() {\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    public synchronized static Student getStudent() {\n\t\t\t\t        if (Objects.isNull(student)) {\n\t\t\t\t            student = new Student();\n\t\t\t\t        }\n\t\t\t\t        return student;\n\t\t\t\t    }\n\t\t\t\t}\n\t(4)Runtime\n\t\tJDK提供的一个单例模式应用的类。\n\t\t还可以调用系统命令。\n\t\tpublic class RuntimeDemo {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Runtime r = Runtime.getRuntime();\n\t\t        r.exec(\"touch 1.txt\");\n\t\t    }\n\t\t}\n\n# JavaGUI\n\n# Java网络编程\n\n## 1. 网络编程(理解)\n```java\n(1)网络编程：用Java语言实现计算机间数据的信息传递和资源共享\n(2)网络编程模型\n\t应用层-表示层-会话层-传输层-网络层-数据链路层-物理层\n(3)网络编程的三要素\n\tA:IP地址\n\t\ta:点分十进制：192.168.1.1\n\t\tb:IP地址的组成：网络号段+主机号段\n\t\tc:IP地址的分类：\n\t\t\tA类\t1.0.0.1---127.255.255.254\t\n\t\t\t\t(1)10.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t(2)127.X.X.X是保留地址，用做循环测试用的。\n\t\t\tB类\t128.0.0.1---191.255.255.254\t172.16.0.0---172.31.255.255是私有地址。169.254.X.X是保留地址。\n\t\t\tC类\t192.0.0.1---223.255.255.254\t192.168.X.X是私有地址\n\t\t\tD类\t224.0.0.1---239.255.255.254 \t\n\t\t\tE类\t240.0.0.1---247.255.255.254\n\t\td:dos命令\n\t\t\tipconfig; telnet; ping\n\t\te:InetAddress\n\t\t\tpublic class IPDemo {\n\t\t\t    public static void main(String[] args) throws UnknownHostException {\n\t\t\t        InetAddress ip = InetAddress.getByName(\"192.168.2.203\");\n\t\t\t        System.out.println(ip.getHostName() + \":\" + ip.getHostAddress());\n\t\t\t    }\n\t\t\t}\n\tB:端口\n\t\t是应用程序的标识。范围：0-65535。其中0-1024不建议使用。\n\tC:协议\n\t\tUDP:数据打包,有限制,不连接,效率高,不可靠\n\t\tTCP:建立数据通道,无限制,效率低,可靠\n(3)Socket机制\n\tA:通信两端都应该有Socket对象\n\tB:所有的通信都是通过Socket间的IO进行操作的\n(4)UDP协议发送和接收数据(掌握 自己补齐代码)\n\t发送：\n\t\t创建UDP发送端的Socket对象\n\t\t创建数据并把数据打包\n\t\t发送数据\n\t\t释放资源\n\t接收：\n\t\t创建UDP接收端的Socket对象\n\t\t创建数据包用于接收数据\n\t\t接收数据\n\t\t解析数据包\n\t\t释放资源\n\t\t\n(5)TCP协议发送和接收数据(掌握 自己补齐代码)\n\t发送：\n\t\t创建TCP客户端的Socket对象\n\t\t获取输出流，写数据\n\t\t释放资源\n\t\t\n\t接收：\n\t\t创建TCP服务器端的Socket对象\n\t\t监听客户端连接\n\t\t获取输入流，读取数据\n\t\t释放资源\n(6)案例：\n\tA:UDP\n\t\ta:最基本的UDP协议发送和接收数据\n\t\tb:把发送数据改进为键盘录入\n\t\t发送端：\n\t\tpublic class SendSocket {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        //设置socket发送的端口号，不设置的则为随机端口号\n\t\t        DatagramSocket ds = new DatagramSocket(12307);\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t        String s = null;\n\t\t        while ((s = br.readLine()) != null) {\n\t\t            if (Objects.equals(s, \"bye\")) {\n\t\t                break;\n\t\t            }\n\t\t            byte[] bytes = s.getBytes();\n\t\t            DatagramPacket dp = new DatagramPacket(\n\t\t            \tbytes, bytes.length, InetAddress.getByName(\"192.168.2.203\"), 12306);\n\t\t            ds.send(dp);\n\t\t        }\n\t\t        ds.close();\n\t\t    }\n\t\t}\n\t\t接收端：\n\t\tpublic class ReceiveSocket {\n\t\t\t\t\t    public static void main(String[] args) throws IOException {\n\t\t\t\t\t        //设置socket接收的端口号\n\t\t\t\t\t        DatagramSocket ds = new DatagramSocket(12306);\n\t\t\t\t\t        while (true) {\n\t\t\t\t\t            byte[] bytes = new byte[1024];\n\t\t\t\t\t            DatagramPacket dp = new DatagramPacket(bytes, bytes.length);\n\t\t\t\t\t            ds.receive(dp);\n\t\t\t\t\t            String s = new String(dp.getData(), 0, dp.getLength());\n\t\t\t\t\t            System.out.println(dp.getAddress().getHostAddress() + \":\" + dp.getPort() + \"\\n\" + s);\n\t\t\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\tc:一个简易聊天小程序并用多线程改进\n\t\tpublic class ChatRoom {\n\t\t    public static void main(String[] args) {\n\t\t        Thread sendThread = new Thread(new Runnable() {\n\t\t            @Override\n\t\t            public void run() {\n\t\t                try {\n\t\t                    DatagramSocket ds = new DatagramSocket(12307);\n\t\t                    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t                    String s = null;\n\t\t                    while ((s = br.readLine()) != null) {\n\t\t                        if (Objects.equals(s, \"bye\")) {\n\t\t                            break;\n\t\t                        }\n\t\t                        byte[] bytes = s.getBytes();\n\t\t                        DatagramPacket dp = new DatagramPacket(\n\t\t                        \tbytes, bytes.length, InetAddress.getByName(\"192.168.2.203\"), 12306);\n\t\t                        ds.send(dp);\n\t\t                    }\n\t\t                    ds.close();\n\t\t                } catch (IOException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t            }\n\t\t        });\n\t\t        Thread receiveThread = new Thread(new Runnable() {\n\t\t            @Override\n\t\t            public void run() {\n\t\t                try {\n\t\t                    DatagramSocket ds = new DatagramSocket(12306);\n\t\t                    while (true) {\n\t\t                        byte[] bytes = new byte[1024];\n\t\t                        DatagramPacket dp = new DatagramPacket(bytes, bytes.length);\n\t\t                        ds.receive(dp);\n\t\t                        String s = new String(dp.getData(), 0, dp.getLength());\n\t\t                        System.out.println(dp.getAddress().getHostAddress() + \":\" + dp.getPort() + \"\\n\" + s);\n\t\t                    }\n\t\t                } catch (IOException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t            }\n\t\t        });\n\t\t\n\t\t        sendThread.start();\n\t\t        receiveThread.start();\n\t\t    }\n\t\t}\n\tB:TCP\n\t\ta:最基本的TCP协议发送和接收数据\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"192.168.2.203\", 8809);\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t        \n\t\t        bw.write(\"hello tcp\");\n\t\t        bw.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket server = new ServerSocket(8809);\n\t\t        Socket s = server.accept();\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        System.out.println(br.readLine());\n\t\t        br.close();\n\t\t    }\n\t\t}\n\t\tb:服务器给出反馈\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"192.168.2.203\", 8809);\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t\n\t\t        bw.write(\"hello tcp\");\n\t\t        bw.flush();\n\t\t\n\t\t        //给服务端发送停止写入的信号，否则服务端会一直阻塞\n\t\t        client.shutdownOutput();\n\t\t\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\n\t\t        System.out.println(br.readLine());\n\t\t\n\t\t        bw.close();\n\t\t        br.close();\n\t\t        client.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket server = new ServerSocket(8809);\n\t\t        Socket s = server.accept();\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        System.out.println(br.readLine());\n\t\t\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n\t\t        bw.write(\"已收到\");\n\t\t        bw.flush();\n\t\t\n\t\t        bw.close();\n\t\t        br.close();\n\t\t        server.close();\n\t\t        server.close();\n\t\t    }\n\t\t}\n\t\tc:客户端键盘录入服务器控制台输出\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"192.168.2.203\", 8809);\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t\n\t\t        String s = null;\n\t\t        while ((s = br.readLine()) != null) {\n\t\t            if (Objects.equals(s, \"bye\")) {\n\t\t                break;\n\t\t            }\n\t\t            bw.write(s);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        //给服务端发送停止写入的信号，否则服务端会一直阻塞\n\t\t        client.shutdownOutput();\n\t\t\n\t\t        br.close();\n\t\t        bw.close();\n\t\t        client.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket server = new ServerSocket(8809);\n\t\t        Socket s = server.accept();\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        String client = null;\n\t\t        while ((client = br.readLine()) != null) {\n\t\t            System.out.println(client);\n\t\t        }\n\t\t\n\t\t        br.close();\n\t\t        s.close();\n\t\t        server.close();\n\t\t    }\n\t\t}\n\t\td:客户端键盘录入服务器写到文本文件\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket s = new Socket(\"192.168.2.203\",8809);\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n\t\t\n\t\t        String msg = null;\n\t\t        while ((msg = br.readLine()) != null){\n\t\t            if (Objects.equals(msg, \"bye\")) {\n\t\t                break;\n\t\t            }\n\t\t            bw.write(msg);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        s.shutdownOutput();\n\t\t\n\t\t        BufferedReader br1 = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t        System.out.println(br1.readLine());\n\t\t\n\t\t        br.close();\n\t\t        br1.close();\n\t\t        bw.close();\n\t\t        s.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket ss = new ServerSocket(8809);\n\t\t        Socket s = ss.accept();\n\t\t\n\t\t        BufferedWriter bw = new BufferedWriter(new FileWriter(\"test.txt\"));\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        String msg = null;\n\t\t        while ((msg = br.readLine()) != null) {\n\t\t            bw.write(msg);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        BufferedWriter bw1 = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n\t\t        bw1.write(\"已全部接收！\");\n\t\t        bw1.newLine();\n\t\t        bw1.flush();\n\t\t\n\t\t        br.close();\n\t\t        bw.close();\n\t\t        bw1.close();\n\t\t        s.close();\n\t\t        ss.close();\n\t\t    }\n\t\t}\n\t\te:客户端读取文本文件服务器控制台输出\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"localhost\", 8808);\n\t\t\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"1.txt\")));\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t\n\t\t        String s = null;\n\t\t        while ((s = br.readLine()) != null) {\n\t\t            bw.write(s);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        bw.close();\n\t\t        br.close();\n\t\t        client.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t\tpublic static void main(String[] args) throws IOException {\n\t\t\t\tServerSocket server = new ServerSocket(8808);\n\n\t\t\t\tSocket client = server.accept();\n\n\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\n\n\t\t\t\tString s = null;\n\t\t\t\twhile ((s = br.readLine()) != null) {\n\t\t\t\t\tSystem.out.println(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\tf:客户端读取文本文件服务器写到文本文件\n\t\tg:上传图片\n\t\th:多线程改进上传文件\n```\n# Java反射\n## 1. 反射(理解)\n```java\n(1)类的加载及类加载器\n(2)反射：\n\t通过字节码文件对象，去使用成员变量，构造方法，成员方法\n(3)反射的使用\n\tA:通过反射获取构造方法并使用\n\tB:通过反射获取成员变量并使用\n\tC:通过反射获取成员方法并使用\n(4)反射案例\n\tA:通过反射运行配置文件的内容\n\tB:通过反射越过泛型检查\n\tC:通过反射给任意的一个对象的任意的属性赋值为指定的值\n(5)动态代理\n```\n## 2. 设计模式\n```java\n(1)装饰设计模式\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\n\tScanner sc = new Scanner(System.in);\n(2)模版设计模式\n```\n## 3. JDK新特性\n```java\n(1)JDK5(掌握)\n\t装箱和拆箱\n\t泛型\n\t增强for\n\t静态导入\n\t可变参数\n\t枚举\n(2)JDK6(了解)\n(3)JDK7(理解)\n\t二进制的表现形式\n\t用_分隔数据\n\tswitch语句可是用字符串\n\t泛型推断(菱形泛型)\n\t多catch的使用\n\t自动释放资源的用法\n(4)JDK8(了解)\n\t可以去网上了解资料\n```","source":"_posts/Java学习笔记.md","raw":"---\ntitle: Java学习笔记\ndate: 2018-12-05 16:18:01\ntags: 学习笔记\n---\n\n# 计算机的基础知识\n\n## 1. 计算机概述(了解)\n```java\n(1)计算机\n(2)计算机硬件\n(3)计算机软件\n\t系统软件：window,linux,mac\n\t应用软件：qq,yy,飞秋\n(4)软件开发(理解)\n\t软件：是由数据和指令组成的。(计算器)\n\t开发：就是把软件做出来。\n\t如何实现软件开发呢?\n\t\t就是使用开发工具和计算机语言做出东西来\n(5)语言\n\t自然语言：人与人交流沟通的\n\t计算机语言：人与计算机交流沟通的\n\t\tC,C++,C#,Java\n(6)人机交换\n\t图形界面：操作方便只管\n\tDOS命令：需要记忆一些常见的命令\n```\n## 2. 键盘功能键的认识和快捷键(掌握)\n```java\n(1)功能键的认识\n\ttab\n\tshift\n\tctrl\n\talt\n\twindos\n\t空格\n\t上下左右\n\t回车\n\t截图\n(2)快捷键\n\t全选\tCtrl+A\n\t复制\tCtrl+C\n\t粘贴\tCtrl+V\n\t剪切\tCtrl+X\n\t撤销\tCtrl+Z\n\t保存\tCtrl+S\n```\n\n## 3. 常见的DOS命令(掌握)\n```java\n(1)常见的如下\n\t盘符的切换\n\t\td:回车\n\t目录的进入\n\t\tcd javase\n\t\tcd javase\\day01\\code\n\t目录的回退\n\t\tcd..\n\t\tcd\\\n\t清屏\n\t\tcls\n\t退出\n\t\texit\n(2)其他的几个(了解)\n\t创建目录\n\t\tmkdir\n\t删除目录\n\t\trmdir\n\t创建文件\n\t\tedit\n\t删除文件\n\t\tdel\n\t显示目录下的内容\n\t\tdir\n\t删除带内容的目录\n\t\trd /s/q\n```\n## 4. Java语言概述(了解)\n```java\n(1)Java语言的发展史\n\tJava之父\n\tJDK1.4.2\n\tJDK5\n\tJDK7\n(2)Java语言的特点\n\t有很多小特点，重点有两个开源，跨平台\n(3)Java语言是跨平台的，请问是如何保证的呢?(理解)\n\t我们是通过翻译的案例讲解的。\n\t\n\t针对不同的操作系统，提供不同的jvm来实现的。\n(4)Java语言的平台\n\tJavaSE\n\tJavaME--Android\n\tJavaEE\n```\n## 5. JDK,JRE,JVM的作用及关系(掌握)\n```java\n(1)作用\n\tJVM：保证Java语言跨平台\n\tJRE：Java程序的运行环境\n\tJDK：Java程序的开发环境\n(2)关系\n\tJDK：JRE+工具\n\tJRE：JVM+类库\n```\n## 6. JDK的下载,安装,卸载(掌握)\n```java\n(1)下载到官网。\n\tA:也可以到百度搜索即可。\n\tB:我给你。\n(2)安装\n\tA:绿色版\t解压就可以使用\n\tB:安装版\t必须一步一步的安装，一般只要会点击下一步即可\n\t\n\t注意：\n\t\t建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。\n(3)卸载\n\tA:绿色版\t直接删除文件夹\n\tB:安装版\t\n\t\ta:控制面板 -- 添加删除程序\n\t\tb:通过专业的软件卸载工具。(比如360的软件管家卸载)\n```\n## 7. 第一个程序：HelloWorld案例(掌握)\n```java\nclass HelloWorld {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"HelloWorld\");\n\t}\n}\n\n(1)程序解释：\n\tA:Java程序的最基本单位是类，所以我们要定义一个类。\n\t\t格式：class 类名\n\t\t举例：class HelloWorld\n\tB:在类中写内容的时候，用大括号括起来。\n\tC:Java程序要想执行，必须有main方法。\n\t\t格式：public static void main(String[] args)\n\tD:要指向哪些东西呢，也用大括号括起来。\n\tE:你要做什么呢?今天我们仅仅做了一个简单的输出\n\t\t格式：System.out.println(\"HelloWorld\");\n\t\t注意：\"\"里面的内容是可以改动的。\n\n(2)Java程序的开发执行流程：\n\tA:编写java源程序(.java)\n\tB:通过javac命令编译生成.class文件\n\tC:通过java命令运行.class文件\n```\n## 8. 常见的问题(掌握)\n```java\n(1)扩展名被隐藏\n\t如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾\n(2)我要求文件名称和类名一致。\n\t实际上不这样做也是可以的。\n\t但是，注意：\n\t\tjavac后面跟的是文件名+扩展名\n\t\tjava后面跟的类名不带扩展名\n(3)Java语言严格区分大小写，请注意。\n\t 还有就是单词不要写错了。\n(4)见到非法字符: \\65307肯定是中文问题。\n\t我们写程序要求标点符号必须全部是英文状态。\n(5)括号的配对问题。\n\t一般来说，括号都是成对出现的。\n(6)遇到\n\t在类 HelloWorld 中找不到主方法, 请将主方法定义为\n\tpublic static void main(String[] args)\n\t肯定是主方法的格式问题。\n```\n## 9. path环境变量(掌握)\n```java\n(1)path环境变量的作用\n\t保证javac命令可以在任意目录下运行。\n\t同理可以配置qq等\n(2)path配置的两种方案：\n\tA:方案1(了解)\n\tB:方案2\n\t\t找到环境变量的位置，在系统变量里面\n\t\t新建：\n\t\t\t变量名：JAVA_HOME\n\t\t\t变量值：D:\\develop\\Java\\jdk1.7.0_60\n\t\t修改：\n\t\t\t变量名：Path\n\t\t\t变量值：%JAVA_HOME%\\bin;以前的内容\n```\n## 10. classpath环境变量(理解)\n```java\n(1)classpath环境变量的作用\n\t保证class文件可以在任意目录下运行\n(2)classpath环境变量的配置\n\t找到环境变量的位置，在系统变量里面\n\t新建：\n\t\t变量名：classpath\n\t\t变量值：E:\\JavaSE\\day01\\code\\HelloWorld案例\n```\n# Java语言基础\n\n## 1. 关键字(掌握)\n```java\n(1)被Java语言赋予特定含义的单词\n(2)特点：\n\t全部小写。\n(3)注意事项：\n\tA:goto和const作为保留字存在。\n\tB:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记\n```\n## 2. 标识符(掌握)\n```java\n(1)就是给类，接口，方法，变量等起名字的字符序列\n(2)组成规则：\n\tA:英文大小写字母\n\tB:数字\n\tC:$和_\n(3)注意事项：\n\tA:不能以数字开头\n\tB:不能是java中的关键字\n\tC:区分大小写\n(4)常见的命名规则(见名知意)\n\tA:包\t全部小写\n\t\t单级包：小写\n\t\t\t举例：liuyi,com\n\t\t多级包：小写，并用.隔开\n\t\t\t举例：cn.itcast,com.baidu\t\t\t\t\n\tB:类或者接口\n\t\t一个单词：首字母大写\n\t\t\t举例：Student,Demo\n\t\t多个单词：每个单词首字母大写\n\t\t\t举例：HelloWorld,StudentName\n\tC:方法或者变量\n\t\t一个单词：首字母小写\n\t\t\t举例：name,main\n\t\t多个单词：从第二个单词开始，每个单词首字母大写\n\t\t\t举例：studentAge,showAllNames()\n\tD:常量\n\t\t全部大写\n\t\t一个单词：大写\n\t\t\t举例：PI\n\t\t多个单词：大写，并用_隔开\n\t\t\t举例：STUDENT_MAX_AGE\n```\n## 3. 注释(掌握)\n```java\n(1)就是对程序进行解释说明的文字\n(2)分类：\n\tA:单行注释\t//\n\tB:多行注释\t/**/\n\tC:文档注释(后面讲) /** */\n(3)把HelloWorld案例写了一个带注释的版本。\n\t后面我们要写一个程序的过程。\n\t需求：\n\t分析：\n\t实现：\n\t代码体现：\n(4)注释的作用\n\tA:解释说明程序，提高了代码的阅读性。\n\tB:可以帮助我们调试程序。\n\t\t后面我们会讲解一个更高端的一个调试工具\n```\n\n## 4. 常量(掌握)\n```java\n(1)在程序执行的过程中，其值不发生改变的量\n(2)分类：\n\tA:字面值常量\n\tB:自定义常量(后面讲)\n(3)字面值常量\n\tA:字符串常量 \"hello\"\n\tB:整数常量\t12,23\n\tC:小数常量\t12.345\n\tD:字符常量\t'a','A','0'\n\tE:布尔常量\ttrue,false\n\tF:空常量\tnull(后面讲)\n(4)在Java中针对整数常量提供了四种表现形式\n\tA:二进制\t由0，1组成。以0b开头。\n\tB:八进制\t由0，1，...7组成。以0开头。\n\tC:十进制\t由0，1，...9组成。整数默认是十进制。\n\tD:十六进制\t由0，1，...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。\n```\n## 5. 进制转换(了解)\n```java\n(1)其他进制到十进制\n\t系数：就是每一个位上的数值\n\t基数：x进制的基数就是x\n\t权：对每一个位上的数据，从右，并且从0开始编号，对应的编号就是该数据的权。\n\t\n\t结果：系数*基数^权次幂之和。\n(2)十进制到其他进制\n\t除基取余，直到商为0，余数反转。\n(3)进制转换的快速转换法\n\tA:十进制和二进制间的转换\n\t\t8421码。\n\tB:二进制到八进制，十六进制的转换\n```\n## 6. 变量(掌握)\n```java\n(1)在程序的执行过程中，其值在某个范围内可以发生改变的量\n(2)变量的定义格式：\n\tA:数据类型 变量名 = 初始化值;\n\tB:数据类型 变量名;\n\t  变量名 = 初始化值;\n```\n## 7. 数据类型(掌握)\n\n\t(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。\n\t(2)分类：\n\t\tA:基本数据类型：4类8种\n\t\tB:引用数据类型：类，接口，数组。\n\t(3)基本数据类型\n\t\tA:整数\t\t\t占用字节数\n\t\t\tbyte\t\t\t1\n\t\t\tshort\t\t\t2\n\t\t\tint \t\t\t4\n\t\t\tlong\t\t\t8\n\t\tB:浮点数\n\t\t\tfloat\t\t\t4\n\t\t\tdouble\t\t\t8\n\t\tC:字符\n\t\t\tchar\t\t\t2\n\t\tD:布尔\n\t\t\tboolean\t\t\t1\n\t\t\t\n\t\t注意：\n\t\t\t整数默认是int类型，浮点数默认是double。\n\t\t\t\n\t\t\t长整数要加L或者l。\n\t\t\t单精度的浮点数要加F或者f。\n\n\n## 8. 数据类型转换(掌握)\n\n\t(1)boolean类型不参与转换\n\t(2)默认转换\n\t\tA:从小到大\n\t\tB:byte,short,char -- int -- long -- float -- double\n\t\tC:byte,short,char之间不相互转换，直接转成int类型参与运算。\n\t(3)强制转换\n\t\tA:从大到小\n\t\tB:可能会有精度的损失，一般不建议这样使用。\n\t\tC:格式：\n\t\t\t目标数据类型 变量名 = (目标数据类型) (被转换的数据);\n\t(4)思考题和面试题：\n\t\tA:下面两种方式有区别吗?\n\t\t\t\n\t\t\tfloat f1 = 12.345f;//本来就是float\n\t\t\tfloat f2 = (float)12.345;//double转float\n\t\n\t\tB:下面的程序有问题吗，如果有，在哪里呢?\n\t\t\t\n\t\t\tbyte b1 = 3;\n\t\t\tbyte b2 = 4;\n\t\t\tbyte b3 = b1 + b2;//b1+b2是int,需要强转(byte)(b1 + b2)\n\t\t\tbyte b4 = 3 + 4;//会先判断3+4的值是否在byte区间内,区间内就没问题\n\t\n\t\tC:下面的操作结果是什么呢?\n\t\t\tbyte b = (byte)130;//-126\n\t\t\t\n\t\tD:字符参与运算\n\t\t\t是查找ASCII里面的值\n\t\t\t'a'\t\t97\n\t\t\t'A'\t\t65\n\t\t\t'0'\t\t48\n\t\n\t\t\tSystem.out.println('a');//a\n\t\t\tSystem.out.println('a' + 1);//98\n\t\n\t\tE:字符串参与运算\n\t\t\t这里其实是字符串的连接\t\t\n\t\n\t\t\tSystem.out.println(\"hello\"+'a'+1);//helloa1\n\t\t\tSystem.out.println('a'+1+\"hello\");//98hello\n\t\t\tSystem.out.println(\"5+5=\"+5+5);//5+5=55\n\t\t\tSystem.out.println(5+5+\"=5+5\");//10=5+5\n\n## 1. 运算符(掌握)\n\n\t(1)算术运算符\n\t\tA:+,-,*,/,%,++,--\n\t\tB:+的用法\n\t\t\ta:加法\n\t\t\tb:正号\n\t\t\tc:字符串连接符\n\t\tC:/和%的区别\n\t\t\t数据做除法操作的时候，/取得是商，%取得是余数\n\t\tD:++和--的用法\n\t\t\ta:他们的作用是自增或者自减\n\t\t\tb:使用\n\t\t\t\t**单独使用\n\t\t\t\t\t放在操作数据的前面和后面效果一样。\n\t\t\t\t\ta++或者++a效果一样。\n\t\t\t\t**参与操作使用\n\t\t\t\t\t放在操作数的前面：先自增或者自减，再参与操作\n\t\t\t\t\t\tint a = 10;\n\t\t\t\t\t\tint b = ++a;\n\t\t\t\t\t放在操作数的后面：先参与操作，再自增或者自减\n\t\t\t\t\t\tint a = 10;\n\t\t\t\t\t\tint b = a++;\n\t(2)赋值运算符\n\t\tA:=,+=,-=,*=,/=,%=等\n\t\tB:=叫做赋值运算符，也是最基本的赋值运算符\n\t\t\tint x = 10; 把10赋值给int类型的变量x。\n\t\tC:扩展的赋值运算符的特点\n\t\t\t隐含了自动强制转换。\n\t\t\t\n\t面试题：\n\t\n\tshort s = 1;\n\ts = s + 1;//有问题,需要强转(short)(s + 1)\n\t\n\tshort s = 1;\n\ts += 1;//没问题,隐含了自动强制转换\n\t\n\t请问上面的代码哪个有问题?\n\t\n\t(3)比较运算符\n\t\tA:==,!=,>,>=,<,<=\n\t\tB:无论运算符两端简单还是复杂最终结果是boolean类型。\n\t\tC:千万不要把==写成了=\n\t(4)逻辑运算符\n\t\tA:&,|,^,!,&&,||\n\t\tB:逻辑运算符用于连接boolean类型的式子\n\t\tC:结论\n\t\t\t&:有false则false\n\t\t\t|:有true则true\n\t\t\t^:相同则false，不同则true。\n\t\t\t\t情侣关系。\n\t\t\t!:非true则false，非false则true\n\t\t\t\n\t\t\t&&:结果和&是一样的，只不过有短路效果。左边是false，右边不执行。\n\t\t\t||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。\n\t(5)位运算符(了解)\n\t\tA:^的特殊用法\n\t\t\t一个数据针对另一个数据位异或两次，该数不变\n\t\tB:面试题\n\t\t\ta:请实现两个变量的交换\n\t\t\t\t**采用第三方变量\n\t\t\t\t**用位异或运算符\n\t\t\t\t\t左边a,b,a\n\t\t\t\t\t右边a^b\n\t\t\tb:请用最有效率的方式计算出2乘以8的结果\n\t\t\t\t2<<3\n\t(6)三元运算符\n\t\tA:格式\n\t\t\t比较表达式?表达式1:表达式2;\n\t\tB:执行流程：\n\t\t\t首先计算比较表达式的值，看是true还是false。\n\t\t\t如果是true，表达式1就是结果。\n\t\t\t如果是false，表达式2就是结果。\n\t\tC:案例：\n\t\t\ta:比较两个数据是否相等\n\t\t\t\tSystem.out.println(a == b ? true : false);\n\t\t\tb:获取两个数据中的最大值\n\t\t\t\tSystem.out.println(a > b ? a : b);\n\t\t\tc:获取三个数据中的最大值\n\t\t\t\tSystem.out.println((a>b?a:b)>c?(a>b?a:b):c);\n## 2. 键盘录入(掌握)\n\n\t(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。\n\t(2)如何实现呢?目前就记住\n\t\tA:导包\n\t\t\timport java.util.Scanner;\n\t\t\t位置：在class的上边\n\t\tB:创建对象\n\t\t\tScanner sc = new Scanner(System.in);\n\t\tC:获取数据\n\t\t\tint x = sc.nextInt();\n\t(3)把三元运算符的案例加入键盘录入改进。\n\t\tScanner sc = new Scanner(System.in);\n\t    int a = sc.nextInt();\n\t    int b = sc.nextInt();\n\t    System.out.println(a > b ? a : b);\n\n## 3. 流程控制语句\n\n\t(1)顺序结构 从上往下，依次执行\n\t(2)选择结构\t按照不同的选择，执行不同的代码\n\t(3)循环结构 做一些重复的代码\n\n\n## 4. if语句(掌握)\n\n\t(1)三种格式\n\t\tA:格式1\n\t\t\tif(比较表达式) {\n\t\t\t\t语句体;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\t判断比较表达式的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体\n\t\t\t\t如果是false，就不执行语句体\n\t\t\n\t\tB:格式2\n\t\t\tif(比较表达式) {\n\t\t\t\t语句体1;\n\t\t\t}else {\n\t\t\t\t语句体2;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\t判断比较表达式的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体1\n\t\t\t\t如果是false，就执行语句体2\n\t\t\t\t\n\t\tC:格式3\n\t\t\tif(比较表达式1) {\n\t\t\t\t语句体1;\n\t\t\t}else if(比较表达式2){\n\t\t\t\t语句体2;\n\t\t\t}\n\t\t\t...\n\t\t\telse {\n\t\t\t\t语句体n+1;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\t判断比较表达式1的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体1\n\t\t\t\t如果是false，就继续判断比较表达式2的值，看是true还是false\n\t\t\t\t如果是true，就执行语句体2\n\t\t\t\t如果是false，就继续判断比较表达式3的值，看是true还是false\n\t\t\t\t...\n\t\t\t\t如果都不满足，就执行语句体n+1\n\t(2)注意事项\n\t\tA:比较表达式无论简单还是复杂，结果是boolean类型\n\t\tB:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。\n\t\t\t建议：永远不要省略。\n\t\tC:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。\n\t\tD:else后面如果没有if，是不会出现比较表达式的。\n\t\tE:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。\n\t(3)案例：\n\t\tA:比较两个数是否相等\n\t\t\t\n\t\t\tif (a == b) {\n\t\t\t    System.out.println(\"a == b\");\n\t\t    }\n\t\n\t\tB:获取两个数中的最大值\n\t\t\t\n\t\t\tif (a > b) {\n\t            System.out.println(a);\n\t\t    } else if (a < b) {\n\t\t        System.out.println(b);\n\t\t    }\n\t\n\t\tC:获取三个数中的最大值(if语句的嵌套)\n\t\t\tif (a > b) {\n\t            if (a > c) {\n\t                System.out.println(a);\n\t            } else if (c > a) {\n\t                System.out.println(c);\n\t            } else if (b > a) {\n\t\t            if (b > c) {\n\t\t                System.out.println(b);\n\t\t            } else if (c > b) {\n\t\t                System.out.println(c);\n\t\t            }\n\t\t        }\n\t\n\t\tD:根据成绩输出对应的等级\n\t\t\tif (score > 0 && score < 60) {\n\t            System.out.println(\"不及格\");\n\t        } else if (score >= 60 && score < 90) {\n\t            System.out.println(\"合格\");\n\t        } else if (score >= 90 && score <= 100) {\n\t            System.out.println(\"优秀\");\n\t        }\n\t\tE:根据月份，输出对应的季节\n\t\tF:根据x计算对应y的值并输出\n\t(4)三元运算符和if语句第二种格式的关系\n\t\t所有的三元运算符能够实现的，if语句的第二种格式都能实现。\n\t\t反之不成立。\n\t\t\n\t\t如果if语句第二种格式控制的语句体是输出语句，就不可以。\n\t\t因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。\n\n## 1. switch语句(掌握)\n\n\t(1)格式：\n\t\tswitch(表达式) {\n\t\t\tcase 值1:\n\t\t\t\t语句体1;\n\t\t\t\tbreak;\n\t\t\tcase 值2:\n\t\t\t\t语句体2;\n\t\t\t\tbreak;\n\t\t\t...\n\t\t\tdefault:\n\t\t\t\t语句体n+1;\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t格式解释说明：\n\t\t\tswitch:说明这是switch语句。\n\t\t\t表达式:可以是byte,short,int,char\n\t\t\t\tJDK5以后可以是枚举\n\t\t\t\tJDK7以后可以是字符串\n\t\t\tcase:后面的值就是要和表达式进行比较的值\n\t\t\tbreak:表示程序到这里中断，跳出switch语句\n\t\t\tdefault:如果所有的情况都不匹配,就执行这里,相当于if语句中的else\n\t(2)面试题\n\t\tswitch语句的表达式可以是byte吗?可以是long吗?可以是String吗?\n\t\t\t可以,不可以,JDK7以后可以\n\t(3)执行流程:\n\t\tA:首先计算表达式的值\n\t\tB:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。\n\t\tC:如果没有匹配，就执行default的语句体n+1。\n\t(4)注意事项:\n\t\tA:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的\n\t\tB:default可以省略吗?\n\t\t\t可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。\n\t\t\t特殊情况：\n\t\t\t\tcase就可以把值固定。\n\t\t\t\tA,B,C,D\n\t\tC:break可以省略吗?\n\t\t\t可以省略，但是结果可能不是我们想要的。\n\t\t\t会出现一个现象：case穿透。\n\t\t\t最终我们建议不要省略\n\t\tD:default一定要在最后吗?\n\t\t\t不是，可以在任意位置。但是建议在最后。\n\t\tE:switch语句的结束条件\n\t\t\ta:遇到break就结束了\n\t\t\tb:执行到末尾就结束了\n\t(5)案例：\n\t\tA:键盘录入一个数字(1-7),输出对应的星期几。\n\t\t\tScanner sc = new Scanner(System.in);\n\t\n\t\t        switch (sc.nextInt()) {\n\t            case ## 1. \n\t                System.out.println(\"Monday\");\n\t                break;\n\t            case ## 2. \n\t                System.out.println(\"Tuesday\");\n\t                break;\n\t            case ## 3. \n\t                System.out.println(\"Wednesday\");\n\t                break;\n\t            case ## 4. \n\t                System.out.println(\"Thursday\");\n\t                break;\n\t            case ## 5. \n\t                System.out.println(\"Friday\");\n\t                break;\n\t            case ## 6. \n\t                System.out.println(\"Saturday\");\n\t                break;\n\t            case ## 7. \n\t                System.out.println(\"Sunday\");\n\t                break;\n\t            default:\n\t                System.out.println(\"wrong\");\n\t        }\n\t\tB:单项选择题\n\t\tC:键盘录入一个字符串的问题\n\t\t\tString s = sc.nextLine();\n\t\tD:根据给定的月份,输出对应的季节\n\t(6)if语句和switch语句各自的场景\n\t\tA:if\n\t\t\t针对boolean类型的判断\n\t\t\t针对一个范围的判断\n\t\t\t针对几个常量的判断\n\t\tB:switch\n\t\t\t针对几个常量的判断\n\n\n## 2. 循环语句(掌握)\n\n\t(1)有三种:for,while,do...while\n\t(2)for循环语句\n\t\tA:格式\n\t\t\tfor(初始化语句;判断条件语句;控制条件语句){\n\t\t\t\t循环体语句;\n\t\t\t}\n\t\t\t\n\t\t\t执行流程：\n\t\t\t\ta:执行初始化语句\n\t\t\t\tb:执行判断条件语句\n\t\t\t\t\t如果这里是true，就继续\n\t\t\t\t\t如果这里是false，循环就结束\n\t\t\t\tc:执行循环体语句\n\t\t\t\td:执行控制条件语句\n\t\t\t\te:回到b\n\t\tB:注意事项\n\t\t\ta:判断条件语句无论简单还是复杂，结果是boolean类型\n\t\t\tb:循环体语句如果是一条，可以省略大括号，但是不建议\n\t\t\tc:有分号就没有左大括号，有左大括号就没有分号\n\t\tC:案例\n\t\t\ta:输出10次HelloWorld\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t            System.out.println(\"HelloWorld\");\n\t\t        }\n\t\t\tb:输出1-10的数据\n\t\t\t\tfor (int i = 1; i < 11; i++) {\n\t\t            System.out.println(i);\n\t\t        }\n\t\t\tc:输出10-1的数据\n\t\t\t\tfor (int i = 10; i > 0; i--) {\n\t\t            System.out.println(i);\n\t\t        }\n\t\t\td:求1-10的和\n\t\t\t\tint sum = 0;\n\t\t        for (int i = 1; i < 11; i++) {\n\t\t            sum += i;\n\t\t        }\n\t\t        System.out.println(sum);\n\t\t\te:求1-100的和,求1-100的偶数和,求1-100的奇数和\n\t\t\t\tint sum = 0;\n\t\t        int oddSum = 0;\n\t\t        int evenSum = 0;\n\t\t\n\t\t        for (int i = 1; i < 101; i++) {\n\t\t            sum += i;\n\t\t        }\n\t\t        System.out.println(\"sum:\" + sum);\n\t\t\n\t\t        for (int i = 1; i < 101; i+=2) {\n\t\t            oddSum += i;\n\t\t        }\n\t\t        System.out.println(\"oddSum:\" + oddSum);\n\t\t\n\t\t        for (int i = 2; i < 101; i+=2) {\n\t\t            evenSum += i;\n\t\t        }\n\t\t        System.out.println(\"evenSum:\" + evenSum);\n\t\t\tf:求5的阶乘\n\t\t\t\tint sum = 1;\n\t\t        for (int i = 5; i > 0; i--) {\n\t\t            sum *= i;\n\t\t        }\n\t\t        System.out.println(sum);\n\t\t\tg:在控制台打印水仙花数(个位,十位,百位的立方和等于该数)\n\t\t\t\tfor (int i = 100; i < 1000; i++) {\n\t\t            int ge = i % 10;\n\t\t            int shi = i / 10 % 10;\n\t\t            int bai = i / 100 % 10;\t\t\n\t\t            if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n\t\t                System.out.println(i);\n\t\t            }\n\t\t        }\n\t\t\th:统计水仙花个数\n\t\t\t\tint flag = 0;\n\t\t        for (int i = 100; i < 1000; i++) {\n\t\t            int ge = i % 10;\n\t\t            int shi = i / 10 % 10;\n\t\t            int bai = i / 100 % 10;\n\t\t            if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n\t\t                flag++;\n\t\t            }\n\t\t        }\n\t\t        System.out.println(flag);\n\t\t\ti:改进版的回文数\n\t\t\t\t一个五位数\n\t\t\t\t个位 = 万位\n\t\t\t\t十位 = 千位\n\t\t\t\t个位 + 十位 + 千位 + 万位 = 百位\n\t\t\t\tfor (int i = 10000; i < 100000; i++) {\n\t\t            int ge = i % 10;\n\t\t            int shi = i / 10 %10;\n\t\t            int bai = i / 100 % 10;\n\t\t            int qian = i /1000 % 10;\n\t\t            int wan = i / 10000 % 10;\n\t\t            if (ge == wan && shi == qian && (ge + shi + qian + wan) == bai) {\n\t\t                System.out.println(i);\n\t\t            }\n\t\t        }\n\t\t\tj:统计1-1000之间同时满足如下条件的数据有多少个\n\t\t\t\tx%3==2\n\t\t\t\tx%5==3\n\t\t\t\tx%7==2\n\t\t\t\tint flag = 0;\n\t\t        for (int i = 1; i < 1001; i++) {\n\t\t            if (i % 3 == 2 && i % 5 == 3 && i % 7 == 2) {\n\t\t                flag++;\n\t\t            }\n\t\t        }\n\t\t        System.out.println(flag);\n\t(3)while循环\n\t\tA:基本格式\n\t\t\twhile(判断条件语句) {\n\t\t\t\t循环体语句;\n\t\t\t}\n\t\t\t\n\t\t\t扩展格式：\n\t\t\t初始化语句;\n\t\t\twhile(判断条件语句){\n\t\t\t\t循环体语句;\n\t\t\t\t控制条件语句;\n\t\t\t}\n\t\t\t\n\t\t\t通过查看这个格式，我们就知道while循环可以和for循环等价转换。\n\t\tB:while的练习\n\t\t\t把for语句的练习用while改进\n\t\tC:for和while的区别\n\t\t\ta:使用上的区别\n\t\t\t\tfor语句的那个控制条件变量,在循环结束后不能在使用了。\n\t\t\t\t而while的可以继续使用。\n\t\t\tb:理解上的区别\n\t\t\t\tfor适合于一个范围的判断\n\t\t\t\twhile适合次数不明确的\n\t\t\t\t\t举例:吃葡萄\n\t\tD:案例：\n\t\t\ta:珠穆朗玛峰问题\n\t\t\tb:小芳存钱问题(break以后才能做)\n\t(4)do...while循环\n\t\tA:基本格式\n\t\t\tdo {\n\t\t\t\t循环体语句;\n\t\t\t}while(判断条件语句);\n\t\t\t\n\t\t\t扩展格式：\n\t\t\t初始化语句;\n\t\t\tdo {\n\t\t\t\t循环体语句;\n\t\t\t\t控制条件语句;\n\t\t\t}while(判断条件语句);\n\t\t\t\n\t\t\t通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。\n\t\tB:三种循环的区别\n\t\t\ta:do...while循环至少执行一次循环体\n\t\t\tb:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体\n\t(5)循环使用的注意事项(死循环)\n\t\tA:一定要注意修改控制条件,否则容易出现死循环。\n\t\tB:最简单的死循环格式\n\t\t\ta:while(true){...}\n\t\t\t\n\t\t\tb:for(;;){}\n\n## 3. 控制跳转语句(掌握)\n\n\t(1)break:中断的意思\n\t\tA:用在循环和switch语句中，离开此应用场景无意义。\n\t\tB:作用\n\t\t\ta:跳出单层循环\n\t\t\tb:跳出多层循环，需要标签语句的配合\n\t(2)continue:继续\n\t\tA:用在循环中，离开此应用场景无意义。\n\t\tB:作用\n\t\t\ta:跳出单层循环的一次，可以继续下一次\n\t\tC:填空题\n\t\t\tfor(int x=1; x<=10; x++) {\n\t\t\t\tif(x%3 == 0) {\n\t\t\t\t\t//补齐代码\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"Java基础班\");\n\t\t\t}\n\t\t\t如何让控制台输出2次：Java基础班\n\t\t\t\tbreak;\n\t\t\t如何让控制台输出7次：Java基础班\n\t\t\t\tcontinue;\n\t\t\t如何让控制台输出13次：Java基础班\n\t\t\t\tSystem.out.println(\"Java基础班\");\n\t(3)return:返回\n\t\tA:用于结束方法的，后面还会在继续讲解和使用。\n\t\tB:一旦遇到return,程序就不会在继续往后执行。\n\n\n\n## 1. 方法(掌握)\n\n\t(1)方法：就是完成特定功能的代码块。\n\t\t注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。\n\t(2)格式：\n\t\t修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {\n\t\t\t方法体语句;\n\t\t\treturn 返回值;\n\t\t}\n\n\n\t\t修饰符：目前就用 public static。后面再详细讲解其他修饰符\n\t\t返回值类型：就是功能结果的数据类型\n\t\t方法名：就是起了一个名字，方便我们调用该方法。\n\t\t参数类型：就是参数的数据类型\n\t\t参数名：就是变量\n\t\t参数分类：\n\t\t\t实参：实际参与运算的数据\n\t\t\t形参：方法上定义的，用于接收实际参数的变量\n\t\t方法体语句：就是完成功能的代码块\n\t\treturn：结束方法\n\t\t返回值：就是功能的结果，由return带给调用者。\n\t(3)两个明确：\n\t\t返回值类型：结果的数据类型\n\t\t参数列表：参数的个数及对应的数据类型\n\t(4)方法调用\n\t\tA:有明确返回值的方法\n\t\t\ta:单独调用，没有意义\n\t\t\tb:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。\n\t\t\tc:赋值调用，推荐方案\n\t\tB:void类型修饰的方法\n\t\t\ta:单独调用\n\t(5)案例：\n\t\tA:求和方案\n\t\t\tpublic static void sum(int a, int b) {\n\t\t        System.out.println(\"a + b = \" + (a + b));\n\t\t    }\n\t\tB:获取两个数中的较大值\n\t\t\tpublic static void max(int a, int b) {\n\t\t        if (a > b) {\n\t\t            System.out.println(a);\n\t\t        } else if (b > a) {\n\t\t            System.out.println(b);\n\t\t        }\n\t\t    }\n\t\tC:比较两个数据是否相同\n\t\t\tpublic static void isEquals(int a, int b) {\n\t\t        if (a == b) {\n\t\t            System.out.println(\"a == b\");\n\t\t        }\n\t\t    }\n\t\tD:获取三个数中的最大值\n\t\t\tpublic static void max(int a, int b, int c) {\n\t\t        if (a > b) {\n\t\t            if (a > c) {\n\t\t                System.out.println(a);\n\t\t            } else if (c > a) {\n\t\t                System.out.println(c);\n\t\t            }\n\t\t        } else if (b > a) {\n\t\t            if (b > c) {\n\t\t                System.out.println(b);\n\t\t            } else if (c > b) {\n\t\t                System.out.println(c);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\tE:输出m行n列的星形\n\t\t\tpublic static void printStar(int row, int column) {\n\t\t        for (int m = 0; m < row; m++) {\n\t\t            String star = \"\";\n\t\t            for (int n = 0; n < column; n++) {\n\t\t                star += \"*\";\n\t\t            }\n\t\t            System.out.println(star);\n\t\t        }\n\t\t        System.out.println(\"--------------\");\n\t\t        for (int m = 0; m < row; m++) {\n\t\t            String star = \"\";\n\t\t            for (int n = 0; n <= m; n++) {\n\t\t                star += \"*\";\n\t\t            }\n\t\t            System.out.println(star);\n\t\t        }\n\t\t        System.out.println(\"---------------\");\n\t\t        for (int m = row; m > 0; m--) {\n\t\t            String star = \"\";\n\t\t            for (int n = 0; n < m; n++) {\n\t\t                star += \"*\";\n\t\t            }\n\t\t            System.out.println(star);\n\t\t        }\n\t\t    }\n\t\tF:输出nn乘法表\n\t\t\tpublic static void chengfabiao(int n) {\n\t\t        for (int i = 1; i <= n; i++) {\n\t\t            for (int j = 1; j <= i; j++) {\n\t\t                System.out.print(j + \" * \" + i + \" = \" + (j * i) + \"\\t\");\n\t\t            }\n\t\t            System.out.println();\n\t\t        }\n\t\t    }\n\t(6)方法的注意事项\n\t\tA:方法不调用不执行\n\t\tB:方法之间是平级关系，不能嵌套定义\n\t\tC:方法定义的时候，参数是用，隔开的\n\t\tD:方法在调用的时候，不用在传递数据类型\n\t\tE:如果方法有明确的返回值类型，就必须有return语句返回。\n\t(7)方法重载\n\t\t在同一个类中，方法名相同，参数列表不同。与返回值无关。\n\t\t\n\t\t参数列表不同：\n\t\t\t参数的个数不同。\n\t\t\t参数的对应的数据类型不同。\n\t(8)方法重载案例\n\t\t不同的类型的多个同名方法的比较。\n\n## 2. 数组(掌握)\n\n\t(1)数组：存储同一种数据类型的多个元素的容器。\n\t(2)特点：每一个元素都有编号，从0开始，最大编号是长度-1。\n\t         编号的专业叫法：索引\n\t(3)定义格式\n\t\tA:数据类型[] 数组名;\n\t\tB:数据类型 数组名[];\n\t\t\n\t\t推荐是用A方式，B方法就忘了吧。\n\t\t但是要能看懂\n\t(4)数组的初始化\n\t\tA:动态初始化\n\t\t\t只给长度，系统给出默认值\n\t\t\t\n\t\t\t举例：int[] arr = new int[3];\n\t\tB:静态初始化\n\t\t\t给出值，系统决定长度\n\t\t\t\n\t\t\t举例：int[] arr = new int[]{1,2,3};\n\t\t\t简化版：int[] arr = {1,2,3};\n\t(5)Java的内存分配\n\t\tA:栈 存储局部变量\n\t\tB:堆 存储所有new出来的\n\t\tC:方法区(面向对象部分详细讲解)\n\t\tD:本地方法区(系统相关)\n\t\tE:寄存器(CPU使用)\n\t\t\n\t\t注意：\n\t\t\ta:局部变量 在方法定义中或者方法声明上定义的变量。\n\t\t\tb:栈内存和堆内存的区别\n\t\t\t\t栈：数据使用完毕，就消失。\n\t\t\t\t堆：每一个new出来的东西都有地址\n\t\t\t\t    每一个变量都有默认值\n\t\t\t\t\t\tbyte,short,int,long 0\n\t\t\t\t\t\tfloat,double 0.0\n\t\t\t\t\t\tchar '\\u0000'\n\t\t\t\t\t\tboolean false\n\t\t\t\t\t\t引用类型 null\n\t\t\t\t    数据使用完毕后，在垃圾回收器空闲的时候回收。\n\t(6)数组内存图\n\t\tA:一个数组\n\t\tB:二个数组\n\t\tC:三个数组(两个栈变量指向同一个堆内存)\n\t(7)数组的常见操作\n\t\tA:遍历\n\t\t\t方式1：\n\t\t\t\tpublic static void printArray(int[] arr) {\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tSystem.out.println(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t方式2：\n\t\t\t\tpublic static void printArray(int[] arr) {\n\t\t\t\t\tSystem.out.print(\"[\");\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tif(x == arr.length-1) {\n\t\t\t\t\t\t\tSystem.out.println(arr[x]+\"]\");\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tSystem.out.println(arr[x]+\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tB:最值\n\t\t\t最大值：\n\t\t\t\tpublic static int getMax(int[] arr) {\n\t\t\t\t\tint max = arr[0];\n\t\t\t\t\t\n\t\t\t\t\tfor(int x=1; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] > max) {\n\t\t\t\t\t\t\tmax = arr[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn max;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t最小值：\n\t\t\t\tpublic static int getMin(int[] arr) {\n\t\t\t\t\tint min = arr[0];\n\t\t\t\t\t\n\t\t\t\t\tfor(int x=1; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] < min) {\n\t\t\t\t\t\t\tmin = arr[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn min;\n\t\t\t\t}\n\t\tC:逆序\n\t\t\t方式1：\n\t\t\t\tpublic static void reverse(int[] arr) {\n\t\t\t\t\tfor(int x=0; x<arr.length/2; x++) {\n\t\t\t\t\t\tint temp = arr[x];\n\t\t\t\t\t\tarr[x] = arr[arr.length-1-x];\n\t\t\t\t\t\tarr[arr.length-1-x] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t方式2：\n\t\t\t\tpublic static void reverse(int[] arr) {\n\t\t\t\t\tfor(int start=0,end=arr.length-1; start<=end; start++,end--) {\n\t\t\t\t\t\tint temp = arr[start];\n\t\t\t\t\t\tarr[start] = arr[end];\n\t\t\t\t\t\tarr[end] = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tD:查表\n\t\t\t\tpublic static String getString(String[] strArray,int index) {\n\t\t\t\t\treturn strArray[index];\n\t\t\t\t}\n\t\tE:基本查找\n\t\t\t方式1：\n\t\t\t\tpublic static int getIndex(int[] arr,int value) {\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] == value) {\n\t\t\t\t\t\t\treturn x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t方式2：\n\t\t\t\tpublic static int getIndex(int[] arr,int value) {\n\t\t\t\t\tint index = -1;\n\t\t\t\t\n\t\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\t\tif(arr[x] == value) {\n\t\t\t\t\t\t\tindex = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\n\n\n# Java面向对象\n\n## 1. 成员变量和局部变量的区别(理解)\n\n\t(1)在类中的位置不同\n\t\t成员变量：类中方法外\n\t\t局部变量：方法定义中或者方法声明上\n\t(2)在内存中的位置不同\n\t\t成员变量：在堆中\n\t\t局部变量：在栈中\n\t(3)生命周期不同\n\t\t成员变量：随着对象的创建而存在，随着对象的消失而消失\n\t\t局部变量：随着方法的调用而存在，随着方法的调用完毕而消失\n\t(4)初始化值不同\n\t\t成员变量：有默认值\n\t\t局部变量：没有默认值，必须定义，赋值，然后才能使用\n\n## 2. 类作为形式参数的问题?(理解)\n\n\t(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。\n\n\n## 3. 匿名对象(理解)\n\n\t(1)没有名字的对象\n\t(2)应用场景\n\t\tA:调用方法，仅仅只调用一次的时候。\n\t\tb:可以作为实际参数传递。\n\n## 4. 封装(理解)\n\n\t(1)隐藏实现细节，提供公共的访问方式\n\t(2)好处：\n\t\tA:隐藏实现细节，提供公共的访问方式\n\t\tB:提高代码的复用性\n\t\tC:提高代码的安全性\n\t(3)设计原则\n\t\t把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式\n\t(4)private是封装的一种体现。\n\t\t封装：类，方法，private修饰成员变量\n\n\n## 5. private关键字(掌握)\n\n\t(1)私有的意义，可以修饰成员变量和成员方法\n\t(2)特点：\n\t\t被private修饰的后的成员只能在本类中被访问\n\t(3)private的应用：\n\t\t以后再写一个类的时候：\n\t\t\t把所有的成员变量给private了\n\t\t\t提供对应的getXxx()/setXxx()方法\n\n\n## 6. this关键字(掌握)\n\n\t(1)代表当前类的引用对象\n\t\t记住：哪个对象调用方法，该方法内部的this就代表那个对象\n\t(2)this的应用场景：\n\t\tA:解决了局部变量隐藏成员变量的问题\n\t\tB:其实this还有其他的应用，明天讲解。\n\n\n## 7. 构造方法(掌握)\n\n\t(1)作用：用于对对象的数据进行初始化\n\t(2)格式：\n\t\tA:方法名和类名相同\n\t\tB:没有返回值类型，连void都不能有\n\t\tC:没有返回值\n\t\t\n\t\t思考题：构造方法中可不可以有return语句呢?\n\t\t可以。只要我们写成这个样子就OK了：return;\n\t\t其实，在任何的void类型的方法的最后你都可以写上：return;\n\t(3)构造方法的注意事项\n\t\tA:如果我们没写构造方法，系统将提供一个默认的无参构造方法\n\t\tB:如果我们给出了构造方法，系统将不再提供默认构造方法\n\t\t\t如果这个时候，我们要使用无参构造方法，就必须自己给出。\n\t\t\t推荐：永远手动自己给出无参构造方法。\n\t(4)给成员变量赋值的方式\n\t\tA:setXxx()\n\t\tB:带参构造方法\n\t(5)标准案例\n\t\tclass Student {\n\t\t\tprivate String name;\n\t\t\tprivate int age;\n\t\t\t\n\t\t\tpublic Student(){}\n\t\t\t\n\t\t\tpublic Student(String name,int age) {\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.age = age;\n\t\t\t}\n\t\t\t\n\t\t\tpublic String getName() {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t\n\t\t\tpublic void setName(String name) {\n\t\t\t\tthis.name = name;\n\t\t\t}\n\t\t\t\n\t\t\tpublic int getAge() {\n\t\t\t\treturn age;\n\t\t\t}\n\t\t\t\n\t\t\tpublic void setAge(int age) {\n\t\t\t\tthis.age = age;\n\t\t\t}\n\t\t}\n\t\t\n\t\t测试：\n\t\tclass StudentDemo {\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\t//方式1\n\t\t\t\tStudent s1 = new Student();\n\t\t\t\ts1.setName(\"林青霞\");\n\t\t\t\ts1.setAge(27);\n\t\t\t\tSystem.out.println(s1.getName()+\"---\"+s1.getAge());\n\t\t\t\t\n\t\t\t\t//方式2\n\t\t\t\tStudent s2 = new Student(\"刘意\",30);\n\t\t\t\tSystem.out.println(s2.getName()+\"---\"+s2.getAge());\n\t\t\t}\n\t\t}\n\n\n\n## 8. 代码：Student s = new Student();做了哪些事情?(理解)\n\n\t(1)把Student.class文件加载到内存\n\t(2)在栈内存为s开辟空间\n\t(3)在堆内存为学生对象申请空间\n\t(4)给学生的成员变量进行默认初始化。null,0\n\t(5)给学生的成员变量进行显示初始化。林青霞,27\n\t(6)通过构造方法给成员变量进行初始化。刘意,30\n\t(7)对象构造完毕，把地址赋值给s变量\n\n## 9. 面向对象的练习题(掌握)\n\n\t(1)标准的手机类的定义和测试\n\t(2)Demo类有求和方法，Test类进行测试。\n\t\t什么时候定义成员变量?\n\t\t当该变量是用来描述一个类的时候。\n\t(3)长方形案例\n\t(4)员工案例\n\t(5)MyMath案例(自己提供加减乘除并测试)\n\t\tpublic class MyMath {\n\t\t    public MyMath() {\n\t\t    }\n\t\t\n\t\t    public static void add(int a, int b) {\n\t\t        System.out.println(\"add\" + (a + b));\n\t\t    }\n\t\t\n\t\t    public static void subtract(int a, int b) {\n\t\t        System.out.println(\"subtract\" + (a - b));\n\t\t    }\n\t\t\n\t\t    public static void multiply(int a, int b) {\n\t\t        System.out.println(\"multiply\" + (a * b));\n\t\t    }\n\t\t\n\t\t    public static void divide(int a, int b) {\n\t\t        System.out.println(\"divide\" + (a / b));\n\t\t    }\n\t\t}\n\n## 10. static关键字(理解)\n\n\t(1)静态的意思。可以修饰成员变量和成员方法。\n\t(2)静态的特点：\n\t\tA:随着类的加载而加载\n\t\tB:优先于对象存在\n\t\tC:被类的所有对象共享\n\t\t\t这其实也是我们判断该不该使用静态的依据。\n\t\t\t举例：饮水机和水杯的问题思考\n\t\tD:可以通过类名调用\n\t\t\t既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。\n\t(3)静态的内存图\n\t\t静态的内容在方法区的静态区\n\t(4)静态的注意事项；\n\t\tA:在静态方法中没有this对象\n\t\tB:静态只能访问静态(代码测试过)\n\t(5)静态变量和成员变量的区别\n\t\tA:所属不同\n\t\t\t静态变量：属于类，类变量\n\t\t\t成员变量：属于对象，对象变量，实例变量\n\t\tB:内存位置不同\n\t\t\t静态变量：方法区的静态区\n\t\t\t成员变量：堆内存\n\t\tC:生命周期不同\n\t\t\t静态变量：静态变量是随着类的加载而加载，随着类的消失而消失\n\t\t\t成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失\n\t\tD:调用不同\n\t\t\t静态变量：可以通过对象名调用，也可以通过类名调用\n\t\t\t成员变量：只能通过对象名调用\n\t(6)main方法是静态的\n\t\tpublic:权限最大\n\t\tstatic:不用创建对象调用\n\t\tvoid:返回值给jvm没有意义\n\t\tmain:就是一个常见的名称。\n\t\tString[] args:可以接收数据，提供程序的灵活性\n\t\t\t格式：java MainDemo hello world java\n\t\t\t\t  java MainDemo 10 20 30\n\n## 1. 如何制作帮助文档(了解)\n\n\t(1)写一个类\n\t(2)加入文档注释\n\t(3)通过javadoc工具生成即可\n\t\tjavadoc -d 目录 -author -version ArrayTool.java\n\n\n## 2. 通过JDK提供的API学习了Math类(掌握)\n\n\t(1)API(Application Programming Interface)\n\t\t应用程序编程接口(帮助文档)\n\t(2)如何使用呢?\n\t\t请参照\n\t\t\tday08\\code\\02_如何使用JDK提供的帮助文档\\如何使用帮助文档.txt\n\t(3)Math类\n\t\tA:是针对数学进行操作的类\n\t\tB:没有构造方法，因为它的成员都是静态的\n\t\tC:产生随机数\n\t\t\tpublic static double random(): [0.0,1.0)\n\t\tD:如何产生一个1-100之间的随机数\n\t\t\tint number = (int)(Math.random()*100)+1;\n\t\tE:猜数字小游戏\n\n\n## 3. 代码块(理解)\n\n\t(1)用{}括起来的代码。\n\t(2)分类：\n\t\tA:局部代码块\n\t\t\t用于限定变量的生命周期，及早释放，提高内存利用率。\n\t\tB:构造代码块\n\t\t\t把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。\n\t\tC:静态代码块\n\t\t\t对类的数据进行初始化，仅仅只执行一次。\n\t(3)静态代码块,构造代码块,构造方法的顺序问题?\n\t\t静态代码块 > 构造代码块 > 构造方法\n\n## 4. 继承(掌握)\n\n\t(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，\n\t   这多个类就具备了这些内容。这个关系叫继承。\n\t(2)Java中如何表示继承呢?格式是什么呢?\n\t\tA:用关键字extends表示\n\t\tB:格式：\n\t\t\tclass 子类名 extends 父类名 {}\n\t(3)继承的好处：\n\t\tA:提高了代码的复用性\n\t\tB:提高了代码的维护性\n\t\tC:让类与类产生了一个关系，是多态的前提\n\t(4)继承的弊端：\n\t\tA:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。\n\t\t\t原则：低耦合，高内聚。\n\t\t\t耦合：类与类的关系\n\t\t\t内聚：自己完成某件事情的能力\n\t\tB:打破了封装性\n\t(5)Java中继承的特点\n\t\tA:Java中类只支持单继承\n\t\tB:Java中可以多层(重)继承(继承体系)\n\t(6)继承的注意事项：\n\t\tA:子类不能继承父类的私有成员\n\t\tB:子类不能继承父类的构造方法，但是可以通过super去访问\n\t\tC:不要为了部分功能而去继承\n\t(7)什么时候使用继承呢?\n\t\tA:继承体现的是：is a的关系。\n\t\tB:采用假设法\n\t(8)Java继承中的成员关系\n\t\tA:成员变量\n\t\t\ta:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单\n\t\t\tb:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?\n\t\t\t\t子类的方法访问变量的查找顺序：\n\t\t\t\t\t在子类方法的局部范围找，有就使用。\n\t\t\t\t\t在子类的成员范围找，有就使用。\n\t\t\t\t\t在父类的成员范围找，有就使用。\n\t\t\t\t\t找不到，就报错。\n\t\tB:构造方法\n\t\t\ta:子类的构造方法默认会去访问父类的无参构造方法\n\t\t\t\t是为了子类访问父类数据的初始化\n\t\t\tb:父类中如果没有无参构造方法，怎么办?\n\t\t\t\t子类通过super去明确调用带参构造\n\t\t\t\t子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造\n\t\t\t\t让父类提供无参构造\n\t\tC:成员方法\n\t\t\ta:子类的成员方法和父类中的成员方法名称不一样，这个太简单\n\t\t\tb:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?\n\t\t\t\t通过子类对象访问一个方法的查找顺序：\n\t\t\t\t\t在子类中找，有就使用\n\t\t\t\t\t在父类中找，有就使用\n\t\t\t\t\t找不到，就报错\n\t(9)两个面试题：\n\t\tA:Override和Overload的区别?Overload是否可以改变返回值类型?\n\t\tB:this和super的区别和各自的作用?\n\t(10)数据初始化的面试题\n\t\tA:一个类的初始化过程\n\t\tB:子父类的构造执行过程\n\t\tC:分层初始化\n\t(11)案例：\n\t\tA:学生和老师案例\n\t\t\t继承前\n\t\t\t继承后\n\t\tB:猫狗案例的分析和实现\n\n## 1. final关键字(掌握)\n\n\t(1)是最终的意思，可以修饰类，方法，变量。\n\t(2)特点：\n\t\tA:它修饰的类，不能被继承。\n\t\tB:它修饰的方法，不能被重写。\n\t\tC:它修饰的变量，是一个常量。\n\t(3)面试相关：\n\t\tA:局部变量\n\t\t\ta:基本类型 值不能发生改变\n\t\t\tb:引用类型 地址值不能发生改变，但是对象的内容是可以改变的\n\t\tB:初始化时机\n\t\t\ta:只能初始化一次。\n\t\t\tb:常见的给值\n\t\t\t\t定义的时候。(推荐)\n\t\t\t\t构造方法中。\n\n## 2. 多态(掌握)\n\n\t(1)同一个对象在不同时刻体现出来的不同状态。\n\t(2)多态的前提：\n\t\tA:有继承或者实现关系。\n\t\tB:有方法重写。\n\t\tC:有父类或者父接口引用指向子类对象。\n\t\t\n\t\t多态的分类：\n\t\t\ta:具体类多态\n\t\t\t\tclass Fu {}\n\t\t\t\tclass Zi extends Fu {}\n\t\t\t\t\n\t\t\t\tFu f = new Zi();\n\t\t\tb:抽象类多态\n\t\t\t\tabstract class Fu {}\n\t\t\t\tclass Zi extends Fu {}\n\t\t\t\t\n\t\t\t\tFu f = new Zi();\n\t\t\tc:接口多态\n\t\t\t\tinterface Fu {}\n\t\t\t\tclass Zi implements Fu {}\n\t\t\t\t\n\t\t\t\tFu f = new Zi();\n\t(3)多态中的成员访问特点\n\t\tA:成员变量\n\t\t\t编译看左边，运行看左边\n\t\tB:构造方法\n\t\t\t子类的构造都会默认访问父类构造\n\t\tC:成员方法\n\t\t\t编译看左边，运行看右边\n\t\tD:静态方法\n\t\t\t编译看左边，运行看左边\n\t\t\t\n\t\t为什么?\n\t\t\t因为成员方法有重写。\n\t(4)多态的好处：\n\t\tA:提高代码的维护性(继承体现)\n\t\tB:提高代码的扩展性(多态体现)\n\t(5)多态的弊端：\n\t\t父不能使用子的特有功能。\n\t\t\n\t\t现象：\n\t\t\t子可以当作父使用，父不能当作子使用。\n\t(6)多态中的转型\n\t\tA:向上转型\n\t\t\t从子到父\n\t\tB:向下转型\n\t\t\t从父到子\n\t(7)孔子装爹的案例帮助大家理解多态\n\t(8)多态的练习\n\t\tA:猫狗案例\n\t\tB:老师和学生案例\n\n\n## 3. 抽象类(掌握)\n\n\t(1)把多个共性的东西提取到一个类中，这是继承的做法。\n\t   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。\n\t   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。\n\t   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。\n\t   而一个没有具体的方法体的方法是抽象的方法。\n\t   在一个类中如果有抽象方法，该类必须定义为抽象类。\n\t(2)抽象类的特点\n\t\tA:抽象类和抽象方法必须用关键字abstract修饰\n\t\tB:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类\n\t\tC:抽象类不能实例化\n\t\tD:抽象类的子类\n\t\t\ta:是一个抽象类。\n\t\t\tb:是一个具体类。这个类必须重写抽象类中的所有抽象方法。\n\t(3)抽象类的成员特点：\n\t\tA:成员变量\n\t\t\t有变量，有常量\n\t\tB:构造方法\n\t\t\t有构造方法\n\t\tC:成员方法\n\t\t\t有抽象，有非抽象\n\t(4)抽象类的练习\n\t\tA:猫狗案例练习\n\t\tB:老师案例练习\n\t\tC:学生案例练习\n\t\tD:员工案例练习\n\t(5)抽象类的几个小问题\n\t\tA:抽象类有构造方法，不能实例化，那么构造方法有什么用?\n\t\t\t用于子类访问父类数据的初始化\n\t\tB:一个类如果没有抽象方法,却定义为了抽象类，有什么用?\n\t\t\t为了不让创建对象\n\t\tC:abstract不能和哪些关键字共存\n\t\t\ta:final\t冲突\n\t\t\tb:private 冲突\n\t\t\tc:static 无意义\n\n\n## 4. 接口(掌握)\n\n\t(1)回顾猫狗案例，它们仅仅提供一些基本功能。\n\t   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，\n\t   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。\n\t(2)接口的特点：\n\t\tA:接口用关键字interface修饰\n\t\t\tinterface 接口名 {}\n\t\tB:类实现接口用implements修饰\n\t\t\tclass 类名 implements 接口名 {}\n\t\tC:接口不能实例化\n\t\tD:接口的实现类\n\t\t\ta:是一个抽象类。\n\t\t\tb:是一个具体类，这个类必须重写接口中的所有抽象方法。\n\t(3)接口的成员特点：\n\t\tA:成员变量\n\t\t\t只能是常量\n\t\t\t默认修饰符：public static final\n\t\tB:构造方法\n\t\t\t没有构造方法\n\t\tC:成员方法\n\t\t\t只能是抽象的\n\t\t\t默认修饰符：public abstract\n\t(4)类与类,类与接口,接口与接口\n\t\tA:类与类\n\t\t\t继承关系，只能单继承，可以多层继承\n\t\tB:类与接口\n\t\t\t实现关系，可以单实现，也可以多实现。\n\t\t\t还可以在继承一个类的同时，实现多个接口\n\t\tC:接口与接口\n\t\t\t继承关系，可以单继承，也可以多继承\n\t(5)抽象类和接口的区别(自己补齐)?\n\t\tA:成员区别\n\t\t\t抽象类：可以是变量可以是常量\n\t\t\t接口：只能是常量\n\t\tB:关系区别:\n\t\t\t类与类：继承\n\t\t\t类与接口：实现\n\t\t\t接口与接口：继承\n\t\tC:设计理念不同\n\t\t\t抽象类：is a，抽象类中定义的是共性功能。\n\t\t\t接口：like a，接口中定义的是扩展功能。\n\t(6)练习：\n\t\tA:猫狗案例，加入跳高功能\n\t\tB:老师和学生案例，加入抽烟功能0\n\n\n\n## 1. 形式参数和返回值的问题(理解)\n\n\t(1)形式参数：\n\t\t类名：需要该类的对象\n\t\t抽象类名：需要该类的子类对象\n\t\t接口名：需要该接口的实现类对象\n\t(2)返回值类型：\n\t\t类名：返回的是该类的对象\n\t\t抽象类名：返回的是该类的子类对象\n\t\t接口名：返回的是该接口的实现类的对象\n\t(3)链式编程\n\t\t对象.方法1().方法2().......方法n();\n\t\t\n\t\t这种用法：其实在方法1()调用完毕后，应该一个对象；\n\t\t\t      方法2()调用完毕后，应该返回一个对象。\n\t\t\t\t  方法n()调用完毕后，可能是对象，也可以不是对象。\n\n\n## 2. 包(理解)\n\n\t(1)其实就是文件夹\n\t(2)作用：\n\t\tA:区分同名的类\n\t\tB:对类进行分类管理\n\t\t\ta:按照功能分\n\t\t\tb:按照模块分\n\t(3)包的定义(掌握)\n\t\tpackage 包名;\n\t\t多级包用.分开。\n\t(4)注意事项：(掌握)\n\t\tA:package语句必须在文件中的第一条有效语句\n\t\tB:在一个java文件中，只能有一个package\n\t\tC:如果没有package，默认就是无包名\n\t(5)带包的编译和运行\n\t\tA:手动式\n\t\tB:自动式(掌握)\n\t\t\tjavac -d . HelloWorld.java\n\n## 3. 导包(掌握)\n\n\t(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。\n\t(2)格式：\n\t\timport 包名...类名;\n\t\t另一种：\n\t\t\timport 包名...*;(不建议)\n\t(3)package,import,class的顺序\n\t\tpackage > import > class\n\n## 4. 权限修饰符(掌握)\n\n\t(1)权限修饰符\n\t\t\t\t\t本类\t同一个包下\t不同包下的子类\t不同包下的无关类\n\t\tprivate\t\tY\n\t\t\t默认\t\tY\t\tY\n\t\tprotected\tY\t\tY\t\t\t Y\n\t\tpublic\t\tY\t\tY\t\t\t Y\t\t\t\t  Y\n\t(2)这四种权限修饰符在任意时刻只能出现一种。\n\t\tpublic class Demo {}\t\t\n\n\n## 5. 常见的修饰符(理解)\n\n\t(1)分类：\n\t\t权限修饰符：private,默认,protected,public\n\t\t状态修饰符：static,final\n\t\t抽象修饰符：abstract\n\t(2)常见的类及其组成的修饰\n\t\t类：\n\t\t\t默认,public,final,abstract\n\t\t\t常用的：public\n\t\t成员变量：\n\t\t\tprivate,默认,protected,public,static,final\n\t\t\t常用的：private\n\t\t构造方法：\n\t\t\tprivate,默认,protected,public\n\t\t\t常用的：public\n\t\t成员方法：\n\t\t\tprivate,默认,protected,public,static,final,abstract\n\t\t\t常用的：public\n\t(3)另外比较常见的：\n\t\tpublic static final int X = 10;\n\t\tpublic static void show() {}\n\t\tpublic final void show() {}\n\t\tpublic abstract void show();\n\n\n## 6. 内部类(理解)\n\n\t(1)把类定义在另一个类的内部，该类就被称为内部类。\n\t\t举例：把类B定义在类A中，类B就被称为内部类。\n\t(2)内部类的访问规则\n\t\tA:可以直接访问外部类的成员，包括私有\n\t\tB:外部类要想访问内部类成员，必须创建对象\n\t(3)内部类的分类\n\t\tA:成员内部类\n\t\tB:局部内部类\n\t(4)成员内部类\n\t\tA:private 为了数据的安全性\n\t\tB:static 为了访问的方便性\t\t\n\t成员内部类不是静态的：\n\t\t外部类名.内部类名 对象名 = new 外部类名.new 内部类名();\n\t成员内部类是静态的：\n\t\t外部类名.内部类名 对象名 = new 外部类名.内部类名();\n(5)成员内部类的面试题(填空)\n\n\t30,20,10\n\tclass Outer {\n\t\tpublic int num = 10;\n\t\t\tclass Inner {\n\t\t\t\tpublic int num = 20;\n\t\t\t\tpublic viod show() {\n\t\t\t\tint num  = 30;\n\t\t\t\tSystem.out.println(num);\n\t\t\t\tSystem.out.println(this.num);\n\t\t\t\tSystem.out.println(Outer.this.num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n(6)局部内部类\n\n\tA:局部内部类访问局部变量必须加final修饰。\n\tB:为什么呢?\n\t\t因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。\n\t\t所以，堆内存还是用该变量，而改变量已经没有了。\n\t\t为了让该值还存在，就加final修饰。\n\t\t通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。\n(7)匿名内部类(掌握)\n\n\tA:是局部内部类的简化形式\n\tB:前提\n\t\t存在一个类或者接口\n\tC:格式:\n\t\tnew 类名或者接口名() {\n\t\t\t重写方法;\n\t\t}\n\tD:本质：\n\t\t其实是继承该类或者实现接口的子类匿名对象\n(8)匿名内部类在开发中的使用\n\n\t我们在开发的时候，会看到抽象类，或者接口作为参数。\n\t而这个时候，我们知道实际需要的是一个子类对象。\n\t如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。\n\t\n\tinterface Person {\n\t\tpublic abstract void study();\n\t}\n\t\n\tclass PersonDemo {\n\t\tpublic void method(Person p) {\n\t\t\tp.study();\n\t\t}\n\t}\n\t\n\tclass PersonTest {\n\t\tpublic static void main(String[] args) {\n\t\t\tPersonDemo pd = new PersonDemo();\n\t\t\tpd.method(new Person() {\n\t\t\t\tpublic void study() {\n\t\t\t\t\tSystem.out.println(\"好好学习，天天向上\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n(9)匿名内部类的面试题(补齐代码)\n\n\tinterface Inter {\n\t\tvoid show();\n\t}\n\t\n\tclass Outer {\n\t\tpublic static Inter method() {\n\t\t\treturn new Inter() {\n\t\t\t\tpublic void show() {\n\t\t\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t\t\t}\t\n\t\t\t};\n\t\t}\n\t}\n\t\n\tclass OuterDemo {\n\t\tpublic static void main(String[] args) {\n\t\t\tOuter.method().show(); //\"HelloWorld\"\n\t\t}\n\t\n\t}\n\nJava开发工具\n\n\t## 1. Eclipse的概述使用(掌握)\n\t\t请参照ppt和课堂练习.txt\n\t\t\n\t## 2. API的概述(了解)\n\t\t(1)应用程序编程接口。\n\t\t(2)就是JDK提供给我们的一些提高编程效率的java类。\n\n\n​\t\n\t## 3. Object类(掌握)\n\t\t(1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。\n\t\t(2)Object类的构造方法有一个，并且是无参构造\n\t\t\t这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造\n\t\t(3)要掌握的方法：\n\t\t\tA:toString()\n\t\t\t\t返回对象的字符串表示，默认是由类的全路径+'@'+哈希值的十六进制表示。\n\t\t\t\t这个表示其实是没有意义的，一般子类都会重写该方法。\n\t\t\t\t如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。\n\t\t\t\t但是最终还是自动生成。\n\t\t\tB:equals()\n\t\t\t\t比较两个对象是否相同。默认情况下，比较的是地址值是否相同。\n\t\t\t\t而比较地址值是没有意义的，所以，一般子类也会重写该方法。\n\t\t\t\t重写过程，我也详细的讲解和分析了。\n\t\t\t\t但是最终还是自动生成。\n\t\t(4)要了解的方法：\n\t\t\tA:hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。\n\t\t\tB:getClass() 返回对象的字节码文件对象，反射中我们会详细讲解\t\n\t\t\tC:finalize() 用于垃圾回收，在不确定的时间\n\t\t\tD:clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。\n\t\t(5)两个注意问题；\n\t\t\tA:直接输出一个对象名称，其实默认调用了该对象的toString()方法。\n\t\t\tB:面试题 \n\t\t\t\t==和equals()的区别?\n\t\t\t\tA:==\n\t\t\t\t\t基本类型：比较的是值是否相同\n\t\t\t\t\t引用类型：比较的是地址值是否相同\n\t\t\t\tB:equals()\n\t\t\t\t\t只能比较引用类型。默认情况下，比较的是地址值是否相同。\n\t\n\t\t\t\t但是，我们可以根据自己的需要重写该方法。\n\n# Java常见对象\n\n## 1. Scanner的使用(了解)\n\t\t(1)在JDK5以后出现的用于键盘录入数据的类。\n\t\t(2)构造方法：\n\t\t\tA:讲解了System.in这个东西。\n\t\t\t\t它其实是标准的输入流,对应于键盘录入\n\t\t\tB:构造方法\n\t\t\t\tInputStream is = System.in;\n\t\t\t\tScanner(InputStream is)\n\t\t\tC:常用的格式\n\t\t\t\tScanner sc = new Scanner(System.in);\n\t(3)基本方法格式：\n\t\tA:hasNextXxx() 判断是否是某种类型的\n\t\tB:nextXxx()\t返回某种类型的元素\n\t(4)要掌握的两个方法\n\t\tA:public int nextInt()\n\t\tB:public String nextLine()\n\t(5)需要注意的小问题\n\t\tA:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。\n\t\tB:解决方案：\n\t\t\ta:重新定义一个Scanner对象\n\t\t\tb:把所有的数据都用字符串获取，然后再进行相应的转换\n\n## 2. String类的概述和使用(掌握)\n\n\t(1)多个字符组成的一串数据。\n\t\t其实它可以和字符数组进行相互转换。\n\t(2)构造方法：\n\t\tA:public String()\n\t\tB:public String(byte[] bytes)\n\t\tC:public String(byte[] bytes,int offset,int length)\n\t\tD:public String(char[] value)\n\t\tE:public String(char[] value,int offset,int count)\n\t\tF:public String(String original)\n\t\t下面的这一个虽然不是构造方法，但是结果也是一个字符串对象\n\t\tG:String s = \"hello\";\n\t(3)字符串的特点\n\t\tA:字符串一旦被赋值，就不能改变。\n\t\t\t注意：这里指的是字符串的内容不能改变，而不是引用不能改变。\n\t\tB:字面值作为字符串对象和通过构造方法创建对象的不同\n\t\t\tString s = new String(\"hello\");和String s = \"hello\"的区别?\n\t\t\tnew String(\"hello\")会在堆内存开辟空间,另一种不会,但是最终的值都在字符串缓存区.\n\t(4)字符串的面试题(看程序写结果)\n\t\tA:==和equals()\n\t\t\tString s1 = new String(\"hello\");\n\t\t\tString s2 = new String(\"hello\");\n\t\t\tSystem.out.println(s1 == s2);// false\n\t\t\tSystem.out.println(s1.equals(s2));// true\n\n\n\t\t\tString s3 = new String(\"hello\");\n\t\t\tString s4 = \"hello\";\n\t\t\tSystem.out.println(s3 == s4);// false\n\t\t\tSystem.out.println(s3.equals(s4));// true\n\n\n\t\t\tString s5 = \"hello\";\n\t\t\tString s6 = \"hello\";\n\t\t\tSystem.out.println(s5 == s6);// true(常量会先去缓存区找,存在就不创建新的对象)\n\t\t\tSystem.out.println(s5.equals(s6));// true\n\t\tB:字符串的拼接\n\t\t\tString s1 = \"hello\";\n\t\t\tString s2 = \"world\";\n\t\t\tString s3 = \"helloworld\";\n\t\t\tSystem.out.println(s3 == s1 + s2);// false\n\t\t\tSystem.out.println(s3.equals((s1 + s2)));// true\n\n\n\t\t\tSystem.out.println(s3 == \"hello\" + \"world\");// false 这个我们错了，应该是true\n\t\t\tSystem.out.println(s3.equals(\"hello\" + \"world\"));// true\n\t(5)字符串的功能(自己补齐方法中文意思)\n\t\tA:判断功能\n\t\t\tboolean equals(Object obj)\n\t\t\tboolean equalsIgnoreCase(String str)\n\t\t\tboolean contains(String str)\n\t\t\tboolean startsWith(String str)\n\t\t\tboolean endsWith(String str)\n\t\t\tboolean isEmpty()\n\t\tB:获取功能\n\t\t\tint length()\n\t\t\tchar charAt(int index)\n\t\t\tint indexOf(int ch)\n\t\t\tint indexOf(String str)\n\t\t\tint indexOf(int ch,int fromIndex)\n\t\t\tint indexOf(String str,int fromIndex)\n\t\t\tString substring(int start)\n\t\t\tString substring(int start,int end)\n\t\tC:转换功能\n\t\t\tbyte[] getBytes()\n\t\t\tchar[] toCharArray()\n\t\t\tstatic String valueOf(char[] chs)\n\t\t\tstatic String valueOf(int i)\n\t\t\tString toLowerCase()\n\t\t\tString toUpperCase()\n\t\t\tString concat(String str)\n\t\tD:其他功能\n\t\t\ta:替换功能 \n\t\t\t\tString replace(char old,char new)\n\t\t\t\tString replace(String old,String new)\n\t\t\tb:去空格功能\n\t\t\t\tString trim()\n\t\t\tc:按字典比较功能\n\t\t\t\tint compareTo(String str)\n\t\t\t\tint compareToIgnoreCase(String str) \n\t(6)字符串的案例\n\t\tA:模拟用户登录\n\t\t\tpublic static void login(String userName, String passwd) {\n\t\t        if (userName == \"Xmos\" && passwd == \"123\") {\n\t\t            System.out.println(\"login success\");\n\t\t        }\n\t\t    }\n\t\tB:字符串遍历\n\t\t\tpublic static void printString(String s) {\n\t\t        char[] c = s.toCharArray();\n\t\t        for (int i = 0; i < c.length; i++) {\n\t\t            System.out.print(c[i]);\n\t\t        }\n\t\t    }\n\t\tC:统计字符串中大写，小写及数字字符的个数\n\t\t\tpublic static void method(String s) {\n\t\t        char[] c = s.toCharArray();\n\t\t        int lowerCaseNum = 0;\n\t\t        int upperCaseNum = 0;\n\t\t        int num = 0;\n\t\t        for (char c1 : c) {\n\t\t            if (c1 >= 'a' && c1 <= 'z') {\n\t\t                lowerCaseNum++;\n\t\t            } else if (c1 >= 'A' && c1 <= 'Z') {\n\t\t                upperCaseNum++;\n\t\t            } else if (c1 >= '0' && c1 <= '9') {\n\t\t                num++;\n\t\t            }\n\t\t        }\n\t\t        \n\t\tD:把字符串的首字母转成大写，其他小写\n\t\t\tpublic static void method1(String s) {\n\t\t        String s1 = s.substring(0, 1);\n\t\t        String s2 = s.substring(1, s.length());\n\t\t        String s3 = s1.toUpperCase() + s2.toLowerCase();\n\t\t\n\t\t        System.out.println(s3);\n\t\t    }\t\t\n\t\tE:把int数组拼接成一个指定格式的字符串\n\t\t\t//方法一\n\t\t\tpublic static void method3(int[] i) {\n\t\t        String s = Arrays.toString(i);\n\t\t        System.out.println(s);\n\t\t    }\n\t\t    //方法二\n\t\t\tpublic static void method3(int[] i) {\n\t\t\t        String s = \"\";\n\t\t\t        for (int i1 : i) {\n\t\t\t            s += String.valueOf(i1);\n\t\t\t        }\n\t\t\t        System.out.println(s);\n\t\t\t    }\n\t\tF:字符串反转\n\t\t\tpublic static void revers(String s) {\n\t\t        char[] c = s.toCharArray();\n\t\t        for (int i = 0; i < c.length / 2; i++) {\n\t\t            char tmp = c[i];\n\t\t            c[i] = c[c.length - 1 - i];\n\t\t            c[c.length - 1 - i] = tmp;\n\t\t        }\n\t\t        System.out.println(String.valueOf(c));\n\t\t    }\t\t\n\t\tG:统计大串中小串出现的次数\n\n\n## 1. StringBuffer(掌握)\n\n\t(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了\n\t   一个字符串缓冲区类。StringBuffer供我们使用。\n\t(2)StringBuffer的构造方法\n\t\tA:StringBuffer()\n\t\tB:StringBuffer(int size)\n\t\tC:StringBuffer(String str)\n\t(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)\n\t\tA:添加功能\n\t\t\tappen();\n\t\tB:删除功能\n\t\t\tdelete();\n\t\tC:替换功能\n\t\t\treplace()\n\t\tD:反转功能\n\t\t\treverse()\n\t\tE:截取功能(注意这个返回值)\n\t\t\tString substring()\n\t(4)StringBuffer的练习(做一遍)\n\t\tA:String和StringBuffer相互转换\n\t\t\tString -- StringBuffer\n\t\t\t\t构造方法\n\t\t\tStringBuffer -- String\n\t\t\t\ttoString()方法\n\t\tB:字符串的拼接\n\t\t\tStringBuffer sb = new StringBuffer(\"hello\");\n\t        StringBuffer sb2 = new StringBuffer(\"world\");\n\t        \n\t        StringBuffer sb3 = sb.append(sb2);\n\t\tC:把字符串反转\n\t\t\tStringBuffer sb = new StringBuffer(\"abc\");\n\t        StringBuffer sb1 = sb.reverse();\n\t\tD:判断一个字符串是否对称\n\t\t\tpublic static void method(StringBuffer sb) {\n\t\t        if (sb.toString().equals(sb.reverse().toString())) {\n\t\t            System.out.println(true);\n\t\t        } else {\n\t\t            System.out.println(false);\n\t\t        }\n\t\t    }\n\t\t\t\n\t(5)面试题\n\t\t小细节：\n\t\t\tStringBuffer：同步的，数据安全，效率低。\n\t\t\tStringBuilder：不同步的，数据不安全，效率高。\n\t\tA:String,StringBuffer,StringBuilder的区别\n\t\t\tString 字符串常量\n\t\t\tStringBuffer 字符串变量（线程安全）\n\t\t\tStringBuilder 字符串变量（非线程安全）\n\t\tB:StringBuffer和数组的区别?\n\t\t\tStringBuffer : 可以存放任意类型的数据\n\t\t\t数组 : 只能存放同类型的数据\n\t(6)注意的问题：\n\t\tString作为形式参数，StringBuffer作为形式参数。\n\t\t\tString : 不会受影响\n\t\t\tStringBuffer : 除了=操作，其他操作会受影响\n## 2. 数组高级以及Arrays(掌握)\n\t(1)排序\n\t\tA:冒泡排序\n\t\t\t相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。\n\t\t\t\n\t\t\tpublic static void bubbleSort(int[] arr) {\n\t\t\t\tfor(int x=0; x<arr.length-1; x++) {\n\t\t\t\t\tfor(int y=0; y<arr.length-1-x; y++) {\n\t\t\t\t\t\tif(arr[y] > arr[y+1]) {\n\t\t\t\t\t\t\tint temp = arr[y];\n\t\t\t\t\t\t\tarr[y] = arr[y+1];\n\t\t\t\t\t\t\tarr[y+1] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tB:选择排序\n\t\t\t把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。\n\t\t\t\n\t\t\tpublic static void selectSort(int[] arr) {\n\t\t\t\tfor(int x=0; x<arr.length-1; x++) {\n\t\t\t\t\tfor(int y=x+1; y<arr.length; y++) {\n\t\t\t\t\t\tif(arr[y] < arr[x]) {\n\t\t\t\t\t\t\tint temp = arr[x];\n\t\t\t\t\t\t\tarr[x] = arr[y];\n\t\t\t\t\t\t\tarr[y] = temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t(2)查找\n\t\tA:基本查找\n\t\t\t针对数组无序的情况\n\t\t\t\n\t\t\tpublic static int getIndex(int[] arr,int value) {\n\t\t\t\tint index = -1;\n\t\t\t\t\n\t\t\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\t\t\tif(arr[x] == value) {\n\t\t\t\t\t\tindex = x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn index;\n\t\t\t}\n\t\tB:二分查找(折半查找)\n\t\t\t针对数组有序的情况(千万不要先排序，在查找)\n\t\t\t\n\t\t\tpublic static int binarySearch(int[] arr,int value) {\n\t\t\t\tint min = 0;\n\t\t\t\tint max = arr.length-1;\n\t\t\t\tint mid = (min+max)/2;\n\t\t\t\t\n\t\t\t\twhile(arr[mid] != value) {\n\t\t\t\t\tif(arr[mid] > value) {\n\t\t\t\t\t\tmax = mid - 1;\n\t\t\t\t\t}else if(arr[mid] < value) {\n\t\t\t\t\t\tmin = mid + 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(min > max) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tmid = (min+max)/2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn mid;\n\t\t\t}\n\t(3)Arrays工具类\n\t\tA:是针对数组进行操作的工具类。包括排序和查找等功能。\n\t\tB:要掌握的方法(自己补齐方法)\n\t\t\t把数组转成字符串：\n\t\t\t\tArrays.toString();\n\t\t\t排序：\n\t\t\t\tArrays.sort();\n\t\t\t二分查找：\n\t\t\t\tArrays.binarySearch();\n\t(4)Arrays工具类的源码解析\n\t(5)把字符串中的字符进行排序\n\t\t举例：\n\t\t\t\"edacbgf\"\n\t\t\t得到结果\n\t\t\t\"abcdefg\"\n\t\t\tString s = \"edacbgf\";\n\t        char[] c = s.toCharArray();\n\t        Arrays.sort(c);\n\t        System.out.println(Arrays.toString(c));\n\n\n## 3. Integer(掌握)\n\n\t(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型\n\t\tbyte \t\tByte\n\t\tshort\t\tShort\n\t\tint\t\t\tInteger\n\t\tlong\t\tLong\n\t\tfloat\t\tFloat\n\t\tdouble\t\tDouble\n\t\tchar\t\tCharacter\n\t\tboolean\t\tBoolean\n\t(2)Integer的构造方法\n\t\tA:Integer i = new Integer(100);\n\t\tB:Integer i = new Integer(\"100\");\n\t\t\t注意：这里的字符串必须是由数字字符组成\n\t(3)String和int的相互转换\n\t\tA:String -- int\n\t\t\tInteger.parseInt(\"100\");\n\t\tB:int -- String\n\t\t\tString.valueOf(100);\n\t(4)其他的功能(了解)\n\t\t进制转换\n\t\t\tInteger.toBinaryString();\n\t        Integer.toHexString();\n\t        Integer.toOctalString();\n\t(5)JDK5的新特性\n\t\t自动装箱\t基本类型--引用类型\n\t\t自动拆箱\t引用类型--基本类型\n\t\t\n\t\t把下面的这个代码理解即可：\n\t\t\tInteger i = 100;\n\t\t\ti += 200;\n\t(6)面试题\n\t\t-128到127之间的数据缓冲池问题\n\n## 4. Character(了解)\n\n\t(1)Character构造方法\t\n\t\tCharacter ch = new Character('a');\n\t(2)要掌握的方法：(自己补齐)\n\t\tA:判断给定的字符是否是大写\n\t\t\tisUpperCase();\n\t\tB:判断给定的字符是否是小写\n\t\t\tisLowerCase();\n\t\tC:判断给定的字符是否是数字字符\n\t\t\tisDigit();\n\t\tD:把给定的字符转成大写\n\t\t\ttoUpperCase();\n\t\tE:把给定的字符转成小写\n\t\t\ttoLowerCase();\n\t(3)案例：\n\t\n\t\t统计字符串中大写，小写及数字字符出现的次数\n\t\t\tString s = \"abcDEF123\";\n\t        char[] c = s.toCharArray();\n\t        int lowerCaseNum = 0;\n\t        int upperCaseNum = 0;\n\t        int digitNum = 0;\n\t\n\t        for (char c1 : c) {\n\t            if (Character.isLowerCase(c1)) {\n\t                lowerCaseNum++;\n\t            } else if (Character.isUpperCase(c1)) {\n\t                upperCaseNum++;\n\t            } else if (Character.isDigit(c1)) {\n\t                digitNum++;\n\t            }\n\t        }\n\t\n\t        System.out.println(\"lowerCase:\" + lowerCaseNum + \"\\t\" + \"upperCase:\" + upperCaseNum + \"\\t\" + \"digit:\" + digitNum);\n\n\n## 1. 正则表达式(理解)\n\n\t(1)就是符合一定规则的字符串\n\t(2)常见规则\n\t\tA:字符\n\t\t\tx 字符 x。举例：'a'表示字符a\n\t\t\t\\\\ 反斜线字符。\n\t\t\t\\n 新行（换行）符 ('\\u000A') \n\t\t\t\\r 回车符 ('\\u000D')\n\t\t\t\n\t\tB:字符类\n\t\t\t[abc] a、b 或 c（简单类） \n\t\t\t[^abc] 任何字符，除了 a、b 或 c（否定） \n\t\t\t[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） \n\t\t\t[0-9] 0到9的字符都包括\n\t\t\t\n\t\tC:预定义字符类\n\t\t\t. 任何字符。我的就是.字符本身，怎么表示呢? \\.\n\t\t\t\\d 数字：[0-9]\n\t\t\t\\w 单词字符：[a-zA-Z_0-9]\n\t\t\t\t在正则表达式里面组成单词的东西必须有这些东西组成\n\t\t\t\t\n\t\tD:边界匹配器\n\t\t\t^ 行的开头 \n\t\t\t$ 行的结尾 \n\t\t\t\\b 单词边界\n\t\t\t\t就是不是单词字符的地方。\n\t\t\t\t举例：hello world?haha;xixi\n\t\t\t\n\t\tE:Greedy 数量词 \n\t\t\tX? X，一次或一次也没有\n\t\t\tX* X，零次或多次\n\t\t\tX+ X，一次或多次\n\t\t\tX{n} X，恰好 n 次 \n\t\t\tX{n,} X，至少 n 次 \n\t\t\tX{n,m} X，至少 n 次，但是不超过 m 次 \n\t(3)常见功能：(分别用的是谁呢?)\n\t\tA:判断功能\n\t\t\tString类的public boolean matches(String regex)\n\t\tB:分割功能\n\t\t\tString类的public String[] split(String regex)\n\t\tC:替换功能\n\t\t\tString类的public String replaceAll(String regex,String replacement)\n\t\tD:获取功能\n\t\t\tPattern和Matcher\n\t\t\t\tPattern p = Pattern.compile(\"a*b\");\n\t\t\t\tMatcher m = p.matcher(\"aaaaab\");\n\t\t\t\t\n\t\t\t\tfind():查找存不存在\n\t\t\t\tgroup():获取刚才查找过的数据\n\t(4)案例\n\t\tA:判断电话号码和邮箱\n\t\t\t//普安段邮箱\n\t\t\tpublic static boolean checkMail(String s){\n\t\t        String regex = \"\\\\d*\\\\w*@sina\\\\.com\";\n\t\t        return s.matches(regex);\n\t\t    }\n\t\t    //判断电话号码\n\t\t    public static boolean checkPhoneNum(String s) {\n\t\t        String regex = \"\\\\d{11}\";\n\t\t        return s.matches(regex);\n\t\t    }\n\t\tB:按照不同的规则分割数据\n\t\t\tpublic static String[] split(String s) {\n\t\t        String regex = \",\";\n\t\t        String[] result = s.split(regex);\n\t\t        return result;\n\t\t    }\n\t\tC:把论坛中的数字替换为*\n\t\t\t//替换为和数字等量的*\n\t\t\tpublic static String replaceStar(String s) {\n\t\t        String regex = \"\\\\d\";\n\t\t        return s.replaceAll(regex, \"*\");\n\t\t    }\n\t\t    //所有相连数字替换为一个*\n\t\t    public static String replaceStar(String s) {\n\t\t        String regex = \"\\\\d+\";\n\t\t        return s.replaceAll(regex, \"*\");\n\t\t    }\n\t\tD:获取字符串中由3个字符组成的单词\n\t\t\tpublic static List<String> method(String s) {\n\t\t        Pattern p = Pattern.compile(\"a\\\\d{3}b\");\n\t\t        Matcher m = p.matcher(s);\n\t\t        List<String> result = new ArrayList<String>();\n\t\t        \n\t\t        while (m.find()) {\n\t\t            result.add(m.group());\n\t\t        }\n\t\t        return  result;\n\t\t    }\n\n## 2. Math(掌握)\n\n\t(1)针对数学运算进行操作的类\n\t(2)常见方法(自己补齐)\n\t\tA:绝对值\n\t\t\tMath.abs();\n\t\tB:向上取整\n\t\t\tMath.ceil();\n\t\tC:向下取整\n\t\t\tMath.floor();\n\t\tD:两个数据中的大值\n\t\t\tMath.max();\n\t\tE:a的b次幂\n\t\t\tMath.pow(a, b);\n\t\tF:随机数\n\t\t\tMath.random();\n\t\tG:四舍五入\n\t\t\tMath.round();\n\t\tH:正平方根\n\t\t\tMath.sqrt();\n\t(3)案例：\n\t\tA:猜数字小游戏\n\t\t\tScanner sc = new Scanner(System.in);\n\t        int i = (int)(Math.random() * 100) + 1;\n\t        int answer;\n\t        while ((answer = sc.nextInt()) != i) {\n\t            if (answer > i) {\n\t                System.out.println(\"bigger than result,go on\");\n\t            } else if (answer < i) {\n\t                System.out.println(\"smaller than result,go on\");\n\t            }\n\t        }\n\t        System.out.println(\"you are right\");\n\t\tB:获取任意范围的随机数\n\t\t\tScanner sc = new Scanner(System.in);\n\t        System.out.println(\"请输入起始:\");\n\t        int start = sc.nextInt();\n\t        System.out.println(\"请输入结束:\");\n\t        int end = sc.nextInt();\n\t\n\t        int i = (int)(Math.random() * (end - start)) + start;\n\t        System.out.println(i);\n## 3. Random(理解)\n\n\t(1)用于产生随机数的类\n\t(2)构造方法:\n\t\tA:Random() 默认种子，每次产生的随机数不同\n\t\tB:Random(long seed) 指定种子，每次种子相同，随机数就相同\n\t(3)成员方法:\n\t\tA:int nextInt() 返回int范围内的随机数\n\t\tB:int nextInt(int n) 返回[0,n)范围内的随机数\n\n\n## 4. System(掌握)\n\n\t(1)系统类,提供了一些有用的字段和方法\n\t(2)成员方法(自己补齐)\n\t\tA:运行垃圾回收器\n\t\t\tSystem.gc();\n\t\tB:退出jvm\n\t\t\tSystem.exit(0);\n\t\tC:获取当前时间的毫秒值\n\t\t\tSystem.currentTimemillis();\n\t\tD:数组复制\n\t\t\tSystem.arraycopy();\n\n## 5. BigInteger(理解)\n\n\t(1)针对大整数的运算\n\t(2)构造方法\t\n\t\tA:BigInteger(String s)\n\t(3)成员方法(自己补齐)\n\t\tA:加\n\t\t\tadd();\n\t\tB:减\n\t\t\tsubtract();\n\t\tC:乘\n\t\t\tmultiply();\n\t\tD:除\n\t\t\tdivide();\n\t\tE:商和余数\n\t\t\tdivideAndRemainder();\n\n## 6. BigDecimal(理解)\n\n\t(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)\n\t(2)构造方法\n\t\tA:BigDecimal(String s)\n\t(3)成员方法：\n\t\tA:加\n\t\t\tadd();\n\t\tB:减\n\t\t\tsubtract();\n\t\tC:乘\n\t\t\tmultiply();\n\t\tD:除\n\t\t\tdivide();\n\t\tE:自己保留小数几位\n\t\t\tsetScale();\n\n## 7. Date/DateFormat(掌握)\n\n\t(1)Date是日期类，可以精确到毫秒。\n\t\tA:构造方法\n\t\t\tDate()\n\t\t\tDate(long time)\n\t\tB:成员方法\n\t\t\tgetTime()\n\t\t\tsetTime(long time)\n\t\tC:日期和毫秒值的相互转换\n\t\t案例：你来到这个世界多少天了?\n\t(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat\n\t\tA:SimpleDateFormat(String pattern) 给定模式\n\t\t\tyyyy-MM-dd HH:mm:ss\n\t\tB:日期和字符串的转换\n\t\t\ta:Date -- String\n\t\t\t\tformat()\n\t\t\t\t\n\t\t\tb:String -- Date\n\t\t\t\tparse()\n\t\tC:案例：\n\t\t\t制作了一个针对日期操作的工具类。\n\t\t\t\tDate d = new Date();\n\t\t        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t        System.out.println(sdf.format(d));\n\n## 8. Calendar(掌握)\n\n\t(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。\n\t(2)如何得到一个日历对象呢?\n\t\tCalendar rightNow = Calendar.getInstance();\n\t\t本质返回的是子类对象\n\t(3)成员方法\n\t\tA:根据日历字段得到对应的值\n\t\t\tCalendar c =Calendar.getInstance();\n\t        System.out.println(c.get(Calendar.YEAR));\n\t        System.out.println(c.get(Calendar.MONTH));\n\t        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n\t\tB:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值\n\t\t\tadd(Calendar.DAY_OF_MONTH, +3);\n\t\tC:设置日历对象的年月日\n\t\t\tset(2018,5,30);\n\t\t\tset(Calendar.YEAR, 2018);\n\t\t\tset(Calendar.MONTH, 2018);\n\t\t\tset(Calendar.DAY_OF_MONTH, 2018);\n\t(4)案例：\n\t\t计算任意一年的2月份有多少天?\n\t\t\tScanner sc = new Scanner(System.in);\n\t        Calendar c =Calendar.getInstance();\n\t\n\t        c.set(Calendar.YEAR, sc.nextInt());\n\t        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n\n# Java集合框架\n\n# JavaIO流\n\n## 1. 异常(理解)\n\n\t(1)程序出现的不正常的情况。\n\t(2)异常的体系\n\t\tThrowable\n\t\t\t|--Error\t严重问题，我们不处理。\n\t\t\t|--Exception\n\t\t\t\t|--RuntimeException\t运行期异常，我们需要修正代码\n\t\t\t\t|--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过\n\t(3)异常的处理：\n\t\tA:JVM的默认处理\n\t\t\t把异常的名称,原因,位置等信息输出在控制台，但是程序不能继续执行了。\n\t\tB:自己处理\n\t\t\ta:try...catch...finally\n\t\t\t\t自己编写处理代码,后面的程序可以继续执行\n\t\t\tb:throws\n\t\t\t\t把自己处理不了的，在方法上声明，告诉调用者，这里有问题\n\t(4)面试题\n\t\tA:编译期异常和运行期异常的区别?\n\t\t\t编译期异常 必须要处理的，否则编译不通过\n\t\t\t运行期异常 可以不处理，也可以处理\n\t\tB:throw和throws是的区别\n\t\t\tthrow:\n\t\t\t\t在方法体中,后面跟的是异常对象名,并且只能是一个\n\t\t\t\tthrow抛出的是一个异常对象，说明这里肯定有一个异常产生了\n\t\t\tthrows:\n\t\t\t\t在方法声明上,后面跟的是异常的类名,可以是多个\n\t\t\t\tthrows是声明方法有异常，是一种可能性，这个异常并不一定会产生\n\t(5)finally关键字及其面试题\n\t\tA:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了\n\t\tB:面试题\n\t\t\ta:final,finally,finalize的区别?\n\t\t\t\tfinal : 关键字,修饰类、方法、变量,被修饰的类无法被继承,方法无法重写,变量值不能改变.\n\t\t\t\tfinally : try...catch...finally,一定会执行.\n\t\t\t\tfinalize : 对象被垃圾回收器回收时执行的方法.\n\t\t\tb:如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后\n\t\t\t\t会，前。\n\t\t\t\t\n\t\t\t\t实际上在中间。这个上课我们讲过\n\t\tC:异常处理的变形\n\t\t\ttry...catch...finally\n\t\t\ttry...catch...\n\t\t\ttry...catch...catch...\n\t\t\ttry...catch...catch...fianlly\n\t\t\ttry...finally\n\t(6)自定义异常\n\t\t继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可\n\t\t\tpublic class MyException extends RuntimeException {\n\t\t\t    public MyException(String message) {\n\t\t\t        super(message);\n\t\t\t    }\n\t\t\t\n\t\t\t    public MyException() {\n\t\t\t        super();\n\t\t\t    }\n\t\t\t}\n\t(7)异常的注意实现\n\t\tA:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 \n\t\tB:父的方法没有异常抛出,子的重写方法不能有异常抛出\n\t\tC:父的方法抛出多个异常,子的重写方法必须比父少或者小\n\n## 2. File(掌握)\n\n\t(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件\n\t(2)构造方法\n\t\tA:File file = new File(\"e:\\\\demo\\\\a.txt\");\n\t\tB:File file = new File(\"e:\\\\demo\",\"a.txt\");\n\t\tC:File file = new File(\"e:\\\\demo\");\n\t\t  File file2 = new File(file,\"a.txt\");\n\t(3)File类的功能(自己补齐)\n\t\tA:创建功能\n\t\t\tcreateNewFile();\n\t\t\tmkdir();\n\t\t\tmkdirs();\n\t\tB:删除功能\n\t\t\tdelete();\n\t\tC:重命名功能\n\t\t\trenameTo();\n\t\tD:判断功能\n\t\t\tisFile();\n\t        isDirectory();\n\t        exists();\n\t        canRea();\n\t        canWrite();\n\t        isAbsolute();\n\t        isHidden();\n\t\tE:获取功能\n\t\t\tgetAbsoluteFile();\n\t        getAbsolutePath();\n\t        getPath();\n\t        getParent();\n\t        getParentFile();\n\t        getName();\n\t        length();\n\t        lastModified();\n\t\tF:高级获取功能\n\t\t\tlist();\n\t\t\tlistFiles();\n\t\tG:过滤器功能\n\t\t\tlist(FilenameFilter filter);\n\t\t\t\tString[] s = file1.list(new FilenameFilter() {\n\t            @Override\n\t            public boolean accept(File dir, String name) {\n\t                return new File(dir, name).isFile() && name.endsWith(\".jpg\");\n\t            }\n\t        });\n\t\t\tlistFiles(FilenameFilter filter);\n\t(4)案例：\n\t\tA:输出指定目录下指定后缀名的文件名称\n\t\t\ta:先获取所有的，在遍历的时候判断，再输出\n\t\t\t\tFile file = new File(\"D:\\\\Movie\\\\M\");\n\t\t        String[] s = file.list();\n\t\t\n\t\t        for (String result : s) {\n\t\t            if (result.endsWith(\".mp4\")) {\n\t\t                System.out.println(result);\n\t\t            }\n\t\t        }\n\t\t\tb:先判断，再获取，最后直接遍历输出即可\n\t\t\t\tString[] s1 = file.list(new FilenameFilter() {\n\t\t            @Override\n\t\t            public boolean accept(File dir, String name) {\n\t\t                return name.endsWith(\".mp4\");\n\t\t            }\n\t\t        });\n\t\t        for (String result : s1) {\n\t\t            System.out.println(result);\n\t\t        }\n\t\tB:批量修改文件名称\n\t\t\tFile file = new File(\"D:\\\\Movie\");\n\t        String[] s = file.list(new FilenameFilter() {\n\t            @Override\n\t            public boolean accept(File dir, String name) {\n\t                return name.startsWith(\"相对宇宙\");\n\t            }\n\t        });\n\t        for (String result : s) {\n\t            System.out.println(\"beforeRename : \" + result);\n\t            File file1 = new File(file,result.replaceAll(\"WEB.*影视\\\\.\", \"\"));\n\t            File file2 = new File(file, result);\n\t            file2.renameTo(file1);\n\t            System.out.println(\"afterRename : \" + file1.exists() + \", \" + file1.getName());\n\t        }\n\t        ## 1. 递归(理解)\n\t\n\t(1)方法定义中调用方法本身的现象\n\t\t举例：老和尚给小和尚讲故事，我们学编程\n\t(2)递归的注意事项；\n\t\tA:要有出口，否则就是死递归\n\t\tB:次数不能过多，否则内存溢出\n\t\tC:构造方法不能递归使用\n\t(3)递归的案例：\n\t\tA:递归求阶乘\n\t\t\tpublic static int method(int i) {\n\t\t        while (i > 1) {\n\t\t            return i * method(--i);\n\t\t        }\n\t\t        return 1;\n\t\t    }\n\t\tB:兔子问题\n\t\tC:递归输出指定目录下所有指定后缀名的文件绝对路径\n\t\t\tpublic static void method(File filePath, String suffix) {\n\t\t        File[] files = filePath.listFiles();\n\t\t        for (File file : files) {\n\t\t            if (file.isDirectory()) {\n\t\t                method(file, suffix);\n\t\t            } else if (file.getName().endsWith(suffix)){\n\t\t                System.out.println(file.getName());\n\t\t            }\n\t\t        }\n\t\t    }\n\t\tD:递归删除带内容的目录(小心使用)\n\t\t\tpublic static void method(File filePath) {\n\t\t        File[] files = filePath.listFiles();\n\t\t        for (File file : files) {\n\t\t            if (file.isDirectory()) {\n\t\t                method(file);\n\t\t            } else {\n\t\t                file.delete();\n\t\t            }\n\t\t        }\n\t\t        filePath.delete();\n\t\t    }\n\n## 2. IO流(掌握)\n\n\t(1)IO用于在设备间进行数据传输的操作\t\n\t(2)分类：\n\t\tA:流向\n\t\t\t输入流\t读取数据\n\t\t\t输出流\t写出数据\n\t\tB:数据类型\n\t\t\t字节流\t\n\t\t\t\t\t字节输入流\n\t\t\t\t\t字节输出流\n\t\t\t字符流\n\t\t\t\t\t字符输入流\n\t\t\t\t\t字符输出流\n\t\t注意：\n\t\t\ta:如果我们没有明确说明按照什么分，默认按照数据类型分。\n\t\t\tb:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。\n\t(3)FileOutputStream写出数据\n\t\tA:操作步骤\n\t\t\ta:创建字节输出流对象\n\t\t\tb:调用write()方法\n\t\t\tc:释放资源\n\t\t\t\n\t\tB:代码体现：\n\t\t\tFileOutputStream fos = new FileOutputStream(\"fos.txt\");\n\t\t\t\n\t\t\tfos.write(\"hello\".getBytes());\n\t\t\t\n\t\t\tfos.close();\n\t\t\t\n\t\tC:要注意的问题?\n\t\t\ta:创建字节输出流对象做了几件事情?\n\t\t\t\t调用系统功能去创建文件\n\t\t\t\t创建fos对象\n\t\t\t\t把fos对象指向这个文件\n\t\t\tb:为什么要close()?\n\t\t\t\t关闭此文件输出流并释放与此流有关的所有系统资源。\n\t\t\tc:如何实现数据的换行?\n\t\t\t\twindows:\\r\\n\n\t\t\t\tlinux:\\n\n\t\t\t\tMac:\\r\n\t\t\td:如何实现数据的追加写入?\n\t\t\t\tFileOutputStream fos = new FileOutputStream(\"F:\\\\\", true);\n\t(4)FileInputStream读取数据\n\t\tA:操作步骤\n\t\t\ta:创建字节输入流对象\n\t\t\tb:调用read()方法\n\t\t\tc:释放资源\n\t\t\t\n\t\tB:代码体现：\n\t\t\tFileInputStream fis = new FileInputStream(\"fos.txt\");\n\t\t\t\n\t\t\t//方式1\n\t\t\tint by = 0;\n\t\t\twhile((by=fis.read())!=-1) {\n\t\t\t\tSystem.out.print((char)by);\n\t\t\t}\n\t\t\t\n\t\t\t//方式2\n\t\t\tbyte[] bys = new byte[1024];\n\t\t\tint len = 0;\n\t\t\twhile((len=fis.read(bys))!=-1) {\n\t\t\t\tSystem.out.print(new String(bys,0,len));\n\t\t\t}\n\t\t\t\n\t\t\tfis.close();\n\t(5)案例：2种实现\n\t\tA:复制文本文件\n\t\t\tFileInputStream fis = new FileInputStream(\"a.txt\");\n\t        FileOutputStream fos = new FileOutputStream(\"b.txt\");\n\t\t\t//方式一\n\t        int i = 0;\n\t        while ((i = fis.read()) != -1) {\n\t            fos.write(i);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t        //方式二\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tB:复制图片\n\t\t\tFileInputStream fis = new FileInputStream(\"a.jpg\");\n\t        FileOutputStream fos = new FileOutputStream(\"b.jpg\");\n\t\t\t//方式一\n\t        int i = 0;\n\t        while ((i = fis.read()) != -1) {\n\t            fos.write(i);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t        //方式二\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tC:复制视频\n\t\t\tFileInputStream fis = new FileInputStream(\"a.mp4\");\n\t        FileOutputStream fos = new FileOutputStream(\"b.mp4\");\n\t\t\t//方式一\n\t        int i = 0;\n\t        while ((i = fis.read()) != -1) {\n\t            fos.write(i);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t        //方式二\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t(6)字节缓冲区流\n\t\tA:BufferedOutputStream\n\t\tB:BufferedInputStream\n\t(7)案例：4种实现\n\t\tA:复制文本文件\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.txt\"));\n\t        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.txt\"));\n\t\n\t        //方式三\n\t        int i = 0;\n\t        while ((i = bis.read()) != -1) {\n\t            bos.write(i);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n\t        //方式四\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tB:复制图片\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.jpg\"));\n\t        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.jpg\"));\n\t\n\t        //方式三\n\t        int i = 0;\n\t        while ((i = bis.read()) != -1) {\n\t            bos.write(i);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n\t        //方式四\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t\tC:复制视频\n\t\t\tBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"a.mp4\"));\n\t        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"b.mp4\"));\n\t\n\t        //方式三\n\t        int i = 0;\n\t        while ((i = bis.read()) != -1) {\n\t            bos.write(i);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n\t        //方式四\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t\t\tfis.close();\n\t        fos.close();\n## 3. 自学字符流\n\n\tIO流分类\n\t\t字节流：\n\t\t\tInputStream\n\t\t\t\tFileInputStream\n\t\t\t\tBufferedInputStream\n\t\t\tOutputStream\n\t\t\t\tFileOutputStream\n\t\t\t\tBufferedOutputStream\n\t\t\n\t\t字符流：\n\t\t\tReader\n\t\t\t\tFileReader\n\t\t\t\tBufferedReader\n\t\t\tWriter\n\t\t\t\tFileWriter\n\t\t\t\tBufferedWriter\n## 1. 字符流(掌握)\n\n\t(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。\n\t   转换流的作用就是把字节流转换字符流来使用。\n\t(2)转换流其实是一个字符流\n\t\t字符流 = 字节流 + 编码表\n\t(3)编码表\n\t\tA:就是由字符和对应的数值组成的一张表\n\t\tB:常见的编码表\n\t\t\tASCII\n\t\t\tISO-8859-1\n\t\t\tGB2312\n\t\t\tGBK\n\t\t\tGB18030\n\t\t\tUTF-8\n\t\tC:字符串中的编码问题\n\t\t\t编码\n\t\t\t\tString -- byte[]\n\t\t\t解码\n\t\t\t\tbyte[] -- String\n\t(4)IO流中的编码问题\n\t\tA:OutputStreamWriter\n\t\t\tOutputStreamWriter(OutputStream os):默认编码，GBK\n\t\t\tOutputStreamWriter(OutputStream os,String charsetName):指定编码。\n\t\tB:InputStreamReader\n\t\t\tInputStreamReader(InputStream is):默认编码，GBK\n\t\t\tInputStreamReader(InputStream is,String charsetName):指定编码\n\t\tC:编码问题其实很简单\n\t\t\t编码只要一致即可\n\t(5)字符流\n\t\tReader\n\t\t\t|--InputStreamReader\n\t\t\t\t|--FileReader\n\t\t\t|--BufferedReader\n\t\tWriter\n\t\t\t|--OutputStreamWriter\n\t\t\t\t|--FileWriter\n\t\t\t|--BufferedWriter\n\t(6)复制文本文件(5种方式)\n\t\tpublic class CopyDemo {\n\t    public static void main(String[] args) throws IOException {\n\t        File srcFile = new File(\"a.txt\");\n\t        File destFile = new File(\"b.txt\");\n\t\n\t        method1(srcFile, destFile);\n\t        method2(srcFile, destFile);\n\t        method3(srcFile, destFile);\n\t        method4(srcFile, destFile);\n\t        method5(srcFile, destFile);\n\t    }\n\t\n\t    private static void method5(File srcFile, File destFile) throws IOException{\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        String s = null;\n\t        while ((s = br.readLine()) != null) {\n\t            bw.write(s);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method4(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int len = 0;\n\t        char[] chars = new char[1024];\n\t        while ((len = br.read(chars)) != -1) {\n\t            bw.write(chars, 0, len);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method3(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int by = 0;\n\t        while ((by = br.read()) != -1) {\n\t            bw.write(by);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method2(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int len = 0;\n\t        char[] bytes = new char[1024];\n\t        while ((len = fr.read(bytes)) != -1) {\n\t            fw.write(bytes, 0, len);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\t\n\t    private static void method1(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int by = 0;\n\t        while ((by = fr.read()) != -1) {\n\t            fw.write(by);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\n## 2. IO流小结(掌握)\n\n\tIO流\n\t\t|--字节流\n\t\t\t|--字节输入流\n\t\t\t\tInputStream\n\t\t\t\t\tint read():一次读取一个字节\n\t\t\t\t\tint read(byte[] bys):一次读取一个字节数组\n\t\t\t\t\n\t\t\t\t\t|--FileInputStream\n\t\t\t\t\t|--BufferedInputStream\n\t\t\t|--字节输出流\n\t\t\t\tOutputStream\n\t\t\t\t\tvoid write(int by):一次写一个字节\n\t\t\t\t\tvoid write(byte[] bys,int index,int len):一次写一个字节数组的一部分\n\t\t\t\t\t\n\t\t\t\t\t|--FileOutputStream\n\t\t\t\t\t|--BufferedOutputStream\n\t\t|--字符流\n\t\t\t|--字符输入流\n\t\t\t\tReader\n\t\t\t\t\tint read():一次读取一个字符\n\t\t\t\t\tint read(char[] chs):一次读取一个字符数组\n\t\t\t\t\t\n\t\t\t\t\t|--InputStreamReader\n\t\t\t\t\t\t|--FileReader\n\t\t\t\t\t|--BufferedReader\n\t\t\t\t\t\tString readLine():一次读取一个字符串\n\t\t\t|--字符输出流\n\t\t\t\tWriter\n\t\t\t\t\tvoid write(int ch):一次写一个字符\n\t\t\t\t\tvoid write(char[] chs,int index,int len):一次写一个字符数组的一部分\n\t\t\t\t\t\n\t\t\t\t\t|--OutputStreamWriter\n\t\t\t\t\t\t|--FileWriter\n\t\t\t\t\t|--BufferedWriter\n\t\t\t\t\t\tvoid newLine():写一个换行符\n\t\t\t\t\t\t\n\t\t\t\t\t\tvoid write(String line):一次写一个字符串\n\n## 3. 案例(理解 练习一遍)\n\n\tA:复制文本文件 5种方式(掌握)\n\t\tprivate static void method5(File srcFile, File destFile) throws IOException{\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        String s = null;\n\t        while ((s = br.readLine()) != null) {\n\t            bw.write(s);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method4(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int len = 0;\n\t        char[] chars = new char[1024];\n\t        while ((len = br.read(chars)) != -1) {\n\t            bw.write(chars, 0, len);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method3(File srcFile, File destFile) throws IOException {\n\t        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t        int by = 0;\n\t        while ((by = br.read()) != -1) {\n\t            bw.write(by);\n\t        }\n\t        br.close();\n\t        bw.close();\n\t    }\n\t\n\t    private static void method2(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int len = 0;\n\t        char[] bytes = new char[1024];\n\t        while ((len = fr.read(bytes)) != -1) {\n\t            fw.write(bytes, 0, len);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\t\n\t    private static void method1(File srcFile, File destFile) throws IOException {\n\t        FileReader fr = new FileReader(srcFile);\n\t        FileWriter fw = new FileWriter(destFile);\n\t\n\t        int by = 0;\n\t        while ((by = fr.read()) != -1) {\n\t            fw.write(by);\n\t        }\n\t        fr.close();\n\t        fw.close();\n\t    }\n\tB:复制图片(二进制流数据) 4种方式(掌握)\n\t\tprivate static void method4(File srcFile, File destFile) throws IOException{\n\t        BufferedInputStream bis = new BufferedInputStream(\n\t        \tnew FileInputStream(srcFile));\n\t        BufferedOutputStream bos = new BufferedOutputStream(\n\t        \tnew FileOutputStream(destFile));\n\t\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = bis.read()) != -1) {\n\t            bos.write(bytes, 0, len);\n\t        }\n\t        bis.close();\n\t        bos.close();\n\t    }\n\t\n\t    private static void method3(File srcFile, File destFile) throws IOException{\n\t        BufferedInputStream bis = new BufferedInputStream(\n\t        \tnew FileInputStream(srcFile));\n\t        BufferedOutputStream bos = new BufferedOutputStream(\n\t        \tnew FileOutputStream(destFile));\n\t\n\t        int by = 0;\n\t        while ((by = bis.read()) != -1) {\n\t            bos.write(by);\n\t        }\n\t        bis.close();\n\t        bos.close();\n\t    }\n\t\n\t    private static void method2(File srcFile, File destFile) throws IOException{\n\t        FileInputStream fis = new FileInputStream(srcFile);\n\t        FileOutputStream fos = new FileOutputStream(destFile);\n\t\n\t        int len = 0;\n\t        byte[] bytes = new byte[1024];\n\t        while ((len = fis.read(bytes)) != -1) {\n\t            fos.write(bytes,0,len);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t    }\n\t\n\t    private static void method1(File srcFile, File destFile) throws IOException{\n\t        FileInputStream fis = new FileInputStream(srcFile);\n\t        FileOutputStream fos = new FileOutputStream(destFile);\n\t\n\t        int by = 0;\n\t        while ((by = fis.read()) != -1) {\n\t            fos.write(by);\n\t        }\n\t        fis.close();\n\t        fos.close();\n\t    }\n\tC:把集合中的数据存储到文本文件\n\t\tFile srcFile = new File(\"a.txt\");\n\t    List<String> list = new ArrayList<String>();\n\t\n\t    list.add(\"hello\");\n\t    list.add(\"world\");\n\t    list.add(\"java\");\n\t\t//方式一\n\t    FileOutputStream fos = new FileOutputStream(srcFile);\n\t    for (String s : list) {\n\t        fos.write((s).getBytes());\n\t    }\n\t    fos.close();\n\t    //方式二\n\t    FileWriter fw = new FileWriter(srcFile);\n\t    for (String s : list) {\n\t        fw.write(s.toCharArray());\n\t        fw.flush();\n\t    }\n\t    fw.close();\n\t    //方式三\n\t    BufferedWriter bw = new BufferedWriter(new FileWriter(srcFile));\n\t    for (String s : list) {\n\t        bw.write(s);\n\t        bw.flush();\n\t    }\n\t    bw.close();\n\tD:把文本文件中的数据读取到集合并遍历集合\n\t\tFile srcFile = new File(\"a.txt\");\n\t    List<String> list = new ArrayList<String>();\n\t\n\t    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t    String s = null;\n\t    while ((s = br.readLine()) != null) {\n\t        list.add(s);\n\t    }\n\t    br.close();\n\tE:复制单级文件夹\n\t\tFile srcPath = new File(\"F:\\\\struts-1.2.7\");\n\t    File destPath = new File(\"F:\\\\test1\");\n\t\n\t    File[] srcFiles = srcPath.listFiles();\n\t    BufferedInputStream bis = null;\n\t    BufferedOutputStream bos = null;\n\t    if (!destPath.exists()) {\n\t        destPath.mkdir();\n\t    }\n\t    for (File srcFile : srcFiles) {\n\t        if (srcFile.isFile()) {\n\t             bis = new BufferedInputStream(new FileInputStream(srcFile));\n\t             bos = new BufferedOutputStream(\n\t             \tnew FileOutputStream(new File(destPath,srcFile.getName())));\n\t            int len = 0;\n\t            byte[] bytes = new byte[1024];\n\t            while ((len = bis.read(bytes)) != -1) {\n\t                bos.write(bytes, 0, len);\n\t                bos.flush();\n\t            }\n\t        }\n\t    }\n\t    bis.close();\n\t    bos.close();\n\tF:复制单级文件夹中指定的文件\n\t\tFile srcPath = new File(\"F:\\\\test\");\n\t    File destPath = new File(\"F:\\\\test1\");\n\t\n\t    File[] srcFiles = srcPath.listFiles(new FilenameFilter(){\n\t\n\t        @Override\n\t        public boolean accept(File dir, String name) {\n\t            return dir.isFile()&&name.endsWith(\".java\");\n\t        }\n\t    });\n\t    BufferedInputStream bis = null;\n\t    BufferedOutputStream bos = null;\n\t    if (!destPath.exists()) {\n\t        destPath.mkdir();\n\t    }\n\t    for (File srcFile : srcFiles) {\n\t        if (srcFile.isFile()) {\n\t             bis = new BufferedInputStream(new FileInputStream(srcFile));\n\t             bos = new BufferedOutputStream(\n\t             \tnew FileOutputStream(new File(destPath,srcFile.getName())));\n\t            int len = 0;\n\t            byte[] bytes = new byte[1024];\n\t            while ((len = bis.read(bytes)) != -1) {\n\t                bos.write(bytes, 0, len);\n\t                bos.flush();\n\t            }\n\t        }\n\t    }\n\t    bis.close();\n\t    bos.close();\n\tG:复制多级文件夹\n\t\tpublic class CopyDemo {\n\t    public static void main(String[] args) throws IOException {\n\t        File srcPath = new File(\"F:\\\\test\");\n\t        File destPath = new File(\"F:\\\\test1\");\n\t\n\t        copyFolder(srcPath,destPath);\n\t\n\t    }\n\t\n\t    public static void copyFolder(File srcPath, File destPath) throws IOException{\n\t        if (!destPath.exists()) {\n\t            destPath.mkdir();\n\t        }\n\t        File[] files = srcPath.listFiles();\n\t        for (File file : files) {\n\t            if (file.isDirectory()) {\n\t\n\t                copyFolder(file,new File(destPath,file.getName()));\n\t            } else if (file.isFile()) {\n\t                BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));\n\t                BufferedOutputStream bos = new BufferedOutputStream(\n\t                \tnew FileOutputStream(new File(destPath,file.getName())));\n\t                int len = 0;\n\t                byte[] bytes = new byte[1024];\n\t                while ((len = bis.read(bytes)) != -1) {\n\t                    bos.write(bytes,0,len);\n\t                    bos.flush();\n\t                }\n\t                bis.close();\n\t                bos.close();\n\t            }\n\t        }\n\t\n\t    }\n\t\n\t}\n\tH:键盘录入学生信息按照总分从高到低存储到文本文件\n\t\tpublic class CopyDemo {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Scanner sc = new Scanner(System.in);\n\t\t        //比较器返回-1降序，返回1升序\n\t\t        TreeSet<Student> studentList = new TreeSet<Student>(new Comparator<Student>() {\n\t\t            @Override\n\t\t            public int compare(Student o1, Student o2) {\n\t\t                int sum1 = o1.getChinese() + o1.getEnglish() + o1.getMath();\n\t\t                int sum2 = o2.getChinese() + o2.getEnglish() + o2.getMath();\n\t\t                if (sum1 > sum2) {\n\t\t                    return -1;\n\t\t                } else if (sum1 == sum2) {\n\t\t                    if (o1.getName().compareTo(o2.getName()) >=0 ) {\n\t\t                        return -1;\n\t\t                    } else {\n\t\t                        return 1;\n\t\t                    }\n\t\t                } else {\n\t\t                    return 1;\n\t\t                }\n\t\t            }\n\t\t        });\n\t\t        for (int i = 0; i < 3; i++) {\n\t\t            Student st = new Student();\n\t\t            System.out.println(\"请输入学生信息:\");\n\t\t            System.out.println(\"姓名: \");\n\t\t            st.setName(sc.nextLine());\n\t\t            System.out.println(\"语文: \");\n\t\t            st.setChinese(Integer.valueOf(sc.nextLine()));\n\t\t            System.out.println(\"数学: \");\n\t\t            st.setEnglish(Integer.valueOf(sc.nextLine()));\n\t\t            System.out.println(\"英语: \");\n\t\t            st.setMath(Integer.valueOf(sc.nextLine()));\n\t\t            studentList.add(st);\n\t\t        }\n\t\t        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(\"a.txt\")));\n\t\t        for (Student student : studentList) {\n\t\t            bw.write(\"name: \" + student.getName());\n\t\t            bw.newLine();\n\t\t            bw.write(\"chinese: \"+student.getChinese());\n\t\t            bw.newLine();\n\t\t            bw.write(\"english: \" + student.getEnglish());\n\t\t            bw.newLine();\n\t\t            bw.write(\"math: \"+student.getMath());\n\t\t            bw.newLine();\n\t\t            bw.write(\"---------------------\");\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t        bw.close();\n\t\t    }\n\t}\n\t\n\tclass Student {\n\t    private String name;\n\t    private int chinese;\n\t    private int math;\n\t    private int english;\n\t\n\t    public String getName() {\n\t        return name;\n\t    }\n\t\n\t    public void setName(String name) {\n\t        this.name = name;\n\t    }\n\t\n\t    public int getChinese() {\n\t        return chinese;\n\t    }\n\t\n\t    public void setChinese(int chinese) {\n\t        this.chinese = chinese;\n\t    }\n\t\n\t    public int getMath() {\n\t        return math;\n\t    }\n\t\n\t    public void setMath(int math) {\n\t        this.math = math;\n\t    }\n\t\n\t    public int getEnglish() {\n\t        return english;\n\t    }\n\t\n\t    public void setEnglish(int english) {\n\t        this.english = english;\n\t    }\n\t}\n\tI:把某个文件中的字符串排序后输出到另一个文本文件中\n\t\tFile srcFile = new File(\"a.txt\");\n\t    File destFile = new File(\"b.txt\");\n\t\n\t    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n\t    BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\t\n\t    StringBuilder sb = new StringBuilder();\n\t    String s = null;\n\t    while ((s = br.readLine()) != null) {\n\t        sb.append(s);\n\t    }\n\t    char[] ch = sb.toString().toCharArray();\n\t    Arrays.sort(ch);\n\t    bw.write(ch);\n\t    bw.close();\n\t    br.close();\n\tJ:用Reader模拟BufferedReader的特有功能\n\tK:模拟LineNumberReader的特有功能\n# Java多线程\n\n## 1. 多线程(理解)\n\n\t(1)多线程：一个应用程序有多条执行路径\n\t\t进程：正在执行的应用程序\n\t\t线程：进程的执行单元，执行路径\n\t\t单线程：一个应用程序只有一条执行路径\n\t\t多线程：一个应用程序有多条执行路径\n\t\t\n\t\t多进程的意义?\n\t\t\t提高CPU的使用率\n\t\t多线程的意义?\n\t\t\t提高应用程序的使用率\n\t(2)Java程序的运行原理及JVM的启动是多线程的吗?\n\t\tA:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。\n\t\tB:JVM的启动是多线程的，因为它至少有两个线程启动了，主线程和垃圾回收线程。\n\t(3)多线程的实现方案(自己补齐步骤及代码\t掌握)\n\t\tA:继承Thread类\n\t\tpublic class MyThread extends Thread {\n\t\t    @Override\n\t\t    public void run() {\n\t\t        for (int i = 0; i < 10; i++) {\n\t\t            System.out.println(getName() + \":\" + i);\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class MyThreadTest {\n\t\t        public static void main(String[] args) {\n\t\t            MyThread mt = new MyThread();\n\t\t            mt.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t\tB:实现Runnable接口\n\t\tpublic class MyRunnable implements Runnable {\n\t\t    @Override\n\t\t    public void run() {\n\t\t        for (int i = 0; i < 10; i++) {\n\t\t            System.out.println(Thread.currentThread().getName() + \":\" + i);\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class MyRunnableTest {\n\t\t        public static void main(String[] args) {\n\t\t            MyRunnable mr = new MyRunnable();\n\t\t            Thread td = new Thread(mr);\n\t\t\n\t\t            td.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t(4)线程的调度和优先级问题\n\t\tA:线程的调度\n\t\t\ta:分时调度\n\t\t\tb:抢占式调度 (Java采用的是该调度方式)\n\t\tB:获取和设置线程优先级\n\t\t\ta:默认是5\n\t\t\tb:范围是1-10（Thread.MIN_PRIORITY，Thread.MAX_PRIORITY）\n\t(5)线程的控制(常见方法)\n\t\tA:休眠线程：sleep()\n\t\tB:加入线程：join()\n\t\tC:礼让线程：yield()\n\t\tD:后台线程：setDaemon()\n\t\tE:终止线程(掌握)：interrupt()\n\t(6)线程的生命周期(参照\t线程生命周期图解.bmp)\n\t\tA:新建\n\t\tB:就绪\n\t\tC:运行\n\t\tD:阻塞\n\t\tE:死亡\n![线程生命周期图解](https://img-blog.csdn.net/20181003115703845?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\t(7)电影院卖票程序的实现\n\t\tA:继承Thread类\n\t\tpublic class ThreadTicket extends Thread {\n\t\t    private static int ticket = 100;\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t       while (true) {\n\t\t            if (ticket > 0) {\n\t\t                System.out.println(getName() + \"正在售出第\" + ticket-- + \"张票\");\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class ThreadTicketTest {\n\t\t        public static void main(String[] args) {\n\t\t            ThreadTicket threadTicket = new ThreadTicket();\n\t\t            ThreadTicket threadTicket1 = new ThreadTicket();\n\t\t            ThreadTicket threadTicket2 = new ThreadTicket();\n\t\t\n\t\t            threadTicket.start();\n\t\t            threadTicket1.start();\n\t\t            threadTicket2.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t\tB:实现Runnable接口\n\t\tpublic class RunnableTicket implements Runnable {\n\t\t    private int ticket = 100;\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        while (true) {\n\t\t            if (ticket > 0) {\n\t\t                System.out.println(getName() + \"正在售出第\" + ticket-- + \"张票\");\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class RunnableTicketTest {\n\t\t        public static void main(String[] args) {\n\t\t            RunnableTicket rt = new RunnableTicket();\n\t\t            Thread thread = new Thread(rt);\n\t\t            Thread thread1 = new Thread(rt);\n\t\t            Thread thread2 = new Thread(rt);\n\t\t\n\t\t            thread.start();\n\t\t            thread1.start();\n\t\t            thread2.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t(8)电影院卖票程序出问题\n\t\tA:为了更符合真实的场景，加入了休眠100毫秒。\n\t\tB:卖票问题\n\t\t\ta:同票多次\n\t\t\tb:负数票\n\t(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)\n\t\tA:是否有多线程环境\n\t\tB:是否有共享数据\n\t\tC:是否有多条语句操作共享数据\n\t(10)同步解决线程安全问题\n\t\tA:同步代码块\n\t\t\tsynchronized(对象) {\n\t\t\t\t需要被同步的代码;\n\t\t\t}\n\t\t\t\n\t\t\t这里的锁对象可以是任意对象。\n\t\t\t\n\t\tB:同步方法\n\t\t\t把同步加在方法上。\n\t\t\t\n\t\t\t这里的锁对象是this\n\t\t\t\n\t\tC:静态同步方法\n\t\t\t把同步加在方法上。\n\t\t\t\n\t\t\t这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)\n\t(11)回顾以前的线程安全的类\n\t\tA:StringBuffer\n\t\tB:Vector\n\t\tC:Hashtable\n\t\tD:如何把一个线程不安全的集合类变成一个线程安全的集合类\n\t\t\t用Collections工具类的方法即可。\n\t\t\tList<String> list = Collections.synchronizedList(new ArrayList<String>());\n## 1. 多线程(理解)\n\n\t(1)JDK5以后的针对线程的锁定操作和释放操作\n\t\tLock锁\n\t\tpublic class RunnableTicket implements Runnable {\n\t\t    private int ticket = 100;\n\t\t    private ReentrantLock lock = new ReentrantLock();\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        while (true) {\n\t\t            lock.lock();\n\t\t            if (ticket > 0) {\n\t\t            System.out.println(Thread.currentThread().getName() + \"正在售出第\" + ticket-- + \"张票\");\n\t\t                try {\n\t\t                    Thread.sleep(100);\n\t\t                } catch (InterruptedException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t            }\n\t\t            lock.unlock();\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static class RunnableTicketTest {\n\t\t        public static void main(String[] args) {\n\t\t            RunnableTicket rt = new RunnableTicket();\n\t\t            Thread thread = new Thread(rt);\n\t\t            Thread thread1 = new Thread(rt);\n\t\t            Thread thread2 = new Thread(rt);\n\t\t\n\t\t            thread.start();\n\t\t            thread1.start();\n\t\t            thread2.start();\n\t\t        }\n\t\t    }\n\t\t}\n\t(2)死锁问题的描述和代码体现\n\tpublic class DeadLockDemo implements Runnable {\n\t\t    boolean flag;\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        if (flag) {\n\t\t            synchronized (Lock.object1) {\n\t\t                System.out.println(Thread.currentThread().getName() + \"获取了锁object1\");\n\t\t                try {\n\t\t                    Thread.sleep(100);\n\t\t                } catch (InterruptedException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t                synchronized (Lock.object2) {\n\t\t                    System.out.println(Thread.currentThread().getName() + \"获取了锁object2\");\n\t\t                }\n\t\t            }\n\t\t        } else {\n\t\t            synchronized (Lock.object2) {\n\t\t                System.out.println(Thread.currentThread().getName() + \"获取了锁object2\");\n\t\t                try {\n\t\t                    Thread.sleep(100);\n\t\t                } catch (InterruptedException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t                synchronized (Lock.object1) {\n\t\t                    System.out.println(Thread.currentThread().getName() + \"获取了锁object1\");\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t\n\t\t    public static void main(String[] args) {\n\t\t        DeadLockDemo lockDemo = new DeadLockDemo();\n\t\t        DeadLockDemo lockDemo1 = new DeadLockDemo();\n\t\t        lockDemo.flag = true;\n\t\t        Thread td1 = new Thread(lockDemo);\n\t\t        Thread td2 = new Thread(lockDemo1);\n\t\t\n\t\t        td1.start();\n\t\t        td2.start();\n\t\t    }\n\t\t}\n\t\t\n\t\tclass Lock {\n\t\t    public static Object object1 = new Object();\n\t\t    public static Object object2 = new Object();\n\t\t}\n\t(3)生产者和消费者多线程体现(线程间通信问题)\n\t\t以学生作为资源来实现的\n\t\t\n\t\t资源类：Student\n\t\t设置数据类：SetThread(生产者)\n\t\t获取数据类：GetThread(消费者)\n\t\t测试类：StudentDemo\n\t\t\n\t\t代码：\n\t\t\tA:最基本的版本，只有一个数据。\n\t\t\t\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    String name;\n\t\t\t\t    int age;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        student.name = \"xmos\";\n\t\t\t\t        student.age = 23;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            System.out.println(student.name + \":\" + student.age);\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tB:改进版本，给出了不同的数据，并加入了同步机制\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    String name;\n\t\t\t\t    int age;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t    private int x;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        while (true) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                if (x % 2 == 0) {\n\t\t\t\t                    student.name = \"xmos\";\n\t\t\t\t                    student.age = 23;\n\t\t\t\t                } else {\n\t\t\t\t                    student.name = \"tmos\";\n\t\t\t\t                    student.age = 22;\n\t\t\t\t                }\n\t\t\t\t\n\t\t\t\t                x++;\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                System.out.println(student.name + \":\" + student.age);\n\t\t\t\t            }\n\t\t\t\t\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tC:等待唤醒机制改进该程序，让数据能够实现依次的出现\n\t\t\t\twait()\n\t\t\t\tnotify()\n\t\t\t\tnotifyAll() (多生产多消费)\n\t\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    String name;\n\t\t\t\t    int age;\n\t\t\t\t    boolean flag;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t    private int x;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        while (true) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                if (student.flag) {\n\t\t\t\t                    try {\n\t\t\t\t                        student.wait();\n\t\t\t\t                    } catch (InterruptedException e) {\n\t\t\t\t                        e.printStackTrace();\n\t\t\t\t                    }\n\t\t\t\t                }\n\t\t\t\t                if (x % 2 == 0) {\n\t\t\t\t                    student.name = \"xmos\";\n\t\t\t\t                    student.age = 23;\n\t\t\t\t                } else {\n\t\t\t\t                    student.name = \"tmos\";\n\t\t\t\t                    student.age = 22;\n\t\t\t\t                }\n\t\t\t\t                x++;\n\t\t\t\t                student.flag = true;\n\t\t\t\t                student.notify();\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            synchronized (student) {\n\t\t\t\t                if (!student.flag) {\n\t\t\t\t                    try {\n\t\t\t\t                        student.wait();\n\t\t\t\t                    } catch (InterruptedException e) {\n\t\t\t\t                        e.printStackTrace();\n\t\t\t\t                    }\n\t\t\t\t                }\n\t\t\t\t                System.out.println(student.name + \":\" + student.age);\n\t\t\t\t                student.flag = false;\n\t\t\t\t                student.notify();\n\t\t\t\t            }\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tD:等待唤醒机制的代码优化。把数据及操作都写在了资源类中\n\t\t\t\tpublic class ThreadDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student student = new Student();\n\t\t\t\t        GetThread gt = new GetThread(student);\n\t\t\t\t        SetThread st = new SetThread(student);\n\t\t\t\t\n\t\t\t\t        new Thread(gt).start();\n\t\t\t\t        new Thread(st).start();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    private String name;\n\t\t\t\t    private int age;\n\t\t\t\t    private int x;\n\t\t\t\t    private boolean flag;\n\t\t\t\t\n\t\t\t\t    synchronized void setStudent() {\n\t\t\t\t        while (true) {\n\t\t\t\t            if (flag) {\n\t\t\t\t                try {\n\t\t\t\t                    wait();\n\t\t\t\t                } catch (InterruptedException e) {\n\t\t\t\t                    e.printStackTrace();\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t            if (x % 2 == 0) {\n\t\t\t\t                name = \"xmos\";\n\t\t\t\t                age = 23;\n\t\t\t\t            } else {\n\t\t\t\t                name = \"tmos\";\n\t\t\t\t                age = 22;\n\t\t\t\t            }\n\t\t\t\t            x++;\n\t\t\t\t            flag = true;\n\t\t\t\t            notify();\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    synchronized void getStudent() {\n\t\t\t\t        for (int i = 0; i < 100; i++) {\n\t\t\t\t            if (!flag) {\n\t\t\t\t                try {\n\t\t\t\t                    wait();\n\t\t\t\t                } catch (InterruptedException e) {\n\t\t\t\t                    e.printStackTrace();\n\t\t\t\t                }\n\t\t\t\t            }\n\t\t\t\t            System.out.println(name + \":\" + age);\n\t\t\t\t            flag = false;\n\t\t\t\t            notify();\n\t\t\t\t        }\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass SetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public SetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        student.setStudent();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass GetThread implements Runnable {\n\t\t\t\t    private Student student;\n\t\t\t\t\n\t\t\t\t    public GetThread(Student student) {\n\t\t\t\t        this.student = student;\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    @Override\n\t\t\t\t    public void run() {\n\t\t\t\t        student.getStudent();\n\t\t\t\t    }\n\t\t\t\t}\n\t(4)线程组\n\t\tpublic class ThreadGroupDemo {\n\t\t   public static void main(String[] args) {\n\t\t        ThreadGroup tg = new ThreadGroup(\"MyThreadGroup\");\n\t\t        MyRunnable mr = new MyRunnable();\n\t\t        Thread th1 = new Thread(tg, mr, \"xmos\");\n\t\t        Thread th2 = new Thread(tg, mr, \"tmos\");\n\t\t\n\t\t        th1.start();\n\t\t        th2.start();\n\t\t\n\t\t    }\n\t\t}\n\t\t\n\t\tclass MyRunnable implements Runnable {\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        System.out.println(Thread.currentThread().getThreadGroup().getName() + \":\" \n\t\t        \t+ Thread.currentThread().getName());\n\t\t    }\n\t\t}\n\t\t(5)线程池\n\t\t\tpublic class ThreadPoolDemo {\n\t\t\t    public static void main(String[] args) {\n\t\t\t        ExecutorService pool = Executors.newFixedThreadPool(3);\n\t\t\t        MyRunnable mr = new MyRunnable();\n\t\t\t        pool.submit(mr);\n\t\t\t        pool.submit(mr);\n\t\t\t\n\t\t\t        pool.shutdown();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass MyRunnable implements Runnable{\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void run() {\n\t\t\t        System.out.println(Thread.currentThread().getName());\n\t\t\t    }\n\t\t\t}\n\t(6)多线程实现的第三种方案\n\t\tpublic class ThreadPoolDemo {\n\t\t    public static void main(String[] args) {\n\t\t        ExecutorService pool = Executors.newFixedThreadPool(3);\n\t\t        MyCallable mc = new MyCallable();\n\t\t        pool.submit(mc);\n\t\t        pool.submit(mc);\n\t\t\n\t\t        pool.shutdown();\n\t\t    }\n\t\t}\n\t\t\n\t\tclass MyCallable implements Callable {\n\t\t    @Override\n\t\t    public Object call() throws Exception {\n\t\t        System.out.println(Thread.currentThread().getName());\n\t\t        return null;\n\t\t    }\n\t\t}\n\t(7)定时器\n\t\t案例1：\n\t\t\tpublic class TimerDemo {\n\t\t\t    public static void main(String[] args) throws ParseException {\n\t\t\t        Timer t = new Timer();\n\t\t\t        String s = new String(\"2018-10-03 12:46:00\");\n\t\t\t        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\t        Date date = sdf.parse(s);\n\t\t\t        t.schedule(new Boom(), date, 100);\n\t\t\t\n\t\t\t        t.cancel();\n\n\n​\t\t\t\n\t\t\t    }\n\t\t\t}\n\t\t\n\t\tclass Boom extends TimerTask {\n\t\t\n\t\t    @Override\n\t\t    public void run() {\n\t\t        System.out.println(\"Boom!\");\n\t\t    }\n\t\t}\n\t\t案例2：\n\t\t\tpublic class TimerDemo {\n\t\t\t    public static void main(String[] args) throws ParseException {\n\t\t\t        Timer t = new Timer();\n\t\t\t        t.schedule(new Boom(t), 300, 100);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Boom extends TimerTask {\n\t\t\t    private Timer t;\n\t\t\t    int i = 0;\n\t\t\t\n\t\t\t    public Boom(Timer t) {\n\t\t\t        this.t = t;\n\t\t\t    }\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void run() {\n\t\t\t        System.out.println(\"Boom---\" + ++i);\n\t\t\t\n\t\t\t        if (i == 30) {\n\t\t\t            t.cancel();\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t(8)多线程的面试题\n\t\t## 1. 多线程有几种实现方案，分别是哪几种?\n\t\t两种。\n\t\t\n\t\t继承Thread类\n\t\t实现Runnable接口\n\t\t\n\t\t扩展一种：实现Callable接口。这个得和线程池结合。\n\t\n\t\t## 2. 同步有几种方式，分别是什么?\n\t\t\t两种。\n\t\t\t\n\t\t\t同步代码块\n\t\t\t同步方法\n\t\t\n\t\t## 3. 启动一个线程是run()还是start()?它们的区别?\n\t\t\tstart();\n\t\t\t\n\t\t\trun():封装了被线程执行的代码,直接调用仅仅是普通方法的调用\n\t\t\tstart():启动线程，并由JVM自动调用run()方法\n\t\t\n\t\t## 4. sleep()和wait()方法的区别\n\t\t\tsleep():必须指时间;不释放锁。\n\t\t\twait():可以不指定时间，也可以指定时间;释放锁。\n\t\t\n\t\t## 5. 为什么wait(),notify(),notifyAll()等方法都定义在Object类中\n\t\t\t因为这些方法的调用是依赖于锁对象的，而同步代码块的锁对象是任意锁。\n\t\t\t而Object代码任意的对象，所以，定义在这里面。\n\t\t\n\t\t## 6. 线程的生命周期图\n\t\t\t新建 -- 就绪 -- 运行 -- 死亡\n\t\t\t新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡\n\t\t\t建议：画图解释。\n\n\n## 2. 设计模式(理解)\n\n\t(1)面试对象的常见设计原则\n\t\t单一\n\t\t开闭\n\t\t里氏\n\t\t依赖注入\n\t\t接口\n\t\t迪米特\n\t(2)设计模式概述和分类\n\t\tA:经验的总结\n\t\tB:三类\n\t\t\t创建型\n\t\t\t结构型\n\t\t\t行为型\n\t(3)改进的设计模式\n\t\tA:简单工厂模式（Simple Factory Pattern）\n\t\t\tpublic abstract class Animal {\n\t\t\t    public abstract void eat();\n\t\t\t\n\t\t\t    public static Animal getDog() {\n\t\t\t        return new Dog();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static Animal getCat() {\n\t\t\t        return new Cat();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static void main(String[] args) {\n\t\t\t        Animal dog = Animal.getDog();\n\t\t\t        Animal cat = Animal.getCat();\n\t\t\t\n\t\t\t        dog.eat();\n\t\t\t        cat.eat();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Dog extends Animal{\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat(){\n\t\t\t        System.out.println(\"eat bone\");\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Cat extends Animal{\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat() {\n\t\t\t        System.out.println(\"eat fish\");\n\t\t\t    }\n\t\t\t}\n\t\tB:工厂方法模式（Factory Method Pattern）\n\t\t\tpublic abstract class Animal {\n\t\t\t    public abstract void eat();\n\t\t\t\n\t\t\t    public static Animal getDog() {\n\t\t\t        return new Dog();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static Animal getCat() {\n\t\t\t        return new Cat();\n\t\t\t    }\n\t\t\t\n\t\t\t    public static void main(String[] args) {\n\t\t\t        Animal dog = new DogFactory().getAnimal();\n\t\t\t        Animal cat = new CatFactory().getAnimal();\n\t\t\t\n\t\t\t        dog.eat();\n\t\t\t        cat.eat();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tinterface AnimalFactory {\n\t\t\t    Animal getAnimal();\n\t\t\t}\n\t\t\t\n\t\t\tclass DogFactory implements AnimalFactory {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public Animal getAnimal() {\n\t\t\t        return new Dog();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass CatFactory implements AnimalFactory {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public Animal getAnimal() {\n\t\t\t        return new Cat();\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Dog extends Animal {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat() {\n\t\t\t        System.out.println(\"eat bone\");\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tclass Cat extends Animal {\n\t\t\t\n\t\t\t    @Override\n\t\t\t    public void eat() {\n\t\t\t        System.out.println(\"eat fish\");\n\t\t\t    }\n\t\t\t}\n\t\tC:单例模式(Singleton Pattern掌握)\n\t\t\ta:饿汉式（开发常用）\n\t\t\t\tpublic class TeacherDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Teacher t1 = Teacher.getTeacher();\n\t\t\t\t        Teacher t2 = Teacher.getTeacher();\n\t\t\t\t\n\t\t\t\t        System.out.println(t1 == t2);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Teacher {\n\t\t\t\t    private static Teacher teacher = new Teacher();\n\t\t\t\t\n\t\t\t\t    private Teacher() {\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    public static Teacher getTeacher() {\n\t\t\t\t        return teacher;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\tb:懒汉式（面试常用，容易有线程安全问题，需要线程同步）\n\t\t\t\tpublic class StudentDemo {\n\t\t\t\t    public static void main(String[] args) {\n\t\t\t\t        Student s1 = Student.getStudent();\n\t\t\t\t        Student s2 = Student.getStudent();\n\t\t\t\t\n\t\t\t\t        System.out.println(s1 == s2);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tclass Student {\n\t\t\t\t    private static Student student = null;\n\t\t\t\t\n\t\t\t\t    private Student() {\n\t\t\t\t    }\n\t\t\t\t\n\t\t\t\t    public synchronized static Student getStudent() {\n\t\t\t\t        if (Objects.isNull(student)) {\n\t\t\t\t            student = new Student();\n\t\t\t\t        }\n\t\t\t\t        return student;\n\t\t\t\t    }\n\t\t\t\t}\n\t(4)Runtime\n\t\tJDK提供的一个单例模式应用的类。\n\t\t还可以调用系统命令。\n\t\tpublic class RuntimeDemo {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Runtime r = Runtime.getRuntime();\n\t\t        r.exec(\"touch 1.txt\");\n\t\t    }\n\t\t}\n\n# JavaGUI\n\n# Java网络编程\n\n## 1. 网络编程(理解)\n```java\n(1)网络编程：用Java语言实现计算机间数据的信息传递和资源共享\n(2)网络编程模型\n\t应用层-表示层-会话层-传输层-网络层-数据链路层-物理层\n(3)网络编程的三要素\n\tA:IP地址\n\t\ta:点分十进制：192.168.1.1\n\t\tb:IP地址的组成：网络号段+主机号段\n\t\tc:IP地址的分类：\n\t\t\tA类\t1.0.0.1---127.255.255.254\t\n\t\t\t\t(1)10.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t(2)127.X.X.X是保留地址，用做循环测试用的。\n\t\t\tB类\t128.0.0.1---191.255.255.254\t172.16.0.0---172.31.255.255是私有地址。169.254.X.X是保留地址。\n\t\t\tC类\t192.0.0.1---223.255.255.254\t192.168.X.X是私有地址\n\t\t\tD类\t224.0.0.1---239.255.255.254 \t\n\t\t\tE类\t240.0.0.1---247.255.255.254\n\t\td:dos命令\n\t\t\tipconfig; telnet; ping\n\t\te:InetAddress\n\t\t\tpublic class IPDemo {\n\t\t\t    public static void main(String[] args) throws UnknownHostException {\n\t\t\t        InetAddress ip = InetAddress.getByName(\"192.168.2.203\");\n\t\t\t        System.out.println(ip.getHostName() + \":\" + ip.getHostAddress());\n\t\t\t    }\n\t\t\t}\n\tB:端口\n\t\t是应用程序的标识。范围：0-65535。其中0-1024不建议使用。\n\tC:协议\n\t\tUDP:数据打包,有限制,不连接,效率高,不可靠\n\t\tTCP:建立数据通道,无限制,效率低,可靠\n(3)Socket机制\n\tA:通信两端都应该有Socket对象\n\tB:所有的通信都是通过Socket间的IO进行操作的\n(4)UDP协议发送和接收数据(掌握 自己补齐代码)\n\t发送：\n\t\t创建UDP发送端的Socket对象\n\t\t创建数据并把数据打包\n\t\t发送数据\n\t\t释放资源\n\t接收：\n\t\t创建UDP接收端的Socket对象\n\t\t创建数据包用于接收数据\n\t\t接收数据\n\t\t解析数据包\n\t\t释放资源\n\t\t\n(5)TCP协议发送和接收数据(掌握 自己补齐代码)\n\t发送：\n\t\t创建TCP客户端的Socket对象\n\t\t获取输出流，写数据\n\t\t释放资源\n\t\t\n\t接收：\n\t\t创建TCP服务器端的Socket对象\n\t\t监听客户端连接\n\t\t获取输入流，读取数据\n\t\t释放资源\n(6)案例：\n\tA:UDP\n\t\ta:最基本的UDP协议发送和接收数据\n\t\tb:把发送数据改进为键盘录入\n\t\t发送端：\n\t\tpublic class SendSocket {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        //设置socket发送的端口号，不设置的则为随机端口号\n\t\t        DatagramSocket ds = new DatagramSocket(12307);\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t        String s = null;\n\t\t        while ((s = br.readLine()) != null) {\n\t\t            if (Objects.equals(s, \"bye\")) {\n\t\t                break;\n\t\t            }\n\t\t            byte[] bytes = s.getBytes();\n\t\t            DatagramPacket dp = new DatagramPacket(\n\t\t            \tbytes, bytes.length, InetAddress.getByName(\"192.168.2.203\"), 12306);\n\t\t            ds.send(dp);\n\t\t        }\n\t\t        ds.close();\n\t\t    }\n\t\t}\n\t\t接收端：\n\t\tpublic class ReceiveSocket {\n\t\t\t\t\t    public static void main(String[] args) throws IOException {\n\t\t\t\t\t        //设置socket接收的端口号\n\t\t\t\t\t        DatagramSocket ds = new DatagramSocket(12306);\n\t\t\t\t\t        while (true) {\n\t\t\t\t\t            byte[] bytes = new byte[1024];\n\t\t\t\t\t            DatagramPacket dp = new DatagramPacket(bytes, bytes.length);\n\t\t\t\t\t            ds.receive(dp);\n\t\t\t\t\t            String s = new String(dp.getData(), 0, dp.getLength());\n\t\t\t\t\t            System.out.println(dp.getAddress().getHostAddress() + \":\" + dp.getPort() + \"\\n\" + s);\n\t\t\t\t\t        }\n\t\t\t\t\t\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\tc:一个简易聊天小程序并用多线程改进\n\t\tpublic class ChatRoom {\n\t\t    public static void main(String[] args) {\n\t\t        Thread sendThread = new Thread(new Runnable() {\n\t\t            @Override\n\t\t            public void run() {\n\t\t                try {\n\t\t                    DatagramSocket ds = new DatagramSocket(12307);\n\t\t                    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t                    String s = null;\n\t\t                    while ((s = br.readLine()) != null) {\n\t\t                        if (Objects.equals(s, \"bye\")) {\n\t\t                            break;\n\t\t                        }\n\t\t                        byte[] bytes = s.getBytes();\n\t\t                        DatagramPacket dp = new DatagramPacket(\n\t\t                        \tbytes, bytes.length, InetAddress.getByName(\"192.168.2.203\"), 12306);\n\t\t                        ds.send(dp);\n\t\t                    }\n\t\t                    ds.close();\n\t\t                } catch (IOException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t            }\n\t\t        });\n\t\t        Thread receiveThread = new Thread(new Runnable() {\n\t\t            @Override\n\t\t            public void run() {\n\t\t                try {\n\t\t                    DatagramSocket ds = new DatagramSocket(12306);\n\t\t                    while (true) {\n\t\t                        byte[] bytes = new byte[1024];\n\t\t                        DatagramPacket dp = new DatagramPacket(bytes, bytes.length);\n\t\t                        ds.receive(dp);\n\t\t                        String s = new String(dp.getData(), 0, dp.getLength());\n\t\t                        System.out.println(dp.getAddress().getHostAddress() + \":\" + dp.getPort() + \"\\n\" + s);\n\t\t                    }\n\t\t                } catch (IOException e) {\n\t\t                    e.printStackTrace();\n\t\t                }\n\t\t            }\n\t\t        });\n\t\t\n\t\t        sendThread.start();\n\t\t        receiveThread.start();\n\t\t    }\n\t\t}\n\tB:TCP\n\t\ta:最基本的TCP协议发送和接收数据\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"192.168.2.203\", 8809);\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t        \n\t\t        bw.write(\"hello tcp\");\n\t\t        bw.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket server = new ServerSocket(8809);\n\t\t        Socket s = server.accept();\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        System.out.println(br.readLine());\n\t\t        br.close();\n\t\t    }\n\t\t}\n\t\tb:服务器给出反馈\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"192.168.2.203\", 8809);\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t\n\t\t        bw.write(\"hello tcp\");\n\t\t        bw.flush();\n\t\t\n\t\t        //给服务端发送停止写入的信号，否则服务端会一直阻塞\n\t\t        client.shutdownOutput();\n\t\t\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\n\t\t        System.out.println(br.readLine());\n\t\t\n\t\t        bw.close();\n\t\t        br.close();\n\t\t        client.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket server = new ServerSocket(8809);\n\t\t        Socket s = server.accept();\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        System.out.println(br.readLine());\n\t\t\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n\t\t        bw.write(\"已收到\");\n\t\t        bw.flush();\n\t\t\n\t\t        bw.close();\n\t\t        br.close();\n\t\t        server.close();\n\t\t        server.close();\n\t\t    }\n\t\t}\n\t\tc:客户端键盘录入服务器控制台输出\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"192.168.2.203\", 8809);\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t\n\t\t        String s = null;\n\t\t        while ((s = br.readLine()) != null) {\n\t\t            if (Objects.equals(s, \"bye\")) {\n\t\t                break;\n\t\t            }\n\t\t            bw.write(s);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        //给服务端发送停止写入的信号，否则服务端会一直阻塞\n\t\t        client.shutdownOutput();\n\t\t\n\t\t        br.close();\n\t\t        bw.close();\n\t\t        client.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket server = new ServerSocket(8809);\n\t\t        Socket s = server.accept();\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        String client = null;\n\t\t        while ((client = br.readLine()) != null) {\n\t\t            System.out.println(client);\n\t\t        }\n\t\t\n\t\t        br.close();\n\t\t        s.close();\n\t\t        server.close();\n\t\t    }\n\t\t}\n\t\td:客户端键盘录入服务器写到文本文件\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket s = new Socket(\"192.168.2.203\",8809);\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n\t\t\n\t\t        String msg = null;\n\t\t        while ((msg = br.readLine()) != null){\n\t\t            if (Objects.equals(msg, \"bye\")) {\n\t\t                break;\n\t\t            }\n\t\t            bw.write(msg);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        s.shutdownOutput();\n\t\t\n\t\t        BufferedReader br1 = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t        System.out.println(br1.readLine());\n\t\t\n\t\t        br.close();\n\t\t        br1.close();\n\t\t        bw.close();\n\t\t        s.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        ServerSocket ss = new ServerSocket(8809);\n\t\t        Socket s = ss.accept();\n\t\t\n\t\t        BufferedWriter bw = new BufferedWriter(new FileWriter(\"test.txt\"));\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));\n\t\t\n\t\t        String msg = null;\n\t\t        while ((msg = br.readLine()) != null) {\n\t\t            bw.write(msg);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        BufferedWriter bw1 = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n\t\t        bw1.write(\"已全部接收！\");\n\t\t        bw1.newLine();\n\t\t        bw1.flush();\n\t\t\n\t\t        br.close();\n\t\t        bw.close();\n\t\t        bw1.close();\n\t\t        s.close();\n\t\t        ss.close();\n\t\t    }\n\t\t}\n\t\te:客户端读取文本文件服务器控制台输出\n\t\tclient：\n\t\tpublic class Client {\n\t\t    public static void main(String[] args) throws IOException {\n\t\t        Socket client = new Socket(\"localhost\", 8808);\n\t\t\n\t\t        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"1.txt\")));\n\t\t        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(client.getOutputStream()));\n\t\t\n\t\t        String s = null;\n\t\t        while ((s = br.readLine()) != null) {\n\t\t            bw.write(s);\n\t\t            bw.newLine();\n\t\t            bw.flush();\n\t\t        }\n\t\t\n\t\t        bw.close();\n\t\t        br.close();\n\t\t        client.close();\n\t\t    }\n\t\t}\n\t\tserver：\n\t\tpublic class Server {\n\t\t\tpublic static void main(String[] args) throws IOException {\n\t\t\t\tServerSocket server = new ServerSocket(8808);\n\n\t\t\t\tSocket client = server.accept();\n\n\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));\n\n\t\t\t\tString s = null;\n\t\t\t\twhile ((s = br.readLine()) != null) {\n\t\t\t\t\tSystem.out.println(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\tf:客户端读取文本文件服务器写到文本文件\n\t\tg:上传图片\n\t\th:多线程改进上传文件\n```\n# Java反射\n## 1. 反射(理解)\n```java\n(1)类的加载及类加载器\n(2)反射：\n\t通过字节码文件对象，去使用成员变量，构造方法，成员方法\n(3)反射的使用\n\tA:通过反射获取构造方法并使用\n\tB:通过反射获取成员变量并使用\n\tC:通过反射获取成员方法并使用\n(4)反射案例\n\tA:通过反射运行配置文件的内容\n\tB:通过反射越过泛型检查\n\tC:通过反射给任意的一个对象的任意的属性赋值为指定的值\n(5)动态代理\n```\n## 2. 设计模式\n```java\n(1)装饰设计模式\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\n\tScanner sc = new Scanner(System.in);\n(2)模版设计模式\n```\n## 3. JDK新特性\n```java\n(1)JDK5(掌握)\n\t装箱和拆箱\n\t泛型\n\t增强for\n\t静态导入\n\t可变参数\n\t枚举\n(2)JDK6(了解)\n(3)JDK7(理解)\n\t二进制的表现形式\n\t用_分隔数据\n\tswitch语句可是用字符串\n\t泛型推断(菱形泛型)\n\t多catch的使用\n\t自动释放资源的用法\n(4)JDK8(了解)\n\t可以去网上了解资料\n```","slug":"Java学习笔记","published":1,"updated":"2019-09-02T16:09:10.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck037qbqm000fliyd3ehlicg9","content":"<h1 id=\"计算机的基础知识\"><a href=\"#计算机的基础知识\" class=\"headerlink\" title=\"计算机的基础知识\"></a>计算机的基础知识</h1><h2 id=\"1-计算机概述-了解\"><a href=\"#1-计算机概述-了解\" class=\"headerlink\" title=\"1. 计算机概述(了解)\"></a>1. 计算机概述(了解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)计算机</span><br><span class=\"line\">(<span class=\"number\">2</span>)计算机硬件</span><br><span class=\"line\">(<span class=\"number\">3</span>)计算机软件</span><br><span class=\"line\">\t系统软件：window,linux,mac</span><br><span class=\"line\">\t应用软件：qq,yy,飞秋</span><br><span class=\"line\">(<span class=\"number\">4</span>)软件开发(理解)</span><br><span class=\"line\">\t软件：是由数据和指令组成的。(计算器)</span><br><span class=\"line\">\t开发：就是把软件做出来。</span><br><span class=\"line\">\t如何实现软件开发呢?</span><br><span class=\"line\">\t\t就是使用开发工具和计算机语言做出东西来</span><br><span class=\"line\">(<span class=\"number\">5</span>)语言</span><br><span class=\"line\">\t自然语言：人与人交流沟通的</span><br><span class=\"line\">\t计算机语言：人与计算机交流沟通的</span><br><span class=\"line\">\t\tC,C++,C#,Java</span><br><span class=\"line\">(<span class=\"number\">6</span>)人机交换</span><br><span class=\"line\">\t图形界面：操作方便只管</span><br><span class=\"line\">\tDOS命令：需要记忆一些常见的命令</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-键盘功能键的认识和快捷键-掌握\"><a href=\"#2-键盘功能键的认识和快捷键-掌握\" class=\"headerlink\" title=\"2. 键盘功能键的认识和快捷键(掌握)\"></a>2. 键盘功能键的认识和快捷键(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)功能键的认识</span><br><span class=\"line\">\ttab</span><br><span class=\"line\">\tshift</span><br><span class=\"line\">\tctrl</span><br><span class=\"line\">\talt</span><br><span class=\"line\">\twindos</span><br><span class=\"line\">\t空格</span><br><span class=\"line\">\t上下左右</span><br><span class=\"line\">\t回车</span><br><span class=\"line\">\t截图</span><br><span class=\"line\">(<span class=\"number\">2</span>)快捷键</span><br><span class=\"line\">\t全选\tCtrl+A</span><br><span class=\"line\">\t复制\tCtrl+C</span><br><span class=\"line\">\t粘贴\tCtrl+V</span><br><span class=\"line\">\t剪切\tCtrl+X</span><br><span class=\"line\">\t撤销\tCtrl+Z</span><br><span class=\"line\">\t保存\tCtrl+S</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-常见的DOS命令-掌握\"><a href=\"#3-常见的DOS命令-掌握\" class=\"headerlink\" title=\"3. 常见的DOS命令(掌握)\"></a>3. 常见的DOS命令(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)常见的如下</span><br><span class=\"line\">\t盘符的切换</span><br><span class=\"line\">\t\td:回车</span><br><span class=\"line\">\t目录的进入</span><br><span class=\"line\">\t\tcd javase</span><br><span class=\"line\">\t\tcd javase\\day01\\code</span><br><span class=\"line\">\t目录的回退</span><br><span class=\"line\">\t\tcd..</span><br><span class=\"line\">\t\tcd\\</span><br><span class=\"line\">\t清屏</span><br><span class=\"line\">\t\tcls</span><br><span class=\"line\">\t退出</span><br><span class=\"line\">\t\texit</span><br><span class=\"line\">(<span class=\"number\">2</span>)其他的几个(了解)</span><br><span class=\"line\">\t创建目录</span><br><span class=\"line\">\t\tmkdir</span><br><span class=\"line\">\t删除目录</span><br><span class=\"line\">\t\trmdir</span><br><span class=\"line\">\t创建文件</span><br><span class=\"line\">\t\tedit</span><br><span class=\"line\">\t删除文件</span><br><span class=\"line\">\t\tdel</span><br><span class=\"line\">\t显示目录下的内容</span><br><span class=\"line\">\t\tdir</span><br><span class=\"line\">\t删除带内容的目录</span><br><span class=\"line\">\t\trd /s/q</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-Java语言概述-了解\"><a href=\"#4-Java语言概述-了解\" class=\"headerlink\" title=\"4. Java语言概述(了解)\"></a>4. Java语言概述(了解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)Java语言的发展史</span><br><span class=\"line\">\tJava之父</span><br><span class=\"line\">\tJDK1.4.2</span><br><span class=\"line\">\tJDK5</span><br><span class=\"line\">\tJDK7</span><br><span class=\"line\">(<span class=\"number\">2</span>)Java语言的特点</span><br><span class=\"line\">\t有很多小特点，重点有两个开源，跨平台</span><br><span class=\"line\">(<span class=\"number\">3</span>)Java语言是跨平台的，请问是如何保证的呢?(理解)</span><br><span class=\"line\">\t我们是通过翻译的案例讲解的。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t针对不同的操作系统，提供不同的jvm来实现的。</span><br><span class=\"line\">(<span class=\"number\">4</span>)Java语言的平台</span><br><span class=\"line\">\tJavaSE</span><br><span class=\"line\">\tJavaME--Android</span><br><span class=\"line\">\tJavaEE</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-JDK-JRE-JVM的作用及关系-掌握\"><a href=\"#5-JDK-JRE-JVM的作用及关系-掌握\" class=\"headerlink\" title=\"5. JDK,JRE,JVM的作用及关系(掌握)\"></a>5. JDK,JRE,JVM的作用及关系(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)作用</span><br><span class=\"line\">\tJVM：保证Java语言跨平台</span><br><span class=\"line\">\tJRE：Java程序的运行环境</span><br><span class=\"line\">\tJDK：Java程序的开发环境</span><br><span class=\"line\">(<span class=\"number\">2</span>)关系</span><br><span class=\"line\">\tJDK：JRE+工具</span><br><span class=\"line\">\tJRE：JVM+类库</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-JDK的下载-安装-卸载-掌握\"><a href=\"#6-JDK的下载-安装-卸载-掌握\" class=\"headerlink\" title=\"6. JDK的下载,安装,卸载(掌握)\"></a>6. JDK的下载,安装,卸载(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)下载到官网。</span><br><span class=\"line\">\tA:也可以到百度搜索即可。</span><br><span class=\"line\">\tB:我给你。</span><br><span class=\"line\">(<span class=\"number\">2</span>)安装</span><br><span class=\"line\">\tA:绿色版\t解压就可以使用</span><br><span class=\"line\">\tB:安装版\t必须一步一步的安装，一般只要会点击下一步即可</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t注意：</span><br><span class=\"line\">\t\t建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。</span><br><span class=\"line\">(<span class=\"number\">3</span>)卸载</span><br><span class=\"line\">\tA:绿色版\t直接删除文件夹</span><br><span class=\"line\">\tB:安装版\t</span><br><span class=\"line\">\t\ta:控制面板 -- 添加删除程序</span><br><span class=\"line\">\t\tb:通过专业的软件卸载工具。(比如<span class=\"number\">360</span>的软件管家卸载)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-第一个程序：HelloWorld案例-掌握\"><a href=\"#7-第一个程序：HelloWorld案例-掌握\" class=\"headerlink\" title=\"7. 第一个程序：HelloWorld案例(掌握)\"></a>7. 第一个程序：HelloWorld案例(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"HelloWorld\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span>)程序解释：</span><br><span class=\"line\">\tA:Java程序的最基本单位是类，所以我们要定义一个类。</span><br><span class=\"line\">\t\t格式：<span class=\"class\"><span class=\"keyword\">class</span> 类名</span></span><br><span class=\"line\"><span class=\"class\">\t\t举例：<span class=\"title\">class</span> <span class=\"title\">HelloWorld</span></span></span><br><span class=\"line\">\tB:在类中写内容的时候，用大括号括起来。</span><br><span class=\"line\">\tC:Java程序要想执行，必须有main方法。</span><br><span class=\"line\">\t\t格式：<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">\tD:要指向哪些东西呢，也用大括号括起来。</span></span><br><span class=\"line\"><span class=\"function\">\tE:你要做什么呢?今天我们仅仅做了一个简单的输出</span></span><br><span class=\"line\"><span class=\"function\">\t\t格式：System.out.<span class=\"title\">println</span><span class=\"params\">(<span class=\"string\">\"HelloWorld\"</span>)</span></span>;</span><br><span class=\"line\">\t\t注意：<span class=\"string\">\"\"</span>里面的内容是可以改动的。</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">2</span>)Java程序的开发执行流程：</span><br><span class=\"line\">\tA:编写java源程序(.java)</span><br><span class=\"line\">\tB:通过javac命令编译生成.class文件</span><br><span class=\"line\">\tC:通过java命令运行.class文件</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-常见的问题-掌握\"><a href=\"#8-常见的问题-掌握\" class=\"headerlink\" title=\"8. 常见的问题(掌握)\"></a>8. 常见的问题(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)扩展名被隐藏</span><br><span class=\"line\">\t如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾</span><br><span class=\"line\">(<span class=\"number\">2</span>)我要求文件名称和类名一致。</span><br><span class=\"line\">\t实际上不这样做也是可以的。</span><br><span class=\"line\">\t但是，注意：</span><br><span class=\"line\">\t\tjavac后面跟的是文件名+扩展名</span><br><span class=\"line\">\t\tjava后面跟的类名不带扩展名</span><br><span class=\"line\">(<span class=\"number\">3</span>)Java语言严格区分大小写，请注意。</span><br><span class=\"line\">\t 还有就是单词不要写错了。</span><br><span class=\"line\">(<span class=\"number\">4</span>)见到非法字符: \\<span class=\"number\">65307</span>肯定是中文问题。</span><br><span class=\"line\">\t我们写程序要求标点符号必须全部是英文状态。</span><br><span class=\"line\">(<span class=\"number\">5</span>)括号的配对问题。</span><br><span class=\"line\">\t一般来说，括号都是成对出现的。</span><br><span class=\"line\">(<span class=\"number\">6</span>)遇到</span><br><span class=\"line\">\t在类 HelloWorld 中找不到主方法, 请将主方法定义为</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">\t肯定是主方法的格式问题。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-path环境变量-掌握\"><a href=\"#9-path环境变量-掌握\" class=\"headerlink\" title=\"9. path环境变量(掌握)\"></a>9. path环境变量(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)path环境变量的作用</span><br><span class=\"line\">\t保证javac命令可以在任意目录下运行。</span><br><span class=\"line\">\t同理可以配置qq等</span><br><span class=\"line\">(<span class=\"number\">2</span>)path配置的两种方案：</span><br><span class=\"line\">\tA:方案<span class=\"number\">1</span>(了解)</span><br><span class=\"line\">\tB:方案<span class=\"number\">2</span></span><br><span class=\"line\">\t\t找到环境变量的位置，在系统变量里面</span><br><span class=\"line\">\t\t新建：</span><br><span class=\"line\">\t\t\t变量名：JAVA_HOME</span><br><span class=\"line\">\t\t\t变量值：D:\\develop\\Java\\jdk1.7.0_60</span><br><span class=\"line\">\t\t修改：</span><br><span class=\"line\">\t\t\t变量名：Path</span><br><span class=\"line\">\t\t\t变量值：%JAVA_HOME%\\bin;以前的内容</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-classpath环境变量-理解\"><a href=\"#10-classpath环境变量-理解\" class=\"headerlink\" title=\"10. classpath环境变量(理解)\"></a>10. classpath环境变量(理解)</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)classpath环境变量的作用</span><br><span class=\"line\">\t保证<span class=\"class\"><span class=\"keyword\">class</span>文件可以在任意目录下运行</span></span><br><span class=\"line\"><span class=\"class\">(2)<span class=\"title\">classpath</span>环境变量的配置</span></span><br><span class=\"line\"><span class=\"class\">\t找到环境变量的位置，在系统变量里面</span></span><br><span class=\"line\"><span class=\"class\">\t新建：</span></span><br><span class=\"line\"><span class=\"class\">\t\t变量名：<span class=\"title\">classpath</span></span></span><br><span class=\"line\">\t\t变量值：E:\\JavaSE\\day01\\code\\HelloWorld案例</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java语言基础\"><a href=\"#Java语言基础\" class=\"headerlink\" title=\"Java语言基础\"></a>Java语言基础</h1><h2 id=\"1-关键字-掌握\"><a href=\"#1-关键字-掌握\" class=\"headerlink\" title=\"1. 关键字(掌握)\"></a>1. 关键字(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)被Java语言赋予特定含义的单词</span><br><span class=\"line\">(<span class=\"number\">2</span>)特点：</span><br><span class=\"line\">\t全部小写。</span><br><span class=\"line\">(<span class=\"number\">3</span>)注意事项：</span><br><span class=\"line\">\tA:goto和<span class=\"keyword\">const</span>作为保留字存在。</span><br><span class=\"line\">\tB:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-标识符-掌握\"><a href=\"#2-标识符-掌握\" class=\"headerlink\" title=\"2. 标识符(掌握)\"></a>2. 标识符(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)就是给类，接口，方法，变量等起名字的字符序列</span><br><span class=\"line\">(<span class=\"number\">2</span>)组成规则：</span><br><span class=\"line\">\tA:英文大小写字母</span><br><span class=\"line\">\tB:数字</span><br><span class=\"line\">\tC:$和_</span><br><span class=\"line\">(<span class=\"number\">3</span>)注意事项：</span><br><span class=\"line\">\tA:不能以数字开头</span><br><span class=\"line\">\tB:不能是java中的关键字</span><br><span class=\"line\">\tC:区分大小写</span><br><span class=\"line\">(<span class=\"number\">4</span>)常见的命名规则(见名知意)</span><br><span class=\"line\">\tA:包\t全部小写</span><br><span class=\"line\">\t\t单级包：小写</span><br><span class=\"line\">\t\t\t举例：liuyi,com</span><br><span class=\"line\">\t\t多级包：小写，并用.隔开</span><br><span class=\"line\">\t\t\t举例：cn.itcast,com.baidu\t\t\t\t</span><br><span class=\"line\">\tB:类或者接口</span><br><span class=\"line\">\t\t一个单词：首字母大写</span><br><span class=\"line\">\t\t\t举例：Student,Demo</span><br><span class=\"line\">\t\t多个单词：每个单词首字母大写</span><br><span class=\"line\">\t\t\t举例：HelloWorld,StudentName</span><br><span class=\"line\">\tC:方法或者变量</span><br><span class=\"line\">\t\t一个单词：首字母小写</span><br><span class=\"line\">\t\t\t举例：name,main</span><br><span class=\"line\">\t\t多个单词：从第二个单词开始，每个单词首字母大写</span><br><span class=\"line\">\t\t\t举例：studentAge,showAllNames()</span><br><span class=\"line\">\tD:常量</span><br><span class=\"line\">\t\t全部大写</span><br><span class=\"line\">\t\t一个单词：大写</span><br><span class=\"line\">\t\t\t举例：PI</span><br><span class=\"line\">\t\t多个单词：大写，并用_隔开</span><br><span class=\"line\">\t\t\t举例：STUDENT_MAX_AGE</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-注释-掌握\"><a href=\"#3-注释-掌握\" class=\"headerlink\" title=\"3. 注释(掌握)\"></a>3. 注释(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)就是对程序进行解释说明的文字</span><br><span class=\"line\">(<span class=\"number\">2</span>)分类：</span><br><span class=\"line\">\tA:单行注释\t<span class=\"comment\">//</span></span><br><span class=\"line\">\tB:多行注释\t<span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"comment\">\tC:文档注释(后面讲) /** */</span></span><br><span class=\"line\">(<span class=\"number\">3</span>)把HelloWorld案例写了一个带注释的版本。</span><br><span class=\"line\">\t后面我们要写一个程序的过程。</span><br><span class=\"line\">\t需求：</span><br><span class=\"line\">\t分析：</span><br><span class=\"line\">\t实现：</span><br><span class=\"line\">\t代码体现：</span><br><span class=\"line\">(<span class=\"number\">4</span>)注释的作用</span><br><span class=\"line\">\tA:解释说明程序，提高了代码的阅读性。</span><br><span class=\"line\">\tB:可以帮助我们调试程序。</span><br><span class=\"line\">\t\t后面我们会讲解一个更高端的一个调试工具</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-常量-掌握\"><a href=\"#4-常量-掌握\" class=\"headerlink\" title=\"4. 常量(掌握)\"></a>4. 常量(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)在程序执行的过程中，其值不发生改变的量</span><br><span class=\"line\">(<span class=\"number\">2</span>)分类：</span><br><span class=\"line\">\tA:字面值常量</span><br><span class=\"line\">\tB:自定义常量(后面讲)</span><br><span class=\"line\">(<span class=\"number\">3</span>)字面值常量</span><br><span class=\"line\">\tA:字符串常量 <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">\tB:整数常量\t<span class=\"number\">12</span>,<span class=\"number\">23</span></span><br><span class=\"line\">\tC:小数常量\t<span class=\"number\">12.345</span></span><br><span class=\"line\">\tD:字符常量\t<span class=\"string\">'a'</span>,<span class=\"string\">'A'</span>,<span class=\"string\">'0'</span></span><br><span class=\"line\">\tE:布尔常量\t<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span></span><br><span class=\"line\">\tF:空常量\t<span class=\"keyword\">null</span>(后面讲)</span><br><span class=\"line\">(<span class=\"number\">4</span>)在Java中针对整数常量提供了四种表现形式</span><br><span class=\"line\">\tA:二进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>组成。以<span class=\"number\">0</span>b开头。</span><br><span class=\"line\">\tB:八进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>，...<span class=\"number\">7</span>组成。以<span class=\"number\">0</span>开头。</span><br><span class=\"line\">\tC:十进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>，...<span class=\"number\">9</span>组成。整数默认是十进制。</span><br><span class=\"line\">\tD:十六进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>，...<span class=\"number\">9</span>,a,b,c,d,e,f(大小写均可)组成。以<span class=\"number\">0</span>x开头。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-进制转换-了解\"><a href=\"#5-进制转换-了解\" class=\"headerlink\" title=\"5. 进制转换(了解)\"></a>5. 进制转换(了解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)其他进制到十进制</span><br><span class=\"line\">\t系数：就是每一个位上的数值</span><br><span class=\"line\">\t基数：x进制的基数就是x</span><br><span class=\"line\">\t权：对每一个位上的数据，从右，并且从<span class=\"number\">0</span>开始编号，对应的编号就是该数据的权。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t结果：系数*基数^权次幂之和。</span><br><span class=\"line\">(<span class=\"number\">2</span>)十进制到其他进制</span><br><span class=\"line\">\t除基取余，直到商为<span class=\"number\">0</span>，余数反转。</span><br><span class=\"line\">(<span class=\"number\">3</span>)进制转换的快速转换法</span><br><span class=\"line\">\tA:十进制和二进制间的转换</span><br><span class=\"line\">\t\t<span class=\"number\">8421</span>码。</span><br><span class=\"line\">\tB:二进制到八进制，十六进制的转换</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-变量-掌握\"><a href=\"#6-变量-掌握\" class=\"headerlink\" title=\"6. 变量(掌握)\"></a>6. 变量(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)在程序的执行过程中，其值在某个范围内可以发生改变的量</span><br><span class=\"line\">(<span class=\"number\">2</span>)变量的定义格式：</span><br><span class=\"line\">\tA:数据类型 变量名 = 初始化值;</span><br><span class=\"line\">\tB:数据类型 变量名;</span><br><span class=\"line\">\t  变量名 = 初始化值;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-数据类型-掌握\"><a href=\"#7-数据类型-掌握\" class=\"headerlink\" title=\"7. 数据类型(掌握)\"></a>7. 数据类型(掌握)</h2><pre><code>(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。\n(2)分类：\n    A:基本数据类型：4类8种\n    B:引用数据类型：类，接口，数组。\n(3)基本数据类型\n    A:整数            占用字节数\n        byte            1\n        short            2\n        int             4\n        long            8\n    B:浮点数\n        float            4\n        double            8\n    C:字符\n        char            2\n    D:布尔\n        boolean            1\n\n    注意：\n        整数默认是int类型，浮点数默认是double。\n\n        长整数要加L或者l。\n        单精度的浮点数要加F或者f。</code></pre><h2 id=\"8-数据类型转换-掌握\"><a href=\"#8-数据类型转换-掌握\" class=\"headerlink\" title=\"8. 数据类型转换(掌握)\"></a>8. 数据类型转换(掌握)</h2><pre><code>(1)boolean类型不参与转换\n(2)默认转换\n    A:从小到大\n    B:byte,short,char -- int -- long -- float -- double\n    C:byte,short,char之间不相互转换，直接转成int类型参与运算。\n(3)强制转换\n    A:从大到小\n    B:可能会有精度的损失，一般不建议这样使用。\n    C:格式：\n        目标数据类型 变量名 = (目标数据类型) (被转换的数据);\n(4)思考题和面试题：\n    A:下面两种方式有区别吗?\n\n        float f1 = 12.345f;//本来就是float\n        float f2 = (float)12.345;//double转float\n\n    B:下面的程序有问题吗，如果有，在哪里呢?\n\n        byte b1 = 3;\n        byte b2 = 4;\n        byte b3 = b1 + b2;//b1+b2是int,需要强转(byte)(b1 + b2)\n        byte b4 = 3 + 4;//会先判断3+4的值是否在byte区间内,区间内就没问题\n\n    C:下面的操作结果是什么呢?\n        byte b = (byte)130;//-126\n\n    D:字符参与运算\n        是查找ASCII里面的值\n        &apos;a&apos;        97\n        &apos;A&apos;        65\n        &apos;0&apos;        48\n\n        System.out.println(&apos;a&apos;);//a\n        System.out.println(&apos;a&apos; + 1);//98\n\n    E:字符串参与运算\n        这里其实是字符串的连接        \n\n        System.out.println(&quot;hello&quot;+&apos;a&apos;+1);//helloa1\n        System.out.println(&apos;a&apos;+1+&quot;hello&quot;);//98hello\n        System.out.println(&quot;5+5=&quot;+5+5);//5+5=55\n        System.out.println(5+5+&quot;=5+5&quot;);//10=5+5</code></pre><h2 id=\"1-运算符-掌握\"><a href=\"#1-运算符-掌握\" class=\"headerlink\" title=\"1. 运算符(掌握)\"></a>1. 运算符(掌握)</h2><pre><code>(1)算术运算符\n    A:+,-,*,/,%,++,--\n    B:+的用法\n        a:加法\n        b:正号\n        c:字符串连接符\n    C:/和%的区别\n        数据做除法操作的时候，/取得是商，%取得是余数\n    D:++和--的用法\n        a:他们的作用是自增或者自减\n        b:使用\n            **单独使用\n                放在操作数据的前面和后面效果一样。\n                a++或者++a效果一样。\n            **参与操作使用\n                放在操作数的前面：先自增或者自减，再参与操作\n                    int a = 10;\n                    int b = ++a;\n                放在操作数的后面：先参与操作，再自增或者自减\n                    int a = 10;\n                    int b = a++;\n(2)赋值运算符\n    A:=,+=,-=,*=,/=,%=等\n    B:=叫做赋值运算符，也是最基本的赋值运算符\n        int x = 10; 把10赋值给int类型的变量x。\n    C:扩展的赋值运算符的特点\n        隐含了自动强制转换。\n\n面试题：\n\nshort s = 1;\ns = s + 1;//有问题,需要强转(short)(s + 1)\n\nshort s = 1;\ns += 1;//没问题,隐含了自动强制转换\n\n请问上面的代码哪个有问题?\n\n(3)比较运算符\n    A:==,!=,&gt;,&gt;=,&lt;,&lt;=\n    B:无论运算符两端简单还是复杂最终结果是boolean类型。\n    C:千万不要把==写成了=\n(4)逻辑运算符\n    A:&amp;,|,^,!,&amp;&amp;,||\n    B:逻辑运算符用于连接boolean类型的式子\n    C:结论\n        &amp;:有false则false\n        |:有true则true\n        ^:相同则false，不同则true。\n            情侣关系。\n        !:非true则false，非false则true\n\n        &amp;&amp;:结果和&amp;是一样的，只不过有短路效果。左边是false，右边不执行。\n        ||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。\n(5)位运算符(了解)\n    A:^的特殊用法\n        一个数据针对另一个数据位异或两次，该数不变\n    B:面试题\n        a:请实现两个变量的交换\n            **采用第三方变量\n            **用位异或运算符\n                左边a,b,a\n                右边a^b\n        b:请用最有效率的方式计算出2乘以8的结果\n            2&lt;&lt;3\n(6)三元运算符\n    A:格式\n        比较表达式?表达式1:表达式2;\n    B:执行流程：\n        首先计算比较表达式的值，看是true还是false。\n        如果是true，表达式1就是结果。\n        如果是false，表达式2就是结果。\n    C:案例：\n        a:比较两个数据是否相等\n            System.out.println(a == b ? true : false);\n        b:获取两个数据中的最大值\n            System.out.println(a &gt; b ? a : b);\n        c:获取三个数据中的最大值\n            System.out.println((a&gt;b?a:b)&gt;c?(a&gt;b?a:b):c);</code></pre><h2 id=\"2-键盘录入-掌握\"><a href=\"#2-键盘录入-掌握\" class=\"headerlink\" title=\"2. 键盘录入(掌握)\"></a>2. 键盘录入(掌握)</h2><pre><code>(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。\n(2)如何实现呢?目前就记住\n    A:导包\n        import java.util.Scanner;\n        位置：在class的上边\n    B:创建对象\n        Scanner sc = new Scanner(System.in);\n    C:获取数据\n        int x = sc.nextInt();\n(3)把三元运算符的案例加入键盘录入改进。\n    Scanner sc = new Scanner(System.in);\n    int a = sc.nextInt();\n    int b = sc.nextInt();\n    System.out.println(a &gt; b ? a : b);</code></pre><h2 id=\"3-流程控制语句\"><a href=\"#3-流程控制语句\" class=\"headerlink\" title=\"3. 流程控制语句\"></a>3. 流程控制语句</h2><pre><code>(1)顺序结构 从上往下，依次执行\n(2)选择结构    按照不同的选择，执行不同的代码\n(3)循环结构 做一些重复的代码</code></pre><h2 id=\"4-if语句-掌握\"><a href=\"#4-if语句-掌握\" class=\"headerlink\" title=\"4. if语句(掌握)\"></a>4. if语句(掌握)</h2><pre><code>(1)三种格式\n    A:格式1\n        if(比较表达式) {\n            语句体;\n        }\n\n        执行流程：\n            判断比较表达式的值，看是true还是false\n            如果是true，就执行语句体\n            如果是false，就不执行语句体\n\n    B:格式2\n        if(比较表达式) {\n            语句体1;\n        }else {\n            语句体2;\n        }\n\n        执行流程：\n            判断比较表达式的值，看是true还是false\n            如果是true，就执行语句体1\n            如果是false，就执行语句体2\n\n    C:格式3\n        if(比较表达式1) {\n            语句体1;\n        }else if(比较表达式2){\n            语句体2;\n        }\n        ...\n        else {\n            语句体n+1;\n        }\n\n        执行流程：\n            判断比较表达式1的值，看是true还是false\n            如果是true，就执行语句体1\n            如果是false，就继续判断比较表达式2的值，看是true还是false\n            如果是true，就执行语句体2\n            如果是false，就继续判断比较表达式3的值，看是true还是false\n            ...\n            如果都不满足，就执行语句体n+1\n(2)注意事项\n    A:比较表达式无论简单还是复杂，结果是boolean类型\n    B:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。\n        建议：永远不要省略。\n    C:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。\n    D:else后面如果没有if，是不会出现比较表达式的。\n    E:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。\n(3)案例：\n    A:比较两个数是否相等\n\n        if (a == b) {\n            System.out.println(&quot;a == b&quot;);\n        }\n\n    B:获取两个数中的最大值\n\n        if (a &gt; b) {\n            System.out.println(a);\n        } else if (a &lt; b) {\n            System.out.println(b);\n        }\n\n    C:获取三个数中的最大值(if语句的嵌套)\n        if (a &gt; b) {\n            if (a &gt; c) {\n                System.out.println(a);\n            } else if (c &gt; a) {\n                System.out.println(c);\n            } else if (b &gt; a) {\n                if (b &gt; c) {\n                    System.out.println(b);\n                } else if (c &gt; b) {\n                    System.out.println(c);\n                }\n            }\n\n    D:根据成绩输出对应的等级\n        if (score &gt; 0 &amp;&amp; score &lt; 60) {\n            System.out.println(&quot;不及格&quot;);\n        } else if (score &gt;= 60 &amp;&amp; score &lt; 90) {\n            System.out.println(&quot;合格&quot;);\n        } else if (score &gt;= 90 &amp;&amp; score &lt;= 100) {\n            System.out.println(&quot;优秀&quot;);\n        }\n    E:根据月份，输出对应的季节\n    F:根据x计算对应y的值并输出\n(4)三元运算符和if语句第二种格式的关系\n    所有的三元运算符能够实现的，if语句的第二种格式都能实现。\n    反之不成立。\n\n    如果if语句第二种格式控制的语句体是输出语句，就不可以。\n    因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。</code></pre><h2 id=\"1-switch语句-掌握\"><a href=\"#1-switch语句-掌握\" class=\"headerlink\" title=\"1. switch语句(掌握)\"></a>1. switch语句(掌握)</h2><pre><code>(1)格式：\n    switch(表达式) {\n        case 值1:\n            语句体1;\n            break;\n        case 值2:\n            语句体2;\n            break;\n        ...\n        default:\n            语句体n+1;\n            break;\n    }\n\n    格式解释说明：\n        switch:说明这是switch语句。\n        表达式:可以是byte,short,int,char\n            JDK5以后可以是枚举\n            JDK7以后可以是字符串\n        case:后面的值就是要和表达式进行比较的值\n        break:表示程序到这里中断，跳出switch语句\n        default:如果所有的情况都不匹配,就执行这里,相当于if语句中的else\n(2)面试题\n    switch语句的表达式可以是byte吗?可以是long吗?可以是String吗?\n        可以,不可以,JDK7以后可以\n(3)执行流程:\n    A:首先计算表达式的值\n    B:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。\n    C:如果没有匹配，就执行default的语句体n+1。\n(4)注意事项:\n    A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的\n    B:default可以省略吗?\n        可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。\n        特殊情况：\n            case就可以把值固定。\n            A,B,C,D\n    C:break可以省略吗?\n        可以省略，但是结果可能不是我们想要的。\n        会出现一个现象：case穿透。\n        最终我们建议不要省略\n    D:default一定要在最后吗?\n        不是，可以在任意位置。但是建议在最后。\n    E:switch语句的结束条件\n        a:遇到break就结束了\n        b:执行到末尾就结束了\n(5)案例：\n    A:键盘录入一个数字(1-7),输出对应的星期几。\n        Scanner sc = new Scanner(System.in);\n\n            switch (sc.nextInt()) {\n            case ## 1. \n                System.out.println(&quot;Monday&quot;);\n                break;\n            case ## 2. \n                System.out.println(&quot;Tuesday&quot;);\n                break;\n            case ## 3. \n                System.out.println(&quot;Wednesday&quot;);\n                break;\n            case ## 4. \n                System.out.println(&quot;Thursday&quot;);\n                break;\n            case ## 5. \n                System.out.println(&quot;Friday&quot;);\n                break;\n            case ## 6. \n                System.out.println(&quot;Saturday&quot;);\n                break;\n            case ## 7. \n                System.out.println(&quot;Sunday&quot;);\n                break;\n            default:\n                System.out.println(&quot;wrong&quot;);\n        }\n    B:单项选择题\n    C:键盘录入一个字符串的问题\n        String s = sc.nextLine();\n    D:根据给定的月份,输出对应的季节\n(6)if语句和switch语句各自的场景\n    A:if\n        针对boolean类型的判断\n        针对一个范围的判断\n        针对几个常量的判断\n    B:switch\n        针对几个常量的判断</code></pre><h2 id=\"2-循环语句-掌握\"><a href=\"#2-循环语句-掌握\" class=\"headerlink\" title=\"2. 循环语句(掌握)\"></a>2. 循环语句(掌握)</h2><pre><code>(1)有三种:for,while,do...while\n(2)for循环语句\n    A:格式\n        for(初始化语句;判断条件语句;控制条件语句){\n            循环体语句;\n        }\n\n        执行流程：\n            a:执行初始化语句\n            b:执行判断条件语句\n                如果这里是true，就继续\n                如果这里是false，循环就结束\n            c:执行循环体语句\n            d:执行控制条件语句\n            e:回到b\n    B:注意事项\n        a:判断条件语句无论简单还是复杂，结果是boolean类型\n        b:循环体语句如果是一条，可以省略大括号，但是不建议\n        c:有分号就没有左大括号，有左大括号就没有分号\n    C:案例\n        a:输出10次HelloWorld\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(&quot;HelloWorld&quot;);\n            }\n        b:输出1-10的数据\n            for (int i = 1; i &lt; 11; i++) {\n                System.out.println(i);\n            }\n        c:输出10-1的数据\n            for (int i = 10; i &gt; 0; i--) {\n                System.out.println(i);\n            }\n        d:求1-10的和\n            int sum = 0;\n            for (int i = 1; i &lt; 11; i++) {\n                sum += i;\n            }\n            System.out.println(sum);\n        e:求1-100的和,求1-100的偶数和,求1-100的奇数和\n            int sum = 0;\n            int oddSum = 0;\n            int evenSum = 0;\n\n            for (int i = 1; i &lt; 101; i++) {\n                sum += i;\n            }\n            System.out.println(&quot;sum:&quot; + sum);\n\n            for (int i = 1; i &lt; 101; i+=2) {\n                oddSum += i;\n            }\n            System.out.println(&quot;oddSum:&quot; + oddSum);\n\n            for (int i = 2; i &lt; 101; i+=2) {\n                evenSum += i;\n            }\n            System.out.println(&quot;evenSum:&quot; + evenSum);\n        f:求5的阶乘\n            int sum = 1;\n            for (int i = 5; i &gt; 0; i--) {\n                sum *= i;\n            }\n            System.out.println(sum);\n        g:在控制台打印水仙花数(个位,十位,百位的立方和等于该数)\n            for (int i = 100; i &lt; 1000; i++) {\n                int ge = i % 10;\n                int shi = i / 10 % 10;\n                int bai = i / 100 % 10;        \n                if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n                    System.out.println(i);\n                }\n            }\n        h:统计水仙花个数\n            int flag = 0;\n            for (int i = 100; i &lt; 1000; i++) {\n                int ge = i % 10;\n                int shi = i / 10 % 10;\n                int bai = i / 100 % 10;\n                if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n                    flag++;\n                }\n            }\n            System.out.println(flag);\n        i:改进版的回文数\n            一个五位数\n            个位 = 万位\n            十位 = 千位\n            个位 + 十位 + 千位 + 万位 = 百位\n            for (int i = 10000; i &lt; 100000; i++) {\n                int ge = i % 10;\n                int shi = i / 10 %10;\n                int bai = i / 100 % 10;\n                int qian = i /1000 % 10;\n                int wan = i / 10000 % 10;\n                if (ge == wan &amp;&amp; shi == qian &amp;&amp; (ge + shi + qian + wan) == bai) {\n                    System.out.println(i);\n                }\n            }\n        j:统计1-1000之间同时满足如下条件的数据有多少个\n            x%3==2\n            x%5==3\n            x%7==2\n            int flag = 0;\n            for (int i = 1; i &lt; 1001; i++) {\n                if (i % 3 == 2 &amp;&amp; i % 5 == 3 &amp;&amp; i % 7 == 2) {\n                    flag++;\n                }\n            }\n            System.out.println(flag);\n(3)while循环\n    A:基本格式\n        while(判断条件语句) {\n            循环体语句;\n        }\n\n        扩展格式：\n        初始化语句;\n        while(判断条件语句){\n            循环体语句;\n            控制条件语句;\n        }\n\n        通过查看这个格式，我们就知道while循环可以和for循环等价转换。\n    B:while的练习\n        把for语句的练习用while改进\n    C:for和while的区别\n        a:使用上的区别\n            for语句的那个控制条件变量,在循环结束后不能在使用了。\n            而while的可以继续使用。\n        b:理解上的区别\n            for适合于一个范围的判断\n            while适合次数不明确的\n                举例:吃葡萄\n    D:案例：\n        a:珠穆朗玛峰问题\n        b:小芳存钱问题(break以后才能做)\n(4)do...while循环\n    A:基本格式\n        do {\n            循环体语句;\n        }while(判断条件语句);\n\n        扩展格式：\n        初始化语句;\n        do {\n            循环体语句;\n            控制条件语句;\n        }while(判断条件语句);\n\n        通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。\n    B:三种循环的区别\n        a:do...while循环至少执行一次循环体\n        b:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体\n(5)循环使用的注意事项(死循环)\n    A:一定要注意修改控制条件,否则容易出现死循环。\n    B:最简单的死循环格式\n        a:while(true){...}\n\n        b:for(;;){}</code></pre><h2 id=\"3-控制跳转语句-掌握\"><a href=\"#3-控制跳转语句-掌握\" class=\"headerlink\" title=\"3. 控制跳转语句(掌握)\"></a>3. 控制跳转语句(掌握)</h2><pre><code>(1)break:中断的意思\n    A:用在循环和switch语句中，离开此应用场景无意义。\n    B:作用\n        a:跳出单层循环\n        b:跳出多层循环，需要标签语句的配合\n(2)continue:继续\n    A:用在循环中，离开此应用场景无意义。\n    B:作用\n        a:跳出单层循环的一次，可以继续下一次\n    C:填空题\n        for(int x=1; x&lt;=10; x++) {\n            if(x%3 == 0) {\n                //补齐代码\n            }\n            System.out.println(&quot;Java基础班&quot;);\n        }\n        如何让控制台输出2次：Java基础班\n            break;\n        如何让控制台输出7次：Java基础班\n            continue;\n        如何让控制台输出13次：Java基础班\n            System.out.println(&quot;Java基础班&quot;);\n(3)return:返回\n    A:用于结束方法的，后面还会在继续讲解和使用。\n    B:一旦遇到return,程序就不会在继续往后执行。</code></pre><h2 id=\"1-方法-掌握\"><a href=\"#1-方法-掌握\" class=\"headerlink\" title=\"1. 方法(掌握)\"></a>1. 方法(掌握)</h2><pre><code>(1)方法：就是完成特定功能的代码块。\n    注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。\n(2)格式：\n    修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {\n        方法体语句;\n        return 返回值;\n    }\n\n\n    修饰符：目前就用 public static。后面再详细讲解其他修饰符\n    返回值类型：就是功能结果的数据类型\n    方法名：就是起了一个名字，方便我们调用该方法。\n    参数类型：就是参数的数据类型\n    参数名：就是变量\n    参数分类：\n        实参：实际参与运算的数据\n        形参：方法上定义的，用于接收实际参数的变量\n    方法体语句：就是完成功能的代码块\n    return：结束方法\n    返回值：就是功能的结果，由return带给调用者。\n(3)两个明确：\n    返回值类型：结果的数据类型\n    参数列表：参数的个数及对应的数据类型\n(4)方法调用\n    A:有明确返回值的方法\n        a:单独调用，没有意义\n        b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。\n        c:赋值调用，推荐方案\n    B:void类型修饰的方法\n        a:单独调用\n(5)案例：\n    A:求和方案\n        public static void sum(int a, int b) {\n            System.out.println(&quot;a + b = &quot; + (a + b));\n        }\n    B:获取两个数中的较大值\n        public static void max(int a, int b) {\n            if (a &gt; b) {\n                System.out.println(a);\n            } else if (b &gt; a) {\n                System.out.println(b);\n            }\n        }\n    C:比较两个数据是否相同\n        public static void isEquals(int a, int b) {\n            if (a == b) {\n                System.out.println(&quot;a == b&quot;);\n            }\n        }\n    D:获取三个数中的最大值\n        public static void max(int a, int b, int c) {\n            if (a &gt; b) {\n                if (a &gt; c) {\n                    System.out.println(a);\n                } else if (c &gt; a) {\n                    System.out.println(c);\n                }\n            } else if (b &gt; a) {\n                if (b &gt; c) {\n                    System.out.println(b);\n                } else if (c &gt; b) {\n                    System.out.println(c);\n                }\n            }\n        }\n    E:输出m行n列的星形\n        public static void printStar(int row, int column) {\n            for (int m = 0; m &lt; row; m++) {\n                String star = &quot;&quot;;\n                for (int n = 0; n &lt; column; n++) {\n                    star += &quot;*&quot;;\n                }\n                System.out.println(star);\n            }\n            System.out.println(&quot;--------------&quot;);\n            for (int m = 0; m &lt; row; m++) {\n                String star = &quot;&quot;;\n                for (int n = 0; n &lt;= m; n++) {\n                    star += &quot;*&quot;;\n                }\n                System.out.println(star);\n            }\n            System.out.println(&quot;---------------&quot;);\n            for (int m = row; m &gt; 0; m--) {\n                String star = &quot;&quot;;\n                for (int n = 0; n &lt; m; n++) {\n                    star += &quot;*&quot;;\n                }\n                System.out.println(star);\n            }\n        }\n    F:输出nn乘法表\n        public static void chengfabiao(int n) {\n            for (int i = 1; i &lt;= n; i++) {\n                for (int j = 1; j &lt;= i; j++) {\n                    System.out.print(j + &quot; * &quot; + i + &quot; = &quot; + (j * i) + &quot;\\t&quot;);\n                }\n                System.out.println();\n            }\n        }\n(6)方法的注意事项\n    A:方法不调用不执行\n    B:方法之间是平级关系，不能嵌套定义\n    C:方法定义的时候，参数是用，隔开的\n    D:方法在调用的时候，不用在传递数据类型\n    E:如果方法有明确的返回值类型，就必须有return语句返回。\n(7)方法重载\n    在同一个类中，方法名相同，参数列表不同。与返回值无关。\n\n    参数列表不同：\n        参数的个数不同。\n        参数的对应的数据类型不同。\n(8)方法重载案例\n    不同的类型的多个同名方法的比较。</code></pre><h2 id=\"2-数组-掌握\"><a href=\"#2-数组-掌握\" class=\"headerlink\" title=\"2. 数组(掌握)\"></a>2. 数组(掌握)</h2><pre><code>(1)数组：存储同一种数据类型的多个元素的容器。\n(2)特点：每一个元素都有编号，从0开始，最大编号是长度-1。\n         编号的专业叫法：索引\n(3)定义格式\n    A:数据类型[] 数组名;\n    B:数据类型 数组名[];\n\n    推荐是用A方式，B方法就忘了吧。\n    但是要能看懂\n(4)数组的初始化\n    A:动态初始化\n        只给长度，系统给出默认值\n\n        举例：int[] arr = new int[3];\n    B:静态初始化\n        给出值，系统决定长度\n\n        举例：int[] arr = new int[]{1,2,3};\n        简化版：int[] arr = {1,2,3};\n(5)Java的内存分配\n    A:栈 存储局部变量\n    B:堆 存储所有new出来的\n    C:方法区(面向对象部分详细讲解)\n    D:本地方法区(系统相关)\n    E:寄存器(CPU使用)\n\n    注意：\n        a:局部变量 在方法定义中或者方法声明上定义的变量。\n        b:栈内存和堆内存的区别\n            栈：数据使用完毕，就消失。\n            堆：每一个new出来的东西都有地址\n                每一个变量都有默认值\n                    byte,short,int,long 0\n                    float,double 0.0\n                    char &apos;\\u0000&apos;\n                    boolean false\n                    引用类型 null\n                数据使用完毕后，在垃圾回收器空闲的时候回收。\n(6)数组内存图\n    A:一个数组\n    B:二个数组\n    C:三个数组(两个栈变量指向同一个堆内存)\n(7)数组的常见操作\n    A:遍历\n        方式1：\n            public static void printArray(int[] arr) {\n                for(int x=0; x&lt;arr.length; x++) {\n                    System.out.println(arr[x]);\n                }\n            }\n\n        方式2：\n            public static void printArray(int[] arr) {\n                System.out.print(&quot;[&quot;);\n                for(int x=0; x&lt;arr.length; x++) {\n                    if(x == arr.length-1) {\n                        System.out.println(arr[x]+&quot;]&quot;);\n                    }else {\n                        System.out.println(arr[x]+&quot;, &quot;);\n                    }\n                }\n            }\n    B:最值\n        最大值：\n            public static int getMax(int[] arr) {\n                int max = arr[0];\n\n                for(int x=1; x&lt;arr.length; x++) {\n                    if(arr[x] &gt; max) {\n                        max = arr[x];\n                    }\n                }\n\n                return max;\n            }\n\n        最小值：\n            public static int getMin(int[] arr) {\n                int min = arr[0];\n\n                for(int x=1; x&lt;arr.length; x++) {\n                    if(arr[x] &lt; min) {\n                        min = arr[x];\n                    }\n                }\n\n                return min;\n            }\n    C:逆序\n        方式1：\n            public static void reverse(int[] arr) {\n                for(int x=0; x&lt;arr.length/2; x++) {\n                    int temp = arr[x];\n                    arr[x] = arr[arr.length-1-x];\n                    arr[arr.length-1-x] = temp;\n                }\n            }\n\n        方式2：\n            public static void reverse(int[] arr) {\n                for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) {\n                    int temp = arr[start];\n                    arr[start] = arr[end];\n                    arr[end] = temp;\n                }\n            }\n    D:查表\n            public static String getString(String[] strArray,int index) {\n                return strArray[index];\n            }\n    E:基本查找\n        方式1：\n            public static int getIndex(int[] arr,int value) {\n                for(int x=0; x&lt;arr.length; x++) {\n                    if(arr[x] == value) {\n                        return x;\n                    }\n                }\n\n                return -1;\n            }\n\n        方式2：\n            public static int getIndex(int[] arr,int value) {\n                int index = -1;\n\n                for(int x=0; x&lt;arr.length; x++) {\n                    if(arr[x] == value) {\n                        index = x;\n                        break;\n                    }\n                }\n\n                return index;\n            }</code></pre><h1 id=\"Java面向对象\"><a href=\"#Java面向对象\" class=\"headerlink\" title=\"Java面向对象\"></a>Java面向对象</h1><h2 id=\"1-成员变量和局部变量的区别-理解\"><a href=\"#1-成员变量和局部变量的区别-理解\" class=\"headerlink\" title=\"1. 成员变量和局部变量的区别(理解)\"></a>1. 成员变量和局部变量的区别(理解)</h2><pre><code>(1)在类中的位置不同\n    成员变量：类中方法外\n    局部变量：方法定义中或者方法声明上\n(2)在内存中的位置不同\n    成员变量：在堆中\n    局部变量：在栈中\n(3)生命周期不同\n    成员变量：随着对象的创建而存在，随着对象的消失而消失\n    局部变量：随着方法的调用而存在，随着方法的调用完毕而消失\n(4)初始化值不同\n    成员变量：有默认值\n    局部变量：没有默认值，必须定义，赋值，然后才能使用</code></pre><h2 id=\"2-类作为形式参数的问题-理解\"><a href=\"#2-类作为形式参数的问题-理解\" class=\"headerlink\" title=\"2. 类作为形式参数的问题?(理解)\"></a>2. 类作为形式参数的问题?(理解)</h2><pre><code>(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。</code></pre><h2 id=\"3-匿名对象-理解\"><a href=\"#3-匿名对象-理解\" class=\"headerlink\" title=\"3. 匿名对象(理解)\"></a>3. 匿名对象(理解)</h2><pre><code>(1)没有名字的对象\n(2)应用场景\n    A:调用方法，仅仅只调用一次的时候。\n    b:可以作为实际参数传递。</code></pre><h2 id=\"4-封装-理解\"><a href=\"#4-封装-理解\" class=\"headerlink\" title=\"4. 封装(理解)\"></a>4. 封装(理解)</h2><pre><code>(1)隐藏实现细节，提供公共的访问方式\n(2)好处：\n    A:隐藏实现细节，提供公共的访问方式\n    B:提高代码的复用性\n    C:提高代码的安全性\n(3)设计原则\n    把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式\n(4)private是封装的一种体现。\n    封装：类，方法，private修饰成员变量</code></pre><h2 id=\"5-private关键字-掌握\"><a href=\"#5-private关键字-掌握\" class=\"headerlink\" title=\"5. private关键字(掌握)\"></a>5. private关键字(掌握)</h2><pre><code>(1)私有的意义，可以修饰成员变量和成员方法\n(2)特点：\n    被private修饰的后的成员只能在本类中被访问\n(3)private的应用：\n    以后再写一个类的时候：\n        把所有的成员变量给private了\n        提供对应的getXxx()/setXxx()方法</code></pre><h2 id=\"6-this关键字-掌握\"><a href=\"#6-this关键字-掌握\" class=\"headerlink\" title=\"6. this关键字(掌握)\"></a>6. this关键字(掌握)</h2><pre><code>(1)代表当前类的引用对象\n    记住：哪个对象调用方法，该方法内部的this就代表那个对象\n(2)this的应用场景：\n    A:解决了局部变量隐藏成员变量的问题\n    B:其实this还有其他的应用，明天讲解。</code></pre><h2 id=\"7-构造方法-掌握\"><a href=\"#7-构造方法-掌握\" class=\"headerlink\" title=\"7. 构造方法(掌握)\"></a>7. 构造方法(掌握)</h2><pre><code>(1)作用：用于对对象的数据进行初始化\n(2)格式：\n    A:方法名和类名相同\n    B:没有返回值类型，连void都不能有\n    C:没有返回值\n\n    思考题：构造方法中可不可以有return语句呢?\n    可以。只要我们写成这个样子就OK了：return;\n    其实，在任何的void类型的方法的最后你都可以写上：return;\n(3)构造方法的注意事项\n    A:如果我们没写构造方法，系统将提供一个默认的无参构造方法\n    B:如果我们给出了构造方法，系统将不再提供默认构造方法\n        如果这个时候，我们要使用无参构造方法，就必须自己给出。\n        推荐：永远手动自己给出无参构造方法。\n(4)给成员变量赋值的方式\n    A:setXxx()\n    B:带参构造方法\n(5)标准案例\n    class Student {\n        private String name;\n        private int age;\n\n        public Student(){}\n\n        public Student(String name,int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n\n    测试：\n    class StudentDemo {\n        public static void main(String[] args) {\n            //方式1\n            Student s1 = new Student();\n            s1.setName(&quot;林青霞&quot;);\n            s1.setAge(27);\n            System.out.println(s1.getName()+&quot;---&quot;+s1.getAge());\n\n            //方式2\n            Student s2 = new Student(&quot;刘意&quot;,30);\n            System.out.println(s2.getName()+&quot;---&quot;+s2.getAge());\n        }\n    }</code></pre><h2 id=\"8-代码：Student-s-new-Student-做了哪些事情-理解\"><a href=\"#8-代码：Student-s-new-Student-做了哪些事情-理解\" class=\"headerlink\" title=\"8. 代码：Student s = new Student();做了哪些事情?(理解)\"></a>8. 代码：Student s = new Student();做了哪些事情?(理解)</h2><pre><code>(1)把Student.class文件加载到内存\n(2)在栈内存为s开辟空间\n(3)在堆内存为学生对象申请空间\n(4)给学生的成员变量进行默认初始化。null,0\n(5)给学生的成员变量进行显示初始化。林青霞,27\n(6)通过构造方法给成员变量进行初始化。刘意,30\n(7)对象构造完毕，把地址赋值给s变量</code></pre><h2 id=\"9-面向对象的练习题-掌握\"><a href=\"#9-面向对象的练习题-掌握\" class=\"headerlink\" title=\"9. 面向对象的练习题(掌握)\"></a>9. 面向对象的练习题(掌握)</h2><pre><code>(1)标准的手机类的定义和测试\n(2)Demo类有求和方法，Test类进行测试。\n    什么时候定义成员变量?\n    当该变量是用来描述一个类的时候。\n(3)长方形案例\n(4)员工案例\n(5)MyMath案例(自己提供加减乘除并测试)\n    public class MyMath {\n        public MyMath() {\n        }\n\n        public static void add(int a, int b) {\n            System.out.println(&quot;add&quot; + (a + b));\n        }\n\n        public static void subtract(int a, int b) {\n            System.out.println(&quot;subtract&quot; + (a - b));\n        }\n\n        public static void multiply(int a, int b) {\n            System.out.println(&quot;multiply&quot; + (a * b));\n        }\n\n        public static void divide(int a, int b) {\n            System.out.println(&quot;divide&quot; + (a / b));\n        }\n    }</code></pre><h2 id=\"10-static关键字-理解\"><a href=\"#10-static关键字-理解\" class=\"headerlink\" title=\"10. static关键字(理解)\"></a>10. static关键字(理解)</h2><pre><code>(1)静态的意思。可以修饰成员变量和成员方法。\n(2)静态的特点：\n    A:随着类的加载而加载\n    B:优先于对象存在\n    C:被类的所有对象共享\n        这其实也是我们判断该不该使用静态的依据。\n        举例：饮水机和水杯的问题思考\n    D:可以通过类名调用\n        既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。\n(3)静态的内存图\n    静态的内容在方法区的静态区\n(4)静态的注意事项；\n    A:在静态方法中没有this对象\n    B:静态只能访问静态(代码测试过)\n(5)静态变量和成员变量的区别\n    A:所属不同\n        静态变量：属于类，类变量\n        成员变量：属于对象，对象变量，实例变量\n    B:内存位置不同\n        静态变量：方法区的静态区\n        成员变量：堆内存\n    C:生命周期不同\n        静态变量：静态变量是随着类的加载而加载，随着类的消失而消失\n        成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失\n    D:调用不同\n        静态变量：可以通过对象名调用，也可以通过类名调用\n        成员变量：只能通过对象名调用\n(6)main方法是静态的\n    public:权限最大\n    static:不用创建对象调用\n    void:返回值给jvm没有意义\n    main:就是一个常见的名称。\n    String[] args:可以接收数据，提供程序的灵活性\n        格式：java MainDemo hello world java\n              java MainDemo 10 20 30</code></pre><h2 id=\"1-如何制作帮助文档-了解\"><a href=\"#1-如何制作帮助文档-了解\" class=\"headerlink\" title=\"1. 如何制作帮助文档(了解)\"></a>1. 如何制作帮助文档(了解)</h2><pre><code>(1)写一个类\n(2)加入文档注释\n(3)通过javadoc工具生成即可\n    javadoc -d 目录 -author -version ArrayTool.java</code></pre><h2 id=\"2-通过JDK提供的API学习了Math类-掌握\"><a href=\"#2-通过JDK提供的API学习了Math类-掌握\" class=\"headerlink\" title=\"2. 通过JDK提供的API学习了Math类(掌握)\"></a>2. 通过JDK提供的API学习了Math类(掌握)</h2><pre><code>(1)API(Application Programming Interface)\n    应用程序编程接口(帮助文档)\n(2)如何使用呢?\n    请参照\n        day08\\code\\02_如何使用JDK提供的帮助文档\\如何使用帮助文档.txt\n(3)Math类\n    A:是针对数学进行操作的类\n    B:没有构造方法，因为它的成员都是静态的\n    C:产生随机数\n        public static double random(): [0.0,1.0)\n    D:如何产生一个1-100之间的随机数\n        int number = (int)(Math.random()*100)+1;\n    E:猜数字小游戏</code></pre><h2 id=\"3-代码块-理解\"><a href=\"#3-代码块-理解\" class=\"headerlink\" title=\"3. 代码块(理解)\"></a>3. 代码块(理解)</h2><pre><code>(1)用{}括起来的代码。\n(2)分类：\n    A:局部代码块\n        用于限定变量的生命周期，及早释放，提高内存利用率。\n    B:构造代码块\n        把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。\n    C:静态代码块\n        对类的数据进行初始化，仅仅只执行一次。\n(3)静态代码块,构造代码块,构造方法的顺序问题?\n    静态代码块 &gt; 构造代码块 &gt; 构造方法</code></pre><h2 id=\"4-继承-掌握\"><a href=\"#4-继承-掌握\" class=\"headerlink\" title=\"4. 继承(掌握)\"></a>4. 继承(掌握)</h2><pre><code>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，\n   这多个类就具备了这些内容。这个关系叫继承。\n(2)Java中如何表示继承呢?格式是什么呢?\n    A:用关键字extends表示\n    B:格式：\n        class 子类名 extends 父类名 {}\n(3)继承的好处：\n    A:提高了代码的复用性\n    B:提高了代码的维护性\n    C:让类与类产生了一个关系，是多态的前提\n(4)继承的弊端：\n    A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。\n        原则：低耦合，高内聚。\n        耦合：类与类的关系\n        内聚：自己完成某件事情的能力\n    B:打破了封装性\n(5)Java中继承的特点\n    A:Java中类只支持单继承\n    B:Java中可以多层(重)继承(继承体系)\n(6)继承的注意事项：\n    A:子类不能继承父类的私有成员\n    B:子类不能继承父类的构造方法，但是可以通过super去访问\n    C:不要为了部分功能而去继承\n(7)什么时候使用继承呢?\n    A:继承体现的是：is a的关系。\n    B:采用假设法\n(8)Java继承中的成员关系\n    A:成员变量\n        a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单\n        b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?\n            子类的方法访问变量的查找顺序：\n                在子类方法的局部范围找，有就使用。\n                在子类的成员范围找，有就使用。\n                在父类的成员范围找，有就使用。\n                找不到，就报错。\n    B:构造方法\n        a:子类的构造方法默认会去访问父类的无参构造方法\n            是为了子类访问父类数据的初始化\n        b:父类中如果没有无参构造方法，怎么办?\n            子类通过super去明确调用带参构造\n            子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造\n            让父类提供无参构造\n    C:成员方法\n        a:子类的成员方法和父类中的成员方法名称不一样，这个太简单\n        b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?\n            通过子类对象访问一个方法的查找顺序：\n                在子类中找，有就使用\n                在父类中找，有就使用\n                找不到，就报错\n(9)两个面试题：\n    A:Override和Overload的区别?Overload是否可以改变返回值类型?\n    B:this和super的区别和各自的作用?\n(10)数据初始化的面试题\n    A:一个类的初始化过程\n    B:子父类的构造执行过程\n    C:分层初始化\n(11)案例：\n    A:学生和老师案例\n        继承前\n        继承后\n    B:猫狗案例的分析和实现</code></pre><h2 id=\"1-final关键字-掌握\"><a href=\"#1-final关键字-掌握\" class=\"headerlink\" title=\"1. final关键字(掌握)\"></a>1. final关键字(掌握)</h2><pre><code>(1)是最终的意思，可以修饰类，方法，变量。\n(2)特点：\n    A:它修饰的类，不能被继承。\n    B:它修饰的方法，不能被重写。\n    C:它修饰的变量，是一个常量。\n(3)面试相关：\n    A:局部变量\n        a:基本类型 值不能发生改变\n        b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的\n    B:初始化时机\n        a:只能初始化一次。\n        b:常见的给值\n            定义的时候。(推荐)\n            构造方法中。</code></pre><h2 id=\"2-多态-掌握\"><a href=\"#2-多态-掌握\" class=\"headerlink\" title=\"2. 多态(掌握)\"></a>2. 多态(掌握)</h2><pre><code>(1)同一个对象在不同时刻体现出来的不同状态。\n(2)多态的前提：\n    A:有继承或者实现关系。\n    B:有方法重写。\n    C:有父类或者父接口引用指向子类对象。\n\n    多态的分类：\n        a:具体类多态\n            class Fu {}\n            class Zi extends Fu {}\n\n            Fu f = new Zi();\n        b:抽象类多态\n            abstract class Fu {}\n            class Zi extends Fu {}\n\n            Fu f = new Zi();\n        c:接口多态\n            interface Fu {}\n            class Zi implements Fu {}\n\n            Fu f = new Zi();\n(3)多态中的成员访问特点\n    A:成员变量\n        编译看左边，运行看左边\n    B:构造方法\n        子类的构造都会默认访问父类构造\n    C:成员方法\n        编译看左边，运行看右边\n    D:静态方法\n        编译看左边，运行看左边\n\n    为什么?\n        因为成员方法有重写。\n(4)多态的好处：\n    A:提高代码的维护性(继承体现)\n    B:提高代码的扩展性(多态体现)\n(5)多态的弊端：\n    父不能使用子的特有功能。\n\n    现象：\n        子可以当作父使用，父不能当作子使用。\n(6)多态中的转型\n    A:向上转型\n        从子到父\n    B:向下转型\n        从父到子\n(7)孔子装爹的案例帮助大家理解多态\n(8)多态的练习\n    A:猫狗案例\n    B:老师和学生案例</code></pre><h2 id=\"3-抽象类-掌握\"><a href=\"#3-抽象类-掌握\" class=\"headerlink\" title=\"3. 抽象类(掌握)\"></a>3. 抽象类(掌握)</h2><pre><code>(1)把多个共性的东西提取到一个类中，这是继承的做法。\n   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。\n   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。\n   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。\n   而一个没有具体的方法体的方法是抽象的方法。\n   在一个类中如果有抽象方法，该类必须定义为抽象类。\n(2)抽象类的特点\n    A:抽象类和抽象方法必须用关键字abstract修饰\n    B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类\n    C:抽象类不能实例化\n    D:抽象类的子类\n        a:是一个抽象类。\n        b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。\n(3)抽象类的成员特点：\n    A:成员变量\n        有变量，有常量\n    B:构造方法\n        有构造方法\n    C:成员方法\n        有抽象，有非抽象\n(4)抽象类的练习\n    A:猫狗案例练习\n    B:老师案例练习\n    C:学生案例练习\n    D:员工案例练习\n(5)抽象类的几个小问题\n    A:抽象类有构造方法，不能实例化，那么构造方法有什么用?\n        用于子类访问父类数据的初始化\n    B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?\n        为了不让创建对象\n    C:abstract不能和哪些关键字共存\n        a:final    冲突\n        b:private 冲突\n        c:static 无意义</code></pre><h2 id=\"4-接口-掌握\"><a href=\"#4-接口-掌握\" class=\"headerlink\" title=\"4. 接口(掌握)\"></a>4. 接口(掌握)</h2><pre><code>(1)回顾猫狗案例，它们仅仅提供一些基本功能。\n   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，\n   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。\n(2)接口的特点：\n    A:接口用关键字interface修饰\n        interface 接口名 {}\n    B:类实现接口用implements修饰\n        class 类名 implements 接口名 {}\n    C:接口不能实例化\n    D:接口的实现类\n        a:是一个抽象类。\n        b:是一个具体类，这个类必须重写接口中的所有抽象方法。\n(3)接口的成员特点：\n    A:成员变量\n        只能是常量\n        默认修饰符：public static final\n    B:构造方法\n        没有构造方法\n    C:成员方法\n        只能是抽象的\n        默认修饰符：public abstract\n(4)类与类,类与接口,接口与接口\n    A:类与类\n        继承关系，只能单继承，可以多层继承\n    B:类与接口\n        实现关系，可以单实现，也可以多实现。\n        还可以在继承一个类的同时，实现多个接口\n    C:接口与接口\n        继承关系，可以单继承，也可以多继承\n(5)抽象类和接口的区别(自己补齐)?\n    A:成员区别\n        抽象类：可以是变量可以是常量\n        接口：只能是常量\n    B:关系区别:\n        类与类：继承\n        类与接口：实现\n        接口与接口：继承\n    C:设计理念不同\n        抽象类：is a，抽象类中定义的是共性功能。\n        接口：like a，接口中定义的是扩展功能。\n(6)练习：\n    A:猫狗案例，加入跳高功能\n    B:老师和学生案例，加入抽烟功能0</code></pre><h2 id=\"1-形式参数和返回值的问题-理解\"><a href=\"#1-形式参数和返回值的问题-理解\" class=\"headerlink\" title=\"1. 形式参数和返回值的问题(理解)\"></a>1. 形式参数和返回值的问题(理解)</h2><pre><code>(1)形式参数：\n    类名：需要该类的对象\n    抽象类名：需要该类的子类对象\n    接口名：需要该接口的实现类对象\n(2)返回值类型：\n    类名：返回的是该类的对象\n    抽象类名：返回的是该类的子类对象\n    接口名：返回的是该接口的实现类的对象\n(3)链式编程\n    对象.方法1().方法2().......方法n();\n\n    这种用法：其实在方法1()调用完毕后，应该一个对象；\n              方法2()调用完毕后，应该返回一个对象。\n              方法n()调用完毕后，可能是对象，也可以不是对象。</code></pre><h2 id=\"2-包-理解\"><a href=\"#2-包-理解\" class=\"headerlink\" title=\"2. 包(理解)\"></a>2. 包(理解)</h2><pre><code>(1)其实就是文件夹\n(2)作用：\n    A:区分同名的类\n    B:对类进行分类管理\n        a:按照功能分\n        b:按照模块分\n(3)包的定义(掌握)\n    package 包名;\n    多级包用.分开。\n(4)注意事项：(掌握)\n    A:package语句必须在文件中的第一条有效语句\n    B:在一个java文件中，只能有一个package\n    C:如果没有package，默认就是无包名\n(5)带包的编译和运行\n    A:手动式\n    B:自动式(掌握)\n        javac -d . HelloWorld.java</code></pre><h2 id=\"3-导包-掌握\"><a href=\"#3-导包-掌握\" class=\"headerlink\" title=\"3. 导包(掌握)\"></a>3. 导包(掌握)</h2><pre><code>(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。\n(2)格式：\n    import 包名...类名;\n    另一种：\n        import 包名...*;(不建议)\n(3)package,import,class的顺序\n    package &gt; import &gt; class</code></pre><h2 id=\"4-权限修饰符-掌握\"><a href=\"#4-权限修饰符-掌握\" class=\"headerlink\" title=\"4. 权限修饰符(掌握)\"></a>4. 权限修饰符(掌握)</h2><pre><code>(1)权限修饰符\n                本类    同一个包下    不同包下的子类    不同包下的无关类\n    private        Y\n        默认        Y        Y\n    protected    Y        Y             Y\n    public        Y        Y             Y                  Y\n(2)这四种权限修饰符在任意时刻只能出现一种。\n    public class Demo {}        </code></pre><h2 id=\"5-常见的修饰符-理解\"><a href=\"#5-常见的修饰符-理解\" class=\"headerlink\" title=\"5. 常见的修饰符(理解)\"></a>5. 常见的修饰符(理解)</h2><pre><code>(1)分类：\n    权限修饰符：private,默认,protected,public\n    状态修饰符：static,final\n    抽象修饰符：abstract\n(2)常见的类及其组成的修饰\n    类：\n        默认,public,final,abstract\n        常用的：public\n    成员变量：\n        private,默认,protected,public,static,final\n        常用的：private\n    构造方法：\n        private,默认,protected,public\n        常用的：public\n    成员方法：\n        private,默认,protected,public,static,final,abstract\n        常用的：public\n(3)另外比较常见的：\n    public static final int X = 10;\n    public static void show() {}\n    public final void show() {}\n    public abstract void show();</code></pre><h2 id=\"6-内部类-理解\"><a href=\"#6-内部类-理解\" class=\"headerlink\" title=\"6. 内部类(理解)\"></a>6. 内部类(理解)</h2><pre><code>(1)把类定义在另一个类的内部，该类就被称为内部类。\n    举例：把类B定义在类A中，类B就被称为内部类。\n(2)内部类的访问规则\n    A:可以直接访问外部类的成员，包括私有\n    B:外部类要想访问内部类成员，必须创建对象\n(3)内部类的分类\n    A:成员内部类\n    B:局部内部类\n(4)成员内部类\n    A:private 为了数据的安全性\n    B:static 为了访问的方便性        \n成员内部类不是静态的：\n    外部类名.内部类名 对象名 = new 外部类名.new 内部类名();\n成员内部类是静态的：\n    外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre><p>(5)成员内部类的面试题(填空)</p>\n<pre><code>30,20,10\nclass Outer {\n    public int num = 10;\n        class Inner {\n            public int num = 20;\n            public viod show() {\n            int num  = 30;\n            System.out.println(num);\n            System.out.println(this.num);\n            System.out.println(Outer.this.num);\n            }\n        }\n    }</code></pre><p>(6)局部内部类</p>\n<pre><code>A:局部内部类访问局部变量必须加final修饰。\nB:为什么呢?\n    因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。\n    所以，堆内存还是用该变量，而改变量已经没有了。\n    为了让该值还存在，就加final修饰。\n    通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。</code></pre><p>(7)匿名内部类(掌握)</p>\n<pre><code>A:是局部内部类的简化形式\nB:前提\n    存在一个类或者接口\nC:格式:\n    new 类名或者接口名() {\n        重写方法;\n    }\nD:本质：\n    其实是继承该类或者实现接口的子类匿名对象</code></pre><p>(8)匿名内部类在开发中的使用</p>\n<pre><code>我们在开发的时候，会看到抽象类，或者接口作为参数。\n而这个时候，我们知道实际需要的是一个子类对象。\n如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。\n\ninterface Person {\n    public abstract void study();\n}\n\nclass PersonDemo {\n    public void method(Person p) {\n        p.study();\n    }\n}\n\nclass PersonTest {\n    public static void main(String[] args) {\n        PersonDemo pd = new PersonDemo();\n        pd.method(new Person() {\n            public void study() {\n                System.out.println(&quot;好好学习，天天向上&quot;);\n            }\n        });\n    }\n}</code></pre><p>(9)匿名内部类的面试题(补齐代码)</p>\n<pre><code>interface Inter {\n    void show();\n}\n\nclass Outer {\n    public static Inter method() {\n        return new Inter() {\n            public void show() {\n                System.out.println(&quot;HelloWorld&quot;);\n            }    \n        };\n    }\n}\n\nclass OuterDemo {\n    public static void main(String[] args) {\n        Outer.method().show(); //&quot;HelloWorld&quot;\n    }\n\n}</code></pre><p>Java开发工具</p>\n<pre><code>## 1. Eclipse的概述使用(掌握)\n    请参照ppt和课堂练习.txt\n\n## 2. API的概述(了解)\n    (1)应用程序编程接口。\n    (2)就是JDK提供给我们的一些提高编程效率的java类。</code></pre><p>​<br>    ## 3. Object类(掌握)<br>        (1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。<br>        (2)Object类的构造方法有一个，并且是无参构造<br>            这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造<br>        (3)要掌握的方法：<br>            A:toString()<br>                返回对象的字符串表示，默认是由类的全路径+’@’+哈希值的十六进制表示。<br>                这个表示其实是没有意义的，一般子类都会重写该方法。<br>                如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。<br>                但是最终还是自动生成。<br>            B:equals()<br>                比较两个对象是否相同。默认情况下，比较的是地址值是否相同。<br>                而比较地址值是没有意义的，所以，一般子类也会重写该方法。<br>                重写过程，我也详细的讲解和分析了。<br>                但是最终还是自动生成。<br>        (4)要了解的方法：<br>            A:hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。<br>            B:getClass() 返回对象的字节码文件对象，反射中我们会详细讲解<br>            C:finalize() 用于垃圾回收，在不确定的时间<br>            D:clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。<br>        (5)两个注意问题；<br>            A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。<br>            B:面试题<br>                ==和equals()的区别?<br>                A:==<br>                    基本类型：比较的是值是否相同<br>                    引用类型：比较的是地址值是否相同<br>                B:equals()<br>                    只能比较引用类型。默认情况下，比较的是地址值是否相同。</p>\n<pre><code>但是，我们可以根据自己的需要重写该方法。</code></pre><h1 id=\"Java常见对象\"><a href=\"#Java常见对象\" class=\"headerlink\" title=\"Java常见对象\"></a>Java常见对象</h1><h2 id=\"1-Scanner的使用-了解\"><a href=\"#1-Scanner的使用-了解\" class=\"headerlink\" title=\"1. Scanner的使用(了解)\"></a>1. Scanner的使用(了解)</h2><pre><code>    (1)在JDK5以后出现的用于键盘录入数据的类。\n    (2)构造方法：\n        A:讲解了System.in这个东西。\n            它其实是标准的输入流,对应于键盘录入\n        B:构造方法\n            InputStream is = System.in;\n            Scanner(InputStream is)\n        C:常用的格式\n            Scanner sc = new Scanner(System.in);\n(3)基本方法格式：\n    A:hasNextXxx() 判断是否是某种类型的\n    B:nextXxx()    返回某种类型的元素\n(4)要掌握的两个方法\n    A:public int nextInt()\n    B:public String nextLine()\n(5)需要注意的小问题\n    A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。\n    B:解决方案：\n        a:重新定义一个Scanner对象\n        b:把所有的数据都用字符串获取，然后再进行相应的转换</code></pre><h2 id=\"2-String类的概述和使用-掌握\"><a href=\"#2-String类的概述和使用-掌握\" class=\"headerlink\" title=\"2. String类的概述和使用(掌握)\"></a>2. String类的概述和使用(掌握)</h2><pre><code>(1)多个字符组成的一串数据。\n    其实它可以和字符数组进行相互转换。\n(2)构造方法：\n    A:public String()\n    B:public String(byte[] bytes)\n    C:public String(byte[] bytes,int offset,int length)\n    D:public String(char[] value)\n    E:public String(char[] value,int offset,int count)\n    F:public String(String original)\n    下面的这一个虽然不是构造方法，但是结果也是一个字符串对象\n    G:String s = &quot;hello&quot;;\n(3)字符串的特点\n    A:字符串一旦被赋值，就不能改变。\n        注意：这里指的是字符串的内容不能改变，而不是引用不能改变。\n    B:字面值作为字符串对象和通过构造方法创建对象的不同\n        String s = new String(&quot;hello&quot;);和String s = &quot;hello&quot;的区别?\n        new String(&quot;hello&quot;)会在堆内存开辟空间,另一种不会,但是最终的值都在字符串缓存区.\n(4)字符串的面试题(看程序写结果)\n    A:==和equals()\n        String s1 = new String(&quot;hello&quot;);\n        String s2 = new String(&quot;hello&quot;);\n        System.out.println(s1 == s2);// false\n        System.out.println(s1.equals(s2));// true\n\n\n        String s3 = new String(&quot;hello&quot;);\n        String s4 = &quot;hello&quot;;\n        System.out.println(s3 == s4);// false\n        System.out.println(s3.equals(s4));// true\n\n\n        String s5 = &quot;hello&quot;;\n        String s6 = &quot;hello&quot;;\n        System.out.println(s5 == s6);// true(常量会先去缓存区找,存在就不创建新的对象)\n        System.out.println(s5.equals(s6));// true\n    B:字符串的拼接\n        String s1 = &quot;hello&quot;;\n        String s2 = &quot;world&quot;;\n        String s3 = &quot;helloworld&quot;;\n        System.out.println(s3 == s1 + s2);// false\n        System.out.println(s3.equals((s1 + s2)));// true\n\n\n        System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// false 这个我们错了，应该是true\n        System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true\n(5)字符串的功能(自己补齐方法中文意思)\n    A:判断功能\n        boolean equals(Object obj)\n        boolean equalsIgnoreCase(String str)\n        boolean contains(String str)\n        boolean startsWith(String str)\n        boolean endsWith(String str)\n        boolean isEmpty()\n    B:获取功能\n        int length()\n        char charAt(int index)\n        int indexOf(int ch)\n        int indexOf(String str)\n        int indexOf(int ch,int fromIndex)\n        int indexOf(String str,int fromIndex)\n        String substring(int start)\n        String substring(int start,int end)\n    C:转换功能\n        byte[] getBytes()\n        char[] toCharArray()\n        static String valueOf(char[] chs)\n        static String valueOf(int i)\n        String toLowerCase()\n        String toUpperCase()\n        String concat(String str)\n    D:其他功能\n        a:替换功能 \n            String replace(char old,char new)\n            String replace(String old,String new)\n        b:去空格功能\n            String trim()\n        c:按字典比较功能\n            int compareTo(String str)\n            int compareToIgnoreCase(String str) \n(6)字符串的案例\n    A:模拟用户登录\n        public static void login(String userName, String passwd) {\n            if (userName == &quot;Xmos&quot; &amp;&amp; passwd == &quot;123&quot;) {\n                System.out.println(&quot;login success&quot;);\n            }\n        }\n    B:字符串遍历\n        public static void printString(String s) {\n            char[] c = s.toCharArray();\n            for (int i = 0; i &lt; c.length; i++) {\n                System.out.print(c[i]);\n            }\n        }\n    C:统计字符串中大写，小写及数字字符的个数\n        public static void method(String s) {\n            char[] c = s.toCharArray();\n            int lowerCaseNum = 0;\n            int upperCaseNum = 0;\n            int num = 0;\n            for (char c1 : c) {\n                if (c1 &gt;= &apos;a&apos; &amp;&amp; c1 &lt;= &apos;z&apos;) {\n                    lowerCaseNum++;\n                } else if (c1 &gt;= &apos;A&apos; &amp;&amp; c1 &lt;= &apos;Z&apos;) {\n                    upperCaseNum++;\n                } else if (c1 &gt;= &apos;0&apos; &amp;&amp; c1 &lt;= &apos;9&apos;) {\n                    num++;\n                }\n            }\n\n    D:把字符串的首字母转成大写，其他小写\n        public static void method1(String s) {\n            String s1 = s.substring(0, 1);\n            String s2 = s.substring(1, s.length());\n            String s3 = s1.toUpperCase() + s2.toLowerCase();\n\n            System.out.println(s3);\n        }        \n    E:把int数组拼接成一个指定格式的字符串\n        //方法一\n        public static void method3(int[] i) {\n            String s = Arrays.toString(i);\n            System.out.println(s);\n        }\n        //方法二\n        public static void method3(int[] i) {\n                String s = &quot;&quot;;\n                for (int i1 : i) {\n                    s += String.valueOf(i1);\n                }\n                System.out.println(s);\n            }\n    F:字符串反转\n        public static void revers(String s) {\n            char[] c = s.toCharArray();\n            for (int i = 0; i &lt; c.length / 2; i++) {\n                char tmp = c[i];\n                c[i] = c[c.length - 1 - i];\n                c[c.length - 1 - i] = tmp;\n            }\n            System.out.println(String.valueOf(c));\n        }        \n    G:统计大串中小串出现的次数</code></pre><h2 id=\"1-StringBuffer-掌握\"><a href=\"#1-StringBuffer-掌握\" class=\"headerlink\" title=\"1. StringBuffer(掌握)\"></a>1. StringBuffer(掌握)</h2><pre><code>(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了\n   一个字符串缓冲区类。StringBuffer供我们使用。\n(2)StringBuffer的构造方法\n    A:StringBuffer()\n    B:StringBuffer(int size)\n    C:StringBuffer(String str)\n(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)\n    A:添加功能\n        appen();\n    B:删除功能\n        delete();\n    C:替换功能\n        replace()\n    D:反转功能\n        reverse()\n    E:截取功能(注意这个返回值)\n        String substring()\n(4)StringBuffer的练习(做一遍)\n    A:String和StringBuffer相互转换\n        String -- StringBuffer\n            构造方法\n        StringBuffer -- String\n            toString()方法\n    B:字符串的拼接\n        StringBuffer sb = new StringBuffer(&quot;hello&quot;);\n        StringBuffer sb2 = new StringBuffer(&quot;world&quot;);\n\n        StringBuffer sb3 = sb.append(sb2);\n    C:把字符串反转\n        StringBuffer sb = new StringBuffer(&quot;abc&quot;);\n        StringBuffer sb1 = sb.reverse();\n    D:判断一个字符串是否对称\n        public static void method(StringBuffer sb) {\n            if (sb.toString().equals(sb.reverse().toString())) {\n                System.out.println(true);\n            } else {\n                System.out.println(false);\n            }\n        }\n\n(5)面试题\n    小细节：\n        StringBuffer：同步的，数据安全，效率低。\n        StringBuilder：不同步的，数据不安全，效率高。\n    A:String,StringBuffer,StringBuilder的区别\n        String 字符串常量\n        StringBuffer 字符串变量（线程安全）\n        StringBuilder 字符串变量（非线程安全）\n    B:StringBuffer和数组的区别?\n        StringBuffer : 可以存放任意类型的数据\n        数组 : 只能存放同类型的数据\n(6)注意的问题：\n    String作为形式参数，StringBuffer作为形式参数。\n        String : 不会受影响\n        StringBuffer : 除了=操作，其他操作会受影响</code></pre><h2 id=\"2-数组高级以及Arrays-掌握\"><a href=\"#2-数组高级以及Arrays-掌握\" class=\"headerlink\" title=\"2. 数组高级以及Arrays(掌握)\"></a>2. 数组高级以及Arrays(掌握)</h2><pre><code>(1)排序\n    A:冒泡排序\n        相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。\n\n        public static void bubbleSort(int[] arr) {\n            for(int x=0; x&lt;arr.length-1; x++) {\n                for(int y=0; y&lt;arr.length-1-x; y++) {\n                    if(arr[y] &gt; arr[y+1]) {\n                        int temp = arr[y];\n                        arr[y] = arr[y+1];\n                        arr[y+1] = temp;\n                    }\n                }\n            }\n        }\n\n    B:选择排序\n        把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。\n\n        public static void selectSort(int[] arr) {\n            for(int x=0; x&lt;arr.length-1; x++) {\n                for(int y=x+1; y&lt;arr.length; y++) {\n                    if(arr[y] &lt; arr[x]) {\n                        int temp = arr[x];\n                        arr[x] = arr[y];\n                        arr[y] = temp;\n                    }\n                }\n            }\n        }\n(2)查找\n    A:基本查找\n        针对数组无序的情况\n\n        public static int getIndex(int[] arr,int value) {\n            int index = -1;\n\n            for(int x=0; x&lt;arr.length; x++) {\n                if(arr[x] == value) {\n                    index = x;\n                    break;\n                }\n            }\n\n            return index;\n        }\n    B:二分查找(折半查找)\n        针对数组有序的情况(千万不要先排序，在查找)\n\n        public static int binarySearch(int[] arr,int value) {\n            int min = 0;\n            int max = arr.length-1;\n            int mid = (min+max)/2;\n\n            while(arr[mid] != value) {\n                if(arr[mid] &gt; value) {\n                    max = mid - 1;\n                }else if(arr[mid] &lt; value) {\n                    min = mid + 1;\n                }\n\n                if(min &gt; max) {\n                    return -1;\n                }\n\n                mid = (min+max)/2;\n            }\n\n            return mid;\n        }\n(3)Arrays工具类\n    A:是针对数组进行操作的工具类。包括排序和查找等功能。\n    B:要掌握的方法(自己补齐方法)\n        把数组转成字符串：\n            Arrays.toString();\n        排序：\n            Arrays.sort();\n        二分查找：\n            Arrays.binarySearch();\n(4)Arrays工具类的源码解析\n(5)把字符串中的字符进行排序\n    举例：\n        &quot;edacbgf&quot;\n        得到结果\n        &quot;abcdefg&quot;\n        String s = &quot;edacbgf&quot;;\n        char[] c = s.toCharArray();\n        Arrays.sort(c);\n        System.out.println(Arrays.toString(c));</code></pre><h2 id=\"3-Integer-掌握\"><a href=\"#3-Integer-掌握\" class=\"headerlink\" title=\"3. Integer(掌握)\"></a>3. Integer(掌握)</h2><pre><code>(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型\n    byte         Byte\n    short        Short\n    int            Integer\n    long        Long\n    float        Float\n    double        Double\n    char        Character\n    boolean        Boolean\n(2)Integer的构造方法\n    A:Integer i = new Integer(100);\n    B:Integer i = new Integer(&quot;100&quot;);\n        注意：这里的字符串必须是由数字字符组成\n(3)String和int的相互转换\n    A:String -- int\n        Integer.parseInt(&quot;100&quot;);\n    B:int -- String\n        String.valueOf(100);\n(4)其他的功能(了解)\n    进制转换\n        Integer.toBinaryString();\n        Integer.toHexString();\n        Integer.toOctalString();\n(5)JDK5的新特性\n    自动装箱    基本类型--引用类型\n    自动拆箱    引用类型--基本类型\n\n    把下面的这个代码理解即可：\n        Integer i = 100;\n        i += 200;\n(6)面试题\n    -128到127之间的数据缓冲池问题</code></pre><h2 id=\"4-Character-了解\"><a href=\"#4-Character-了解\" class=\"headerlink\" title=\"4. Character(了解)\"></a>4. Character(了解)</h2><pre><code>(1)Character构造方法    \n    Character ch = new Character(&apos;a&apos;);\n(2)要掌握的方法：(自己补齐)\n    A:判断给定的字符是否是大写\n        isUpperCase();\n    B:判断给定的字符是否是小写\n        isLowerCase();\n    C:判断给定的字符是否是数字字符\n        isDigit();\n    D:把给定的字符转成大写\n        toUpperCase();\n    E:把给定的字符转成小写\n        toLowerCase();\n(3)案例：\n\n    统计字符串中大写，小写及数字字符出现的次数\n        String s = &quot;abcDEF123&quot;;\n        char[] c = s.toCharArray();\n        int lowerCaseNum = 0;\n        int upperCaseNum = 0;\n        int digitNum = 0;\n\n        for (char c1 : c) {\n            if (Character.isLowerCase(c1)) {\n                lowerCaseNum++;\n            } else if (Character.isUpperCase(c1)) {\n                upperCaseNum++;\n            } else if (Character.isDigit(c1)) {\n                digitNum++;\n            }\n        }\n\n        System.out.println(&quot;lowerCase:&quot; + lowerCaseNum + &quot;\\t&quot; + &quot;upperCase:&quot; + upperCaseNum + &quot;\\t&quot; + &quot;digit:&quot; + digitNum);</code></pre><h2 id=\"1-正则表达式-理解\"><a href=\"#1-正则表达式-理解\" class=\"headerlink\" title=\"1. 正则表达式(理解)\"></a>1. 正则表达式(理解)</h2><pre><code>(1)就是符合一定规则的字符串\n(2)常见规则\n    A:字符\n        x 字符 x。举例：&apos;a&apos;表示字符a\n        \\\\ 反斜线字符。\n        \\n 新行（换行）符 (&apos;\\u000A&apos;) \n        \\r 回车符 (&apos;\\u000D&apos;)\n\n    B:字符类\n        [abc] a、b 或 c（简单类） \n        [^abc] 任何字符，除了 a、b 或 c（否定） \n        [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） \n        [0-9] 0到9的字符都包括\n\n    C:预定义字符类\n        . 任何字符。我的就是.字符本身，怎么表示呢? \\.\n        \\d 数字：[0-9]\n        \\w 单词字符：[a-zA-Z_0-9]\n            在正则表达式里面组成单词的东西必须有这些东西组成\n\n    D:边界匹配器\n        ^ 行的开头 \n        $ 行的结尾 \n        \\b 单词边界\n            就是不是单词字符的地方。\n            举例：hello world?haha;xixi\n\n    E:Greedy 数量词 \n        X? X，一次或一次也没有\n        X* X，零次或多次\n        X+ X，一次或多次\n        X{n} X，恰好 n 次 \n        X{n,} X，至少 n 次 \n        X{n,m} X，至少 n 次，但是不超过 m 次 \n(3)常见功能：(分别用的是谁呢?)\n    A:判断功能\n        String类的public boolean matches(String regex)\n    B:分割功能\n        String类的public String[] split(String regex)\n    C:替换功能\n        String类的public String replaceAll(String regex,String replacement)\n    D:获取功能\n        Pattern和Matcher\n            Pattern p = Pattern.compile(&quot;a*b&quot;);\n            Matcher m = p.matcher(&quot;aaaaab&quot;);\n\n            find():查找存不存在\n            group():获取刚才查找过的数据\n(4)案例\n    A:判断电话号码和邮箱\n        //普安段邮箱\n        public static boolean checkMail(String s){\n            String regex = &quot;\\\\d*\\\\w*@sina\\\\.com&quot;;\n            return s.matches(regex);\n        }\n        //判断电话号码\n        public static boolean checkPhoneNum(String s) {\n            String regex = &quot;\\\\d{11}&quot;;\n            return s.matches(regex);\n        }\n    B:按照不同的规则分割数据\n        public static String[] split(String s) {\n            String regex = &quot;,&quot;;\n            String[] result = s.split(regex);\n            return result;\n        }\n    C:把论坛中的数字替换为*\n        //替换为和数字等量的*\n        public static String replaceStar(String s) {\n            String regex = &quot;\\\\d&quot;;\n            return s.replaceAll(regex, &quot;*&quot;);\n        }\n        //所有相连数字替换为一个*\n        public static String replaceStar(String s) {\n            String regex = &quot;\\\\d+&quot;;\n            return s.replaceAll(regex, &quot;*&quot;);\n        }\n    D:获取字符串中由3个字符组成的单词\n        public static List&lt;String&gt; method(String s) {\n            Pattern p = Pattern.compile(&quot;a\\\\d{3}b&quot;);\n            Matcher m = p.matcher(s);\n            List&lt;String&gt; result = new ArrayList&lt;String&gt;();\n\n            while (m.find()) {\n                result.add(m.group());\n            }\n            return  result;\n        }</code></pre><h2 id=\"2-Math-掌握\"><a href=\"#2-Math-掌握\" class=\"headerlink\" title=\"2. Math(掌握)\"></a>2. Math(掌握)</h2><pre><code>(1)针对数学运算进行操作的类\n(2)常见方法(自己补齐)\n    A:绝对值\n        Math.abs();\n    B:向上取整\n        Math.ceil();\n    C:向下取整\n        Math.floor();\n    D:两个数据中的大值\n        Math.max();\n    E:a的b次幂\n        Math.pow(a, b);\n    F:随机数\n        Math.random();\n    G:四舍五入\n        Math.round();\n    H:正平方根\n        Math.sqrt();\n(3)案例：\n    A:猜数字小游戏\n        Scanner sc = new Scanner(System.in);\n        int i = (int)(Math.random() * 100) + 1;\n        int answer;\n        while ((answer = sc.nextInt()) != i) {\n            if (answer &gt; i) {\n                System.out.println(&quot;bigger than result,go on&quot;);\n            } else if (answer &lt; i) {\n                System.out.println(&quot;smaller than result,go on&quot;);\n            }\n        }\n        System.out.println(&quot;you are right&quot;);\n    B:获取任意范围的随机数\n        Scanner sc = new Scanner(System.in);\n        System.out.println(&quot;请输入起始:&quot;);\n        int start = sc.nextInt();\n        System.out.println(&quot;请输入结束:&quot;);\n        int end = sc.nextInt();\n\n        int i = (int)(Math.random() * (end - start)) + start;\n        System.out.println(i);</code></pre><h2 id=\"3-Random-理解\"><a href=\"#3-Random-理解\" class=\"headerlink\" title=\"3. Random(理解)\"></a>3. Random(理解)</h2><pre><code>(1)用于产生随机数的类\n(2)构造方法:\n    A:Random() 默认种子，每次产生的随机数不同\n    B:Random(long seed) 指定种子，每次种子相同，随机数就相同\n(3)成员方法:\n    A:int nextInt() 返回int范围内的随机数\n    B:int nextInt(int n) 返回[0,n)范围内的随机数</code></pre><h2 id=\"4-System-掌握\"><a href=\"#4-System-掌握\" class=\"headerlink\" title=\"4. System(掌握)\"></a>4. System(掌握)</h2><pre><code>(1)系统类,提供了一些有用的字段和方法\n(2)成员方法(自己补齐)\n    A:运行垃圾回收器\n        System.gc();\n    B:退出jvm\n        System.exit(0);\n    C:获取当前时间的毫秒值\n        System.currentTimemillis();\n    D:数组复制\n        System.arraycopy();</code></pre><h2 id=\"5-BigInteger-理解\"><a href=\"#5-BigInteger-理解\" class=\"headerlink\" title=\"5. BigInteger(理解)\"></a>5. BigInteger(理解)</h2><pre><code>(1)针对大整数的运算\n(2)构造方法    \n    A:BigInteger(String s)\n(3)成员方法(自己补齐)\n    A:加\n        add();\n    B:减\n        subtract();\n    C:乘\n        multiply();\n    D:除\n        divide();\n    E:商和余数\n        divideAndRemainder();</code></pre><h2 id=\"6-BigDecimal-理解\"><a href=\"#6-BigDecimal-理解\" class=\"headerlink\" title=\"6. BigDecimal(理解)\"></a>6. BigDecimal(理解)</h2><pre><code>(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)\n(2)构造方法\n    A:BigDecimal(String s)\n(3)成员方法：\n    A:加\n        add();\n    B:减\n        subtract();\n    C:乘\n        multiply();\n    D:除\n        divide();\n    E:自己保留小数几位\n        setScale();</code></pre><h2 id=\"7-Date-DateFormat-掌握\"><a href=\"#7-Date-DateFormat-掌握\" class=\"headerlink\" title=\"7. Date/DateFormat(掌握)\"></a>7. Date/DateFormat(掌握)</h2><pre><code>(1)Date是日期类，可以精确到毫秒。\n    A:构造方法\n        Date()\n        Date(long time)\n    B:成员方法\n        getTime()\n        setTime(long time)\n    C:日期和毫秒值的相互转换\n    案例：你来到这个世界多少天了?\n(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat\n    A:SimpleDateFormat(String pattern) 给定模式\n        yyyy-MM-dd HH:mm:ss\n    B:日期和字符串的转换\n        a:Date -- String\n            format()\n\n        b:String -- Date\n            parse()\n    C:案例：\n        制作了一个针对日期操作的工具类。\n            Date d = new Date();\n            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n            System.out.println(sdf.format(d));</code></pre><h2 id=\"8-Calendar-掌握\"><a href=\"#8-Calendar-掌握\" class=\"headerlink\" title=\"8. Calendar(掌握)\"></a>8. Calendar(掌握)</h2><pre><code>(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。\n(2)如何得到一个日历对象呢?\n    Calendar rightNow = Calendar.getInstance();\n    本质返回的是子类对象\n(3)成员方法\n    A:根据日历字段得到对应的值\n        Calendar c =Calendar.getInstance();\n        System.out.println(c.get(Calendar.YEAR));\n        System.out.println(c.get(Calendar.MONTH));\n        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n    B:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值\n        add(Calendar.DAY_OF_MONTH, +3);\n    C:设置日历对象的年月日\n        set(2018,5,30);\n        set(Calendar.YEAR, 2018);\n        set(Calendar.MONTH, 2018);\n        set(Calendar.DAY_OF_MONTH, 2018);\n(4)案例：\n    计算任意一年的2月份有多少天?\n        Scanner sc = new Scanner(System.in);\n        Calendar c =Calendar.getInstance();\n\n        c.set(Calendar.YEAR, sc.nextInt());\n        System.out.println(c.get(Calendar.DAY_OF_MONTH));</code></pre><h1 id=\"Java集合框架\"><a href=\"#Java集合框架\" class=\"headerlink\" title=\"Java集合框架\"></a>Java集合框架</h1><h1 id=\"JavaIO流\"><a href=\"#JavaIO流\" class=\"headerlink\" title=\"JavaIO流\"></a>JavaIO流</h1><h2 id=\"1-异常-理解\"><a href=\"#1-异常-理解\" class=\"headerlink\" title=\"1. 异常(理解)\"></a>1. 异常(理解)</h2><pre><code>(1)程序出现的不正常的情况。\n(2)异常的体系\n    Throwable\n        |--Error    严重问题，我们不处理。\n        |--Exception\n            |--RuntimeException    运行期异常，我们需要修正代码\n            |--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过\n(3)异常的处理：\n    A:JVM的默认处理\n        把异常的名称,原因,位置等信息输出在控制台，但是程序不能继续执行了。\n    B:自己处理\n        a:try...catch...finally\n            自己编写处理代码,后面的程序可以继续执行\n        b:throws\n            把自己处理不了的，在方法上声明，告诉调用者，这里有问题\n(4)面试题\n    A:编译期异常和运行期异常的区别?\n        编译期异常 必须要处理的，否则编译不通过\n        运行期异常 可以不处理，也可以处理\n    B:throw和throws是的区别\n        throw:\n            在方法体中,后面跟的是异常对象名,并且只能是一个\n            throw抛出的是一个异常对象，说明这里肯定有一个异常产生了\n        throws:\n            在方法声明上,后面跟的是异常的类名,可以是多个\n            throws是声明方法有异常，是一种可能性，这个异常并不一定会产生\n(5)finally关键字及其面试题\n    A:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了\n    B:面试题\n        a:final,finally,finalize的区别?\n            final : 关键字,修饰类、方法、变量,被修饰的类无法被继承,方法无法重写,变量值不能改变.\n            finally : try...catch...finally,一定会执行.\n            finalize : 对象被垃圾回收器回收时执行的方法.\n        b:如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后\n            会，前。\n\n            实际上在中间。这个上课我们讲过\n    C:异常处理的变形\n        try...catch...finally\n        try...catch...\n        try...catch...catch...\n        try...catch...catch...fianlly\n        try...finally\n(6)自定义异常\n    继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可\n        public class MyException extends RuntimeException {\n            public MyException(String message) {\n                super(message);\n            }\n\n            public MyException() {\n                super();\n            }\n        }\n(7)异常的注意实现\n    A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 \n    B:父的方法没有异常抛出,子的重写方法不能有异常抛出\n    C:父的方法抛出多个异常,子的重写方法必须比父少或者小</code></pre><h2 id=\"2-File-掌握\"><a href=\"#2-File-掌握\" class=\"headerlink\" title=\"2. File(掌握)\"></a>2. File(掌握)</h2><pre><code>(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件\n(2)构造方法\n    A:File file = new File(&quot;e:\\\\demo\\\\a.txt&quot;);\n    B:File file = new File(&quot;e:\\\\demo&quot;,&quot;a.txt&quot;);\n    C:File file = new File(&quot;e:\\\\demo&quot;);\n      File file2 = new File(file,&quot;a.txt&quot;);\n(3)File类的功能(自己补齐)\n    A:创建功能\n        createNewFile();\n        mkdir();\n        mkdirs();\n    B:删除功能\n        delete();\n    C:重命名功能\n        renameTo();\n    D:判断功能\n        isFile();\n        isDirectory();\n        exists();\n        canRea();\n        canWrite();\n        isAbsolute();\n        isHidden();\n    E:获取功能\n        getAbsoluteFile();\n        getAbsolutePath();\n        getPath();\n        getParent();\n        getParentFile();\n        getName();\n        length();\n        lastModified();\n    F:高级获取功能\n        list();\n        listFiles();\n    G:过滤器功能\n        list(FilenameFilter filter);\n            String[] s = file1.list(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return new File(dir, name).isFile() &amp;&amp; name.endsWith(&quot;.jpg&quot;);\n            }\n        });\n        listFiles(FilenameFilter filter);\n(4)案例：\n    A:输出指定目录下指定后缀名的文件名称\n        a:先获取所有的，在遍历的时候判断，再输出\n            File file = new File(&quot;D:\\\\Movie\\\\M&quot;);\n            String[] s = file.list();\n\n            for (String result : s) {\n                if (result.endsWith(&quot;.mp4&quot;)) {\n                    System.out.println(result);\n                }\n            }\n        b:先判断，再获取，最后直接遍历输出即可\n            String[] s1 = file.list(new FilenameFilter() {\n                @Override\n                public boolean accept(File dir, String name) {\n                    return name.endsWith(&quot;.mp4&quot;);\n                }\n            });\n            for (String result : s1) {\n                System.out.println(result);\n            }\n    B:批量修改文件名称\n        File file = new File(&quot;D:\\\\Movie&quot;);\n        String[] s = file.list(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return name.startsWith(&quot;相对宇宙&quot;);\n            }\n        });\n        for (String result : s) {\n            System.out.println(&quot;beforeRename : &quot; + result);\n            File file1 = new File(file,result.replaceAll(&quot;WEB.*影视\\\\.&quot;, &quot;&quot;));\n            File file2 = new File(file, result);\n            file2.renameTo(file1);\n            System.out.println(&quot;afterRename : &quot; + file1.exists() + &quot;, &quot; + file1.getName());\n        }\n        ## 1. 递归(理解)\n\n(1)方法定义中调用方法本身的现象\n    举例：老和尚给小和尚讲故事，我们学编程\n(2)递归的注意事项；\n    A:要有出口，否则就是死递归\n    B:次数不能过多，否则内存溢出\n    C:构造方法不能递归使用\n(3)递归的案例：\n    A:递归求阶乘\n        public static int method(int i) {\n            while (i &gt; 1) {\n                return i * method(--i);\n            }\n            return 1;\n        }\n    B:兔子问题\n    C:递归输出指定目录下所有指定后缀名的文件绝对路径\n        public static void method(File filePath, String suffix) {\n            File[] files = filePath.listFiles();\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    method(file, suffix);\n                } else if (file.getName().endsWith(suffix)){\n                    System.out.println(file.getName());\n                }\n            }\n        }\n    D:递归删除带内容的目录(小心使用)\n        public static void method(File filePath) {\n            File[] files = filePath.listFiles();\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    method(file);\n                } else {\n                    file.delete();\n                }\n            }\n            filePath.delete();\n        }</code></pre><h2 id=\"2-IO流-掌握\"><a href=\"#2-IO流-掌握\" class=\"headerlink\" title=\"2. IO流(掌握)\"></a>2. IO流(掌握)</h2><pre><code>(1)IO用于在设备间进行数据传输的操作    \n(2)分类：\n    A:流向\n        输入流    读取数据\n        输出流    写出数据\n    B:数据类型\n        字节流    \n                字节输入流\n                字节输出流\n        字符流\n                字符输入流\n                字符输出流\n    注意：\n        a:如果我们没有明确说明按照什么分，默认按照数据类型分。\n        b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。\n(3)FileOutputStream写出数据\n    A:操作步骤\n        a:创建字节输出流对象\n        b:调用write()方法\n        c:释放资源\n\n    B:代码体现：\n        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);\n\n        fos.write(&quot;hello&quot;.getBytes());\n\n        fos.close();\n\n    C:要注意的问题?\n        a:创建字节输出流对象做了几件事情?\n            调用系统功能去创建文件\n            创建fos对象\n            把fos对象指向这个文件\n        b:为什么要close()?\n            关闭此文件输出流并释放与此流有关的所有系统资源。\n        c:如何实现数据的换行?\n            windows:\\r\\n\n            linux:\\n\n            Mac:\\r\n        d:如何实现数据的追加写入?\n            FileOutputStream fos = new FileOutputStream(&quot;F:\\\\&quot;, true);\n(4)FileInputStream读取数据\n    A:操作步骤\n        a:创建字节输入流对象\n        b:调用read()方法\n        c:释放资源\n\n    B:代码体现：\n        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);\n\n        //方式1\n        int by = 0;\n        while((by=fis.read())!=-1) {\n            System.out.print((char)by);\n        }\n\n        //方式2\n        byte[] bys = new byte[1024];\n        int len = 0;\n        while((len=fis.read(bys))!=-1) {\n            System.out.print(new String(bys,0,len));\n        }\n\n        fis.close();\n(5)案例：2种实现\n    A:复制文本文件\n        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;);\n        //方式一\n        int i = 0;\n        while ((i = fis.read()) != -1) {\n            fos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式二\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    B:复制图片\n        FileInputStream fis = new FileInputStream(&quot;a.jpg&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;b.jpg&quot;);\n        //方式一\n        int i = 0;\n        while ((i = fis.read()) != -1) {\n            fos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式二\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    C:复制视频\n        FileInputStream fis = new FileInputStream(&quot;a.mp4&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;b.mp4&quot;);\n        //方式一\n        int i = 0;\n        while ((i = fis.read()) != -1) {\n            fos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式二\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n(6)字节缓冲区流\n    A:BufferedOutputStream\n    B:BufferedInputStream\n(7)案例：4种实现\n    A:复制文本文件\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.txt&quot;));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;));\n\n        //方式三\n        int i = 0;\n        while ((i = bis.read()) != -1) {\n            bos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式四\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    B:复制图片\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.jpg&quot;));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.jpg&quot;));\n\n        //方式三\n        int i = 0;\n        while ((i = bis.read()) != -1) {\n            bos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式四\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    C:复制视频\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.mp4&quot;));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.mp4&quot;));\n\n        //方式三\n        int i = 0;\n        while ((i = bis.read()) != -1) {\n            bos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式四\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();</code></pre><h2 id=\"3-自学字符流\"><a href=\"#3-自学字符流\" class=\"headerlink\" title=\"3. 自学字符流\"></a>3. 自学字符流</h2><pre><code>IO流分类\n    字节流：\n        InputStream\n            FileInputStream\n            BufferedInputStream\n        OutputStream\n            FileOutputStream\n            BufferedOutputStream\n\n    字符流：\n        Reader\n            FileReader\n            BufferedReader\n        Writer\n            FileWriter\n            BufferedWriter</code></pre><h2 id=\"1-字符流-掌握\"><a href=\"#1-字符流-掌握\" class=\"headerlink\" title=\"1. 字符流(掌握)\"></a>1. 字符流(掌握)</h2><pre><code>(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。\n   转换流的作用就是把字节流转换字符流来使用。\n(2)转换流其实是一个字符流\n    字符流 = 字节流 + 编码表\n(3)编码表\n    A:就是由字符和对应的数值组成的一张表\n    B:常见的编码表\n        ASCII\n        ISO-8859-1\n        GB2312\n        GBK\n        GB18030\n        UTF-8\n    C:字符串中的编码问题\n        编码\n            String -- byte[]\n        解码\n            byte[] -- String\n(4)IO流中的编码问题\n    A:OutputStreamWriter\n        OutputStreamWriter(OutputStream os):默认编码，GBK\n        OutputStreamWriter(OutputStream os,String charsetName):指定编码。\n    B:InputStreamReader\n        InputStreamReader(InputStream is):默认编码，GBK\n        InputStreamReader(InputStream is,String charsetName):指定编码\n    C:编码问题其实很简单\n        编码只要一致即可\n(5)字符流\n    Reader\n        |--InputStreamReader\n            |--FileReader\n        |--BufferedReader\n    Writer\n        |--OutputStreamWriter\n            |--FileWriter\n        |--BufferedWriter\n(6)复制文本文件(5种方式)\n    public class CopyDemo {\n    public static void main(String[] args) throws IOException {\n        File srcFile = new File(&quot;a.txt&quot;);\n        File destFile = new File(&quot;b.txt&quot;);\n\n        method1(srcFile, destFile);\n        method2(srcFile, destFile);\n        method3(srcFile, destFile);\n        method4(srcFile, destFile);\n        method5(srcFile, destFile);\n    }\n\n    private static void method5(File srcFile, File destFile) throws IOException{\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        String s = null;\n        while ((s = br.readLine()) != null) {\n            bw.write(s);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method4(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int len = 0;\n        char[] chars = new char[1024];\n        while ((len = br.read(chars)) != -1) {\n            bw.write(chars, 0, len);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method3(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int by = 0;\n        while ((by = br.read()) != -1) {\n            bw.write(by);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method2(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int len = 0;\n        char[] bytes = new char[1024];\n        while ((len = fr.read(bytes)) != -1) {\n            fw.write(bytes, 0, len);\n        }\n        fr.close();\n        fw.close();\n    }\n\n    private static void method1(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int by = 0;\n        while ((by = fr.read()) != -1) {\n            fw.write(by);\n        }\n        fr.close();\n        fw.close();\n    }\n}                                                </code></pre><h2 id=\"2-IO流小结-掌握\"><a href=\"#2-IO流小结-掌握\" class=\"headerlink\" title=\"2. IO流小结(掌握)\"></a>2. IO流小结(掌握)</h2><pre><code>IO流\n    |--字节流\n        |--字节输入流\n            InputStream\n                int read():一次读取一个字节\n                int read(byte[] bys):一次读取一个字节数组\n\n                |--FileInputStream\n                |--BufferedInputStream\n        |--字节输出流\n            OutputStream\n                void write(int by):一次写一个字节\n                void write(byte[] bys,int index,int len):一次写一个字节数组的一部分\n\n                |--FileOutputStream\n                |--BufferedOutputStream\n    |--字符流\n        |--字符输入流\n            Reader\n                int read():一次读取一个字符\n                int read(char[] chs):一次读取一个字符数组\n\n                |--InputStreamReader\n                    |--FileReader\n                |--BufferedReader\n                    String readLine():一次读取一个字符串\n        |--字符输出流\n            Writer\n                void write(int ch):一次写一个字符\n                void write(char[] chs,int index,int len):一次写一个字符数组的一部分\n\n                |--OutputStreamWriter\n                    |--FileWriter\n                |--BufferedWriter\n                    void newLine():写一个换行符\n\n                    void write(String line):一次写一个字符串</code></pre><h2 id=\"3-案例-理解-练习一遍\"><a href=\"#3-案例-理解-练习一遍\" class=\"headerlink\" title=\"3. 案例(理解 练习一遍)\"></a>3. 案例(理解 练习一遍)</h2><pre><code>A:复制文本文件 5种方式(掌握)\n    private static void method5(File srcFile, File destFile) throws IOException{\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        String s = null;\n        while ((s = br.readLine()) != null) {\n            bw.write(s);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method4(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int len = 0;\n        char[] chars = new char[1024];\n        while ((len = br.read(chars)) != -1) {\n            bw.write(chars, 0, len);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method3(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int by = 0;\n        while ((by = br.read()) != -1) {\n            bw.write(by);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method2(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int len = 0;\n        char[] bytes = new char[1024];\n        while ((len = fr.read(bytes)) != -1) {\n            fw.write(bytes, 0, len);\n        }\n        fr.close();\n        fw.close();\n    }\n\n    private static void method1(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int by = 0;\n        while ((by = fr.read()) != -1) {\n            fw.write(by);\n        }\n        fr.close();\n        fw.close();\n    }\nB:复制图片(二进制流数据) 4种方式(掌握)\n    private static void method4(File srcFile, File destFile) throws IOException{\n        BufferedInputStream bis = new BufferedInputStream(\n            new FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(\n            new FileOutputStream(destFile));\n\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        bis.close();\n        bos.close();\n    }\n\n    private static void method3(File srcFile, File destFile) throws IOException{\n        BufferedInputStream bis = new BufferedInputStream(\n            new FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(\n            new FileOutputStream(destFile));\n\n        int by = 0;\n        while ((by = bis.read()) != -1) {\n            bos.write(by);\n        }\n        bis.close();\n        bos.close();\n    }\n\n    private static void method2(File srcFile, File destFile) throws IOException{\n        FileInputStream fis = new FileInputStream(srcFile);\n        FileOutputStream fos = new FileOutputStream(destFile);\n\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes,0,len);\n        }\n        fis.close();\n        fos.close();\n    }\n\n    private static void method1(File srcFile, File destFile) throws IOException{\n        FileInputStream fis = new FileInputStream(srcFile);\n        FileOutputStream fos = new FileOutputStream(destFile);\n\n        int by = 0;\n        while ((by = fis.read()) != -1) {\n            fos.write(by);\n        }\n        fis.close();\n        fos.close();\n    }\nC:把集合中的数据存储到文本文件\n    File srcFile = new File(&quot;a.txt&quot;);\n    List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n    list.add(&quot;hello&quot;);\n    list.add(&quot;world&quot;);\n    list.add(&quot;java&quot;);\n    //方式一\n    FileOutputStream fos = new FileOutputStream(srcFile);\n    for (String s : list) {\n        fos.write((s).getBytes());\n    }\n    fos.close();\n    //方式二\n    FileWriter fw = new FileWriter(srcFile);\n    for (String s : list) {\n        fw.write(s.toCharArray());\n        fw.flush();\n    }\n    fw.close();\n    //方式三\n    BufferedWriter bw = new BufferedWriter(new FileWriter(srcFile));\n    for (String s : list) {\n        bw.write(s);\n        bw.flush();\n    }\n    bw.close();\nD:把文本文件中的数据读取到集合并遍历集合\n    File srcFile = new File(&quot;a.txt&quot;);\n    List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n    String s = null;\n    while ((s = br.readLine()) != null) {\n        list.add(s);\n    }\n    br.close();\nE:复制单级文件夹\n    File srcPath = new File(&quot;F:\\\\struts-1.2.7&quot;);\n    File destPath = new File(&quot;F:\\\\test1&quot;);\n\n    File[] srcFiles = srcPath.listFiles();\n    BufferedInputStream bis = null;\n    BufferedOutputStream bos = null;\n    if (!destPath.exists()) {\n        destPath.mkdir();\n    }\n    for (File srcFile : srcFiles) {\n        if (srcFile.isFile()) {\n             bis = new BufferedInputStream(new FileInputStream(srcFile));\n             bos = new BufferedOutputStream(\n                 new FileOutputStream(new File(destPath,srcFile.getName())));\n            int len = 0;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n                bos.flush();\n            }\n        }\n    }\n    bis.close();\n    bos.close();\nF:复制单级文件夹中指定的文件\n    File srcPath = new File(&quot;F:\\\\test&quot;);\n    File destPath = new File(&quot;F:\\\\test1&quot;);\n\n    File[] srcFiles = srcPath.listFiles(new FilenameFilter(){\n\n        @Override\n        public boolean accept(File dir, String name) {\n            return dir.isFile()&amp;&amp;name.endsWith(&quot;.java&quot;);\n        }\n    });\n    BufferedInputStream bis = null;\n    BufferedOutputStream bos = null;\n    if (!destPath.exists()) {\n        destPath.mkdir();\n    }\n    for (File srcFile : srcFiles) {\n        if (srcFile.isFile()) {\n             bis = new BufferedInputStream(new FileInputStream(srcFile));\n             bos = new BufferedOutputStream(\n                 new FileOutputStream(new File(destPath,srcFile.getName())));\n            int len = 0;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n                bos.flush();\n            }\n        }\n    }\n    bis.close();\n    bos.close();\nG:复制多级文件夹\n    public class CopyDemo {\n    public static void main(String[] args) throws IOException {\n        File srcPath = new File(&quot;F:\\\\test&quot;);\n        File destPath = new File(&quot;F:\\\\test1&quot;);\n\n        copyFolder(srcPath,destPath);\n\n    }\n\n    public static void copyFolder(File srcPath, File destPath) throws IOException{\n        if (!destPath.exists()) {\n            destPath.mkdir();\n        }\n        File[] files = srcPath.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n\n                copyFolder(file,new File(destPath,file.getName()));\n            } else if (file.isFile()) {\n                BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));\n                BufferedOutputStream bos = new BufferedOutputStream(\n                    new FileOutputStream(new File(destPath,file.getName())));\n                int len = 0;\n                byte[] bytes = new byte[1024];\n                while ((len = bis.read(bytes)) != -1) {\n                    bos.write(bytes,0,len);\n                    bos.flush();\n                }\n                bis.close();\n                bos.close();\n            }\n        }\n\n    }\n\n}\nH:键盘录入学生信息按照总分从高到低存储到文本文件\n    public class CopyDemo {\n        public static void main(String[] args) throws IOException {\n            Scanner sc = new Scanner(System.in);\n            //比较器返回-1降序，返回1升序\n            TreeSet&lt;Student&gt; studentList = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() {\n                @Override\n                public int compare(Student o1, Student o2) {\n                    int sum1 = o1.getChinese() + o1.getEnglish() + o1.getMath();\n                    int sum2 = o2.getChinese() + o2.getEnglish() + o2.getMath();\n                    if (sum1 &gt; sum2) {\n                        return -1;\n                    } else if (sum1 == sum2) {\n                        if (o1.getName().compareTo(o2.getName()) &gt;=0 ) {\n                            return -1;\n                        } else {\n                            return 1;\n                        }\n                    } else {\n                        return 1;\n                    }\n                }\n            });\n            for (int i = 0; i &lt; 3; i++) {\n                Student st = new Student();\n                System.out.println(&quot;请输入学生信息:&quot;);\n                System.out.println(&quot;姓名: &quot;);\n                st.setName(sc.nextLine());\n                System.out.println(&quot;语文: &quot;);\n                st.setChinese(Integer.valueOf(sc.nextLine()));\n                System.out.println(&quot;数学: &quot;);\n                st.setEnglish(Integer.valueOf(sc.nextLine()));\n                System.out.println(&quot;英语: &quot;);\n                st.setMath(Integer.valueOf(sc.nextLine()));\n                studentList.add(st);\n            }\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;a.txt&quot;)));\n            for (Student student : studentList) {\n                bw.write(&quot;name: &quot; + student.getName());\n                bw.newLine();\n                bw.write(&quot;chinese: &quot;+student.getChinese());\n                bw.newLine();\n                bw.write(&quot;english: &quot; + student.getEnglish());\n                bw.newLine();\n                bw.write(&quot;math: &quot;+student.getMath());\n                bw.newLine();\n                bw.write(&quot;---------------------&quot;);\n                bw.newLine();\n                bw.flush();\n            }\n            bw.close();\n        }\n}\n\nclass Student {\n    private String name;\n    private int chinese;\n    private int math;\n    private int english;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getChinese() {\n        return chinese;\n    }\n\n    public void setChinese(int chinese) {\n        this.chinese = chinese;\n    }\n\n    public int getMath() {\n        return math;\n    }\n\n    public void setMath(int math) {\n        this.math = math;\n    }\n\n    public int getEnglish() {\n        return english;\n    }\n\n    public void setEnglish(int english) {\n        this.english = english;\n    }\n}\nI:把某个文件中的字符串排序后输出到另一个文本文件中\n    File srcFile = new File(&quot;a.txt&quot;);\n    File destFile = new File(&quot;b.txt&quot;);\n\n    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n    BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n    StringBuilder sb = new StringBuilder();\n    String s = null;\n    while ((s = br.readLine()) != null) {\n        sb.append(s);\n    }\n    char[] ch = sb.toString().toCharArray();\n    Arrays.sort(ch);\n    bw.write(ch);\n    bw.close();\n    br.close();\nJ:用Reader模拟BufferedReader的特有功能\nK:模拟LineNumberReader的特有功能</code></pre><h1 id=\"Java多线程\"><a href=\"#Java多线程\" class=\"headerlink\" title=\"Java多线程\"></a>Java多线程</h1><h2 id=\"1-多线程-理解\"><a href=\"#1-多线程-理解\" class=\"headerlink\" title=\"1. 多线程(理解)\"></a>1. 多线程(理解)</h2><pre><code>(1)多线程：一个应用程序有多条执行路径\n    进程：正在执行的应用程序\n    线程：进程的执行单元，执行路径\n    单线程：一个应用程序只有一条执行路径\n    多线程：一个应用程序有多条执行路径\n\n    多进程的意义?\n        提高CPU的使用率\n    多线程的意义?\n        提高应用程序的使用率\n(2)Java程序的运行原理及JVM的启动是多线程的吗?\n    A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。\n    B:JVM的启动是多线程的，因为它至少有两个线程启动了，主线程和垃圾回收线程。\n(3)多线程的实现方案(自己补齐步骤及代码    掌握)\n    A:继承Thread类\n    public class MyThread extends Thread {\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(getName() + &quot;:&quot; + i);\n            }\n        }\n\n        public static class MyThreadTest {\n            public static void main(String[] args) {\n                MyThread mt = new MyThread();\n                mt.start();\n            }\n        }\n    }\n    B:实现Runnable接口\n    public class MyRunnable implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);\n            }\n        }\n\n        public static class MyRunnableTest {\n            public static void main(String[] args) {\n                MyRunnable mr = new MyRunnable();\n                Thread td = new Thread(mr);\n\n                td.start();\n            }\n        }\n    }\n(4)线程的调度和优先级问题\n    A:线程的调度\n        a:分时调度\n        b:抢占式调度 (Java采用的是该调度方式)\n    B:获取和设置线程优先级\n        a:默认是5\n        b:范围是1-10（Thread.MIN_PRIORITY，Thread.MAX_PRIORITY）\n(5)线程的控制(常见方法)\n    A:休眠线程：sleep()\n    B:加入线程：join()\n    C:礼让线程：yield()\n    D:后台线程：setDaemon()\n    E:终止线程(掌握)：interrupt()\n(6)线程的生命周期(参照    线程生命周期图解.bmp)\n    A:新建\n    B:就绪\n    C:运行\n    D:阻塞\n    E:死亡</code></pre><p><img src=\"https://img-blog.csdn.net/20181003115703845?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"线程生命周期图解\"></p>\n<pre><code>(7)电影院卖票程序的实现\n    A:继承Thread类\n    public class ThreadTicket extends Thread {\n        private static int ticket = 100;\n\n        @Override\n        public void run() {\n           while (true) {\n                if (ticket &gt; 0) {\n                    System.out.println(getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);\n                }\n            }\n        }\n\n        public static class ThreadTicketTest {\n            public static void main(String[] args) {\n                ThreadTicket threadTicket = new ThreadTicket();\n                ThreadTicket threadTicket1 = new ThreadTicket();\n                ThreadTicket threadTicket2 = new ThreadTicket();\n\n                threadTicket.start();\n                threadTicket1.start();\n                threadTicket2.start();\n            }\n        }\n    }\n    B:实现Runnable接口\n    public class RunnableTicket implements Runnable {\n        private int ticket = 100;\n\n        @Override\n        public void run() {\n            while (true) {\n                if (ticket &gt; 0) {\n                    System.out.println(getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);\n                }\n            }\n        }\n\n        public static class RunnableTicketTest {\n            public static void main(String[] args) {\n                RunnableTicket rt = new RunnableTicket();\n                Thread thread = new Thread(rt);\n                Thread thread1 = new Thread(rt);\n                Thread thread2 = new Thread(rt);\n\n                thread.start();\n                thread1.start();\n                thread2.start();\n            }\n        }\n    }\n(8)电影院卖票程序出问题\n    A:为了更符合真实的场景，加入了休眠100毫秒。\n    B:卖票问题\n        a:同票多次\n        b:负数票\n(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)\n    A:是否有多线程环境\n    B:是否有共享数据\n    C:是否有多条语句操作共享数据\n(10)同步解决线程安全问题\n    A:同步代码块\n        synchronized(对象) {\n            需要被同步的代码;\n        }\n\n        这里的锁对象可以是任意对象。\n\n    B:同步方法\n        把同步加在方法上。\n\n        这里的锁对象是this\n\n    C:静态同步方法\n        把同步加在方法上。\n\n        这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)\n(11)回顾以前的线程安全的类\n    A:StringBuffer\n    B:Vector\n    C:Hashtable\n    D:如何把一个线程不安全的集合类变成一个线程安全的集合类\n        用Collections工具类的方法即可。\n        List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></pre><h2 id=\"1-多线程-理解-1\"><a href=\"#1-多线程-理解-1\" class=\"headerlink\" title=\"1. 多线程(理解)\"></a>1. 多线程(理解)</h2><pre><code>(1)JDK5以后的针对线程的锁定操作和释放操作\n    Lock锁\n    public class RunnableTicket implements Runnable {\n        private int ticket = 100;\n        private ReentrantLock lock = new ReentrantLock();\n\n        @Override\n        public void run() {\n            while (true) {\n                lock.lock();\n                if (ticket &gt; 0) {\n                System.out.println(Thread.currentThread().getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                lock.unlock();\n            }\n        }\n\n        public static class RunnableTicketTest {\n            public static void main(String[] args) {\n                RunnableTicket rt = new RunnableTicket();\n                Thread thread = new Thread(rt);\n                Thread thread1 = new Thread(rt);\n                Thread thread2 = new Thread(rt);\n\n                thread.start();\n                thread1.start();\n                thread2.start();\n            }\n        }\n    }\n(2)死锁问题的描述和代码体现\npublic class DeadLockDemo implements Runnable {\n        boolean flag;\n\n        @Override\n        public void run() {\n            if (flag) {\n                synchronized (Lock.object1) {\n                    System.out.println(Thread.currentThread().getName() + &quot;获取了锁object1&quot;);\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (Lock.object2) {\n                        System.out.println(Thread.currentThread().getName() + &quot;获取了锁object2&quot;);\n                    }\n                }\n            } else {\n                synchronized (Lock.object2) {\n                    System.out.println(Thread.currentThread().getName() + &quot;获取了锁object2&quot;);\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (Lock.object1) {\n                        System.out.println(Thread.currentThread().getName() + &quot;获取了锁object1&quot;);\n                    }\n                }\n            }\n        }\n\n        public static void main(String[] args) {\n            DeadLockDemo lockDemo = new DeadLockDemo();\n            DeadLockDemo lockDemo1 = new DeadLockDemo();\n            lockDemo.flag = true;\n            Thread td1 = new Thread(lockDemo);\n            Thread td2 = new Thread(lockDemo1);\n\n            td1.start();\n            td2.start();\n        }\n    }\n\n    class Lock {\n        public static Object object1 = new Object();\n        public static Object object2 = new Object();\n    }\n(3)生产者和消费者多线程体现(线程间通信问题)\n    以学生作为资源来实现的\n\n    资源类：Student\n    设置数据类：SetThread(生产者)\n    获取数据类：GetThread(消费者)\n    测试类：StudentDemo\n\n    代码：\n        A:最基本的版本，只有一个数据。\n\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    SetThread st = new SetThread(student);\n                    GetThread gt = new GetThread(student);\n\n                    new Thread(st).start();\n                    new Thread(gt).start();\n                }\n            }\n\n            class Student {\n                String name;\n                int age;\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    student.name = &quot;xmos&quot;;\n                    student.age = 23;\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        System.out.println(student.name + &quot;:&quot; + student.age);\n                    }\n                }\n            }\n        B:改进版本，给出了不同的数据，并加入了同步机制\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    GetThread gt = new GetThread(student);\n                    SetThread st = new SetThread(student);\n\n                    new Thread(gt).start();\n                    new Thread(st).start();\n                }\n            }\n\n            class Student {\n                String name;\n                int age;\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n                private int x;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    while (true) {\n                        synchronized (student) {\n                            if (x % 2 == 0) {\n                                student.name = &quot;xmos&quot;;\n                                student.age = 23;\n                            } else {\n                                student.name = &quot;tmos&quot;;\n                                student.age = 22;\n                            }\n\n                            x++;\n                        }\n                    }\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        synchronized (student) {\n                            System.out.println(student.name + &quot;:&quot; + student.age);\n                        }\n\n                    }\n                }\n            }\n        C:等待唤醒机制改进该程序，让数据能够实现依次的出现\n            wait()\n            notify()\n            notifyAll() (多生产多消费)\n\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    GetThread gt = new GetThread(student);\n                    SetThread st = new SetThread(student);\n\n                    new Thread(gt).start();\n                    new Thread(st).start();\n                }\n            }\n\n            class Student {\n                String name;\n                int age;\n                boolean flag;\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n                private int x;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    while (true) {\n                        synchronized (student) {\n                            if (student.flag) {\n                                try {\n                                    student.wait();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                            }\n                            if (x % 2 == 0) {\n                                student.name = &quot;xmos&quot;;\n                                student.age = 23;\n                            } else {\n                                student.name = &quot;tmos&quot;;\n                                student.age = 22;\n                            }\n                            x++;\n                            student.flag = true;\n                            student.notify();\n                        }\n                    }\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        synchronized (student) {\n                            if (!student.flag) {\n                                try {\n                                    student.wait();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                            }\n                            System.out.println(student.name + &quot;:&quot; + student.age);\n                            student.flag = false;\n                            student.notify();\n                        }\n                    }\n                }\n            }\n        D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    GetThread gt = new GetThread(student);\n                    SetThread st = new SetThread(student);\n\n                    new Thread(gt).start();\n                    new Thread(st).start();\n                }\n            }\n\n            class Student {\n                private String name;\n                private int age;\n                private int x;\n                private boolean flag;\n\n                synchronized void setStudent() {\n                    while (true) {\n                        if (flag) {\n                            try {\n                                wait();\n                            } catch (InterruptedException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        if (x % 2 == 0) {\n                            name = &quot;xmos&quot;;\n                            age = 23;\n                        } else {\n                            name = &quot;tmos&quot;;\n                            age = 22;\n                        }\n                        x++;\n                        flag = true;\n                        notify();\n                    }\n                }\n\n                synchronized void getStudent() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        if (!flag) {\n                            try {\n                                wait();\n                            } catch (InterruptedException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        System.out.println(name + &quot;:&quot; + age);\n                        flag = false;\n                        notify();\n                    }\n                }\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    student.setStudent();\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    student.getStudent();\n                }\n            }\n(4)线程组\n    public class ThreadGroupDemo {\n       public static void main(String[] args) {\n            ThreadGroup tg = new ThreadGroup(&quot;MyThreadGroup&quot;);\n            MyRunnable mr = new MyRunnable();\n            Thread th1 = new Thread(tg, mr, &quot;xmos&quot;);\n            Thread th2 = new Thread(tg, mr, &quot;tmos&quot;);\n\n            th1.start();\n            th2.start();\n\n        }\n    }\n\n    class MyRunnable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getThreadGroup().getName() + &quot;:&quot; \n                + Thread.currentThread().getName());\n        }\n    }\n    (5)线程池\n        public class ThreadPoolDemo {\n            public static void main(String[] args) {\n                ExecutorService pool = Executors.newFixedThreadPool(3);\n                MyRunnable mr = new MyRunnable();\n                pool.submit(mr);\n                pool.submit(mr);\n\n                pool.shutdown();\n            }\n        }\n\n        class MyRunnable implements Runnable{\n\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        }\n(6)多线程实现的第三种方案\n    public class ThreadPoolDemo {\n        public static void main(String[] args) {\n            ExecutorService pool = Executors.newFixedThreadPool(3);\n            MyCallable mc = new MyCallable();\n            pool.submit(mc);\n            pool.submit(mc);\n\n            pool.shutdown();\n        }\n    }\n\n    class MyCallable implements Callable {\n        @Override\n        public Object call() throws Exception {\n            System.out.println(Thread.currentThread().getName());\n            return null;\n        }\n    }\n(7)定时器\n    案例1：\n        public class TimerDemo {\n            public static void main(String[] args) throws ParseException {\n                Timer t = new Timer();\n                String s = new String(&quot;2018-10-03 12:46:00&quot;);\n                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n                Date date = sdf.parse(s);\n                t.schedule(new Boom(), date, 100);\n\n                t.cancel();</code></pre><p>​<br>                }<br>            }</p>\n<pre><code>    class Boom extends TimerTask {\n\n        @Override\n        public void run() {\n            System.out.println(&quot;Boom!&quot;);\n        }\n    }\n    案例2：\n        public class TimerDemo {\n            public static void main(String[] args) throws ParseException {\n                Timer t = new Timer();\n                t.schedule(new Boom(t), 300, 100);\n            }\n        }\n\n        class Boom extends TimerTask {\n            private Timer t;\n            int i = 0;\n\n            public Boom(Timer t) {\n                this.t = t;\n            }\n\n            @Override\n            public void run() {\n                System.out.println(&quot;Boom---&quot; + ++i);\n\n                if (i == 30) {\n                    t.cancel();\n                }\n            }\n        }\n(8)多线程的面试题\n    ## 1. 多线程有几种实现方案，分别是哪几种?\n    两种。\n\n    继承Thread类\n    实现Runnable接口\n\n    扩展一种：实现Callable接口。这个得和线程池结合。\n\n    ## 2. 同步有几种方式，分别是什么?\n        两种。\n\n        同步代码块\n        同步方法\n\n    ## 3. 启动一个线程是run()还是start()?它们的区别?\n        start();\n\n        run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用\n        start():启动线程，并由JVM自动调用run()方法\n\n    ## 4. sleep()和wait()方法的区别\n        sleep():必须指时间;不释放锁。\n        wait():可以不指定时间，也可以指定时间;释放锁。\n\n    ## 5. 为什么wait(),notify(),notifyAll()等方法都定义在Object类中\n        因为这些方法的调用是依赖于锁对象的，而同步代码块的锁对象是任意锁。\n        而Object代码任意的对象，所以，定义在这里面。\n\n    ## 6. 线程的生命周期图\n        新建 -- 就绪 -- 运行 -- 死亡\n        新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡\n        建议：画图解释。</code></pre><h2 id=\"2-设计模式-理解\"><a href=\"#2-设计模式-理解\" class=\"headerlink\" title=\"2. 设计模式(理解)\"></a>2. 设计模式(理解)</h2><pre><code>(1)面试对象的常见设计原则\n    单一\n    开闭\n    里氏\n    依赖注入\n    接口\n    迪米特\n(2)设计模式概述和分类\n    A:经验的总结\n    B:三类\n        创建型\n        结构型\n        行为型\n(3)改进的设计模式\n    A:简单工厂模式（Simple Factory Pattern）\n        public abstract class Animal {\n            public abstract void eat();\n\n            public static Animal getDog() {\n                return new Dog();\n            }\n\n            public static Animal getCat() {\n                return new Cat();\n            }\n\n            public static void main(String[] args) {\n                Animal dog = Animal.getDog();\n                Animal cat = Animal.getCat();\n\n                dog.eat();\n                cat.eat();\n            }\n        }\n\n        class Dog extends Animal{\n\n            @Override\n            public void eat(){\n                System.out.println(&quot;eat bone&quot;);\n            }\n        }\n\n        class Cat extends Animal{\n\n            @Override\n            public void eat() {\n                System.out.println(&quot;eat fish&quot;);\n            }\n        }\n    B:工厂方法模式（Factory Method Pattern）\n        public abstract class Animal {\n            public abstract void eat();\n\n            public static Animal getDog() {\n                return new Dog();\n            }\n\n            public static Animal getCat() {\n                return new Cat();\n            }\n\n            public static void main(String[] args) {\n                Animal dog = new DogFactory().getAnimal();\n                Animal cat = new CatFactory().getAnimal();\n\n                dog.eat();\n                cat.eat();\n            }\n        }\n\n        interface AnimalFactory {\n            Animal getAnimal();\n        }\n\n        class DogFactory implements AnimalFactory {\n\n            @Override\n            public Animal getAnimal() {\n                return new Dog();\n            }\n        }\n\n        class CatFactory implements AnimalFactory {\n\n            @Override\n            public Animal getAnimal() {\n                return new Cat();\n            }\n        }\n\n        class Dog extends Animal {\n\n            @Override\n            public void eat() {\n                System.out.println(&quot;eat bone&quot;);\n            }\n        }\n\n        class Cat extends Animal {\n\n            @Override\n            public void eat() {\n                System.out.println(&quot;eat fish&quot;);\n            }\n        }\n    C:单例模式(Singleton Pattern掌握)\n        a:饿汉式（开发常用）\n            public class TeacherDemo {\n                public static void main(String[] args) {\n                    Teacher t1 = Teacher.getTeacher();\n                    Teacher t2 = Teacher.getTeacher();\n\n                    System.out.println(t1 == t2);\n                }\n            }\n\n            class Teacher {\n                private static Teacher teacher = new Teacher();\n\n                private Teacher() {\n                }\n\n                public static Teacher getTeacher() {\n                    return teacher;\n                }\n            }\n        b:懒汉式（面试常用，容易有线程安全问题，需要线程同步）\n            public class StudentDemo {\n                public static void main(String[] args) {\n                    Student s1 = Student.getStudent();\n                    Student s2 = Student.getStudent();\n\n                    System.out.println(s1 == s2);\n                }\n            }\n\n            class Student {\n                private static Student student = null;\n\n                private Student() {\n                }\n\n                public synchronized static Student getStudent() {\n                    if (Objects.isNull(student)) {\n                        student = new Student();\n                    }\n                    return student;\n                }\n            }\n(4)Runtime\n    JDK提供的一个单例模式应用的类。\n    还可以调用系统命令。\n    public class RuntimeDemo {\n        public static void main(String[] args) throws IOException {\n            Runtime r = Runtime.getRuntime();\n            r.exec(&quot;touch 1.txt&quot;);\n        }\n    }</code></pre><h1 id=\"JavaGUI\"><a href=\"#JavaGUI\" class=\"headerlink\" title=\"JavaGUI\"></a>JavaGUI</h1><h1 id=\"Java网络编程\"><a href=\"#Java网络编程\" class=\"headerlink\" title=\"Java网络编程\"></a>Java网络编程</h1><h2 id=\"1-网络编程-理解\"><a href=\"#1-网络编程-理解\" class=\"headerlink\" title=\"1. 网络编程(理解)\"></a>1. 网络编程(理解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)网络编程：用Java语言实现计算机间数据的信息传递和资源共享</span><br><span class=\"line\">(<span class=\"number\">2</span>)网络编程模型</span><br><span class=\"line\">\t应用层-表示层-会话层-传输层-网络层-数据链路层-物理层</span><br><span class=\"line\">(<span class=\"number\">3</span>)网络编程的三要素</span><br><span class=\"line\">\tA:IP地址</span><br><span class=\"line\">\t\ta:点分十进制：<span class=\"number\">192.168</span>.1.1</span><br><span class=\"line\">\t\tb:IP地址的组成：网络号段+主机号段</span><br><span class=\"line\">\t\tc:IP地址的分类：</span><br><span class=\"line\">\t\t\tA类\t<span class=\"number\">1.0</span>.0.1---<span class=\"number\">127.255</span>.255.254\t</span><br><span class=\"line\">\t\t\t\t(<span class=\"number\">1</span>)<span class=\"number\">10</span>.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t(<span class=\"number\">2</span>)<span class=\"number\">127</span>.X.X.X是保留地址，用做循环测试用的。</span><br><span class=\"line\">\t\t\tB类\t<span class=\"number\">128.0</span>.0.1---<span class=\"number\">191.255</span>.255.254\t<span class=\"number\">172.16</span>.0.0---<span class=\"number\">172.31</span>.255.255是私有地址。<span class=\"number\">169.254</span>.X.X是保留地址。</span><br><span class=\"line\">\t\t\tC类\t<span class=\"number\">192.0</span>.0.1---<span class=\"number\">223.255</span>.255.254\t<span class=\"number\">192.168</span>.X.X是私有地址</span><br><span class=\"line\">\t\t\tD类\t<span class=\"number\">224.0</span>.0.1---<span class=\"number\">239.255</span>.255.254 \t</span><br><span class=\"line\">\t\t\tE类\t<span class=\"number\">240.0</span>.0.1---<span class=\"number\">247.255</span>.255.254</span><br><span class=\"line\">\t\td:dos命令</span><br><span class=\"line\">\t\t\tipconfig; telnet; ping</span><br><span class=\"line\">\t\te:InetAddress</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IPDemo</span> </span>&#123;</span><br><span class=\"line\">\t\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">\t\t\t        InetAddress ip = InetAddress.getByName(<span class=\"string\">\"192.168.2.203\"</span>);</span><br><span class=\"line\">\t\t\t        System.out.println(ip.getHostName() + <span class=\"string\">\":\"</span> + ip.getHostAddress());</span><br><span class=\"line\">\t\t\t    &#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\tB:端口</span><br><span class=\"line\">\t\t是应用程序的标识。范围：<span class=\"number\">0</span>-<span class=\"number\">65535</span>。其中<span class=\"number\">0</span>-<span class=\"number\">1024</span>不建议使用。</span><br><span class=\"line\">\tC:协议</span><br><span class=\"line\">\t\tUDP:数据打包,有限制,不连接,效率高,不可靠</span><br><span class=\"line\">\t\tTCP:建立数据通道,无限制,效率低,可靠</span><br><span class=\"line\">(<span class=\"number\">3</span>)Socket机制</span><br><span class=\"line\">\tA:通信两端都应该有Socket对象</span><br><span class=\"line\">\tB:所有的通信都是通过Socket间的IO进行操作的</span><br><span class=\"line\">(<span class=\"number\">4</span>)UDP协议发送和接收数据(掌握 自己补齐代码)</span><br><span class=\"line\">\t发送：</span><br><span class=\"line\">\t\t创建UDP发送端的Socket对象</span><br><span class=\"line\">\t\t创建数据并把数据打包</span><br><span class=\"line\">\t\t发送数据</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">\t接收：</span><br><span class=\"line\">\t\t创建UDP接收端的Socket对象</span><br><span class=\"line\">\t\t创建数据包用于接收数据</span><br><span class=\"line\">\t\t接收数据</span><br><span class=\"line\">\t\t解析数据包</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">(<span class=\"number\">5</span>)TCP协议发送和接收数据(掌握 自己补齐代码)</span><br><span class=\"line\">\t发送：</span><br><span class=\"line\">\t\t创建TCP客户端的Socket对象</span><br><span class=\"line\">\t\t获取输出流，写数据</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t接收：</span><br><span class=\"line\">\t\t创建TCP服务器端的Socket对象</span><br><span class=\"line\">\t\t监听客户端连接</span><br><span class=\"line\">\t\t获取输入流，读取数据</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">(<span class=\"number\">6</span>)案例：</span><br><span class=\"line\">\tA:UDP</span><br><span class=\"line\">\t\ta:最基本的UDP协议发送和接收数据</span><br><span class=\"line\">\t\tb:把发送数据改进为键盘录入</span><br><span class=\"line\">\t\t发送端：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SendSocket</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        <span class=\"comment\">//设置socket发送的端口号，不设置的则为随机端口号</span></span><br><span class=\"line\">\t\t        DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12307</span>);</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span> (Objects.equals(s, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">byte</span>[] bytes = s.getBytes();</span><br><span class=\"line\">\t\t            DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(</span><br><span class=\"line\">\t\t            \tbytes, bytes.length, InetAddress.getByName(<span class=\"string\">\"192.168.2.203\"</span>), <span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t            ds.send(dp);</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t        ds.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t接收端：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveSocket</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t        <span class=\"comment\">//设置socket接收的端口号</span></span><br><span class=\"line\">\t\t\t\t\t        DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t\t\t\t        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t\t\t\t            DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class=\"line\">\t\t\t\t\t            ds.receive(dp);</span><br><span class=\"line\">\t\t\t\t\t            String s = <span class=\"keyword\">new</span> String(dp.getData(), <span class=\"number\">0</span>, dp.getLength());</span><br><span class=\"line\">\t\t\t\t\t            System.out.println(dp.getAddress().getHostAddress() + <span class=\"string\">\":\"</span> + dp.getPort() + <span class=\"string\">\"\\n\"</span> + s);</span><br><span class=\"line\">\t\t\t\t\t        &#125;</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t    &#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\tc:一个简易聊天小程序并用多线程改进</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChatRoom</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t        Thread sendThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t\t            <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t                    DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12307</span>);</span><br><span class=\"line\">\t\t                    BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t                    String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t                    <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t                        <span class=\"keyword\">if</span> (Objects.equals(s, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t                        &#125;</span><br><span class=\"line\">\t\t                        <span class=\"keyword\">byte</span>[] bytes = s.getBytes();</span><br><span class=\"line\">\t\t                        DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(</span><br><span class=\"line\">\t\t                        \tbytes, bytes.length, InetAddress.getByName(<span class=\"string\">\"192.168.2.203\"</span>), <span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t                        ds.send(dp);</span><br><span class=\"line\">\t\t                    &#125;</span><br><span class=\"line\">\t\t                    ds.close();</span><br><span class=\"line\">\t\t                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t                    e.printStackTrace();</span><br><span class=\"line\">\t\t                &#125;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t        &#125;);</span><br><span class=\"line\">\t\t        Thread receiveThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t\t            <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t                    DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t                        DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class=\"line\">\t\t                        ds.receive(dp);</span><br><span class=\"line\">\t\t                        String s = <span class=\"keyword\">new</span> String(dp.getData(), <span class=\"number\">0</span>, dp.getLength());</span><br><span class=\"line\">\t\t                        System.out.println(dp.getAddress().getHostAddress() + <span class=\"string\">\":\"</span> + dp.getPort() + <span class=\"string\">\"\\n\"</span> + s);</span><br><span class=\"line\">\t\t                    &#125;</span><br><span class=\"line\">\t\t                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t                    e.printStackTrace();</span><br><span class=\"line\">\t\t                &#125;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t        &#125;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        sendThread.start();</span><br><span class=\"line\">\t\t        receiveThread.start();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tB:TCP</span><br><span class=\"line\">\t\ta:最基本的TCP协议发送和接收数据</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>, <span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t        </span><br><span class=\"line\">\t\t        bw.write(<span class=\"string\">\"hello tcp\"</span>);</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = server.accept();</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        System.out.println(br.readLine());</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb:服务器给出反馈</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>, <span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.write(<span class=\"string\">\"hello tcp\"</span>);</span><br><span class=\"line\">\t\t        bw.flush();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        <span class=\"comment\">//给服务端发送停止写入的信号，否则服务端会一直阻塞</span></span><br><span class=\"line\">\t\t        client.shutdownOutput();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\">\t\t        System.out.println(br.readLine());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        client.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = server.accept();</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        System.out.println(br.readLine());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class=\"line\">\t\t        bw.write(<span class=\"string\">\"已收到\"</span>);</span><br><span class=\"line\">\t\t        bw.flush();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        server.close();</span><br><span class=\"line\">\t\t        server.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tc:客户端键盘录入服务器控制台输出</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>, <span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span> (Objects.equals(s, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t            bw.write(s);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        <span class=\"comment\">//给服务端发送停止写入的信号，否则服务端会一直阻塞</span></span><br><span class=\"line\">\t\t        client.shutdownOutput();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        client.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = server.accept();</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String client = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((client = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            System.out.println(client);</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        s.close();</span><br><span class=\"line\">\t\t        server.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\td:客户端键盘录入服务器写到文本文件</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>,<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((msg = br.readLine()) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span> (Objects.equals(msg, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t            bw.write(msg);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        s.shutdownOutput();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedReader br1 = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t        System.out.println(br1.readLine());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        br1.close();</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        s.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket ss = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = ss.accept();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"test.txt\"</span>));</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((msg = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            bw.write(msg);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedWriter bw1 = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class=\"line\">\t\t        bw1.write(<span class=\"string\">\"已全部接收！\"</span>);</span><br><span class=\"line\">\t\t        bw1.newLine();</span><br><span class=\"line\">\t\t        bw1.flush();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        bw1.close();</span><br><span class=\"line\">\t\t        s.close();</span><br><span class=\"line\">\t\t        ss.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\te:客户端读取文本文件服务器控制台输出</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"localhost\"</span>, <span class=\"number\">8808</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"1.txt\"</span>)));</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            bw.write(s);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        client.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t\t\tServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8808</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tSocket client = server.accept();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tBufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tString s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(s);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tf:客户端读取文本文件服务器写到文本文件</span><br><span class=\"line\">\t\tg:上传图片</span><br><span class=\"line\">\t\th:多线程改进上传文件</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java反射\"><a href=\"#Java反射\" class=\"headerlink\" title=\"Java反射\"></a>Java反射</h1><h2 id=\"1-反射-理解\"><a href=\"#1-反射-理解\" class=\"headerlink\" title=\"1. 反射(理解)\"></a>1. 反射(理解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)类的加载及类加载器</span><br><span class=\"line\">(<span class=\"number\">2</span>)反射：</span><br><span class=\"line\">\t通过字节码文件对象，去使用成员变量，构造方法，成员方法</span><br><span class=\"line\">(<span class=\"number\">3</span>)反射的使用</span><br><span class=\"line\">\tA:通过反射获取构造方法并使用</span><br><span class=\"line\">\tB:通过反射获取成员变量并使用</span><br><span class=\"line\">\tC:通过反射获取成员方法并使用</span><br><span class=\"line\">(<span class=\"number\">4</span>)反射案例</span><br><span class=\"line\">\tA:通过反射运行配置文件的内容</span><br><span class=\"line\">\tB:通过反射越过泛型检查</span><br><span class=\"line\">\tC:通过反射给任意的一个对象的任意的属性赋值为指定的值</span><br><span class=\"line\">(<span class=\"number\">5</span>)动态代理</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-设计模式\"><a href=\"#2-设计模式\" class=\"headerlink\" title=\"2. 设计模式\"></a>2. 设计模式</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)装饰设计模式</span><br><span class=\"line\">\tBufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tScanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">(<span class=\"number\">2</span>)模版设计模式</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-JDK新特性\"><a href=\"#3-JDK新特性\" class=\"headerlink\" title=\"3. JDK新特性\"></a>3. JDK新特性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)JDK5(掌握)</span><br><span class=\"line\">\t装箱和拆箱</span><br><span class=\"line\">\t泛型</span><br><span class=\"line\">\t增强<span class=\"keyword\">for</span></span><br><span class=\"line\">\t静态导入</span><br><span class=\"line\">\t可变参数</span><br><span class=\"line\">\t枚举</span><br><span class=\"line\">(<span class=\"number\">2</span>)JDK6(了解)</span><br><span class=\"line\">(<span class=\"number\">3</span>)JDK7(理解)</span><br><span class=\"line\">\t二进制的表现形式</span><br><span class=\"line\">\t用_分隔数据</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>语句可是用字符串</span><br><span class=\"line\">\t泛型推断(菱形泛型)</span><br><span class=\"line\">\t多<span class=\"keyword\">catch</span>的使用</span><br><span class=\"line\">\t自动释放资源的用法</span><br><span class=\"line\">(<span class=\"number\">4</span>)JDK8(了解)</span><br><span class=\"line\">\t可以去网上了解资料</span><br></pre></td></tr></table></figure>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags"},"favicon":"/favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"light","social":{"github":"https://github.com/xDaShen","weibo":"http://weibo.com/Aksmos"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":true,"baidu_analytics":null,"google_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":null,"top_img":true,"post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"auto_excerpt":{"enable":true,"length":150},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"addThis":{"enable":false},"disqus":{"enable":false},"since":2013,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<h1 id=\"计算机的基础知识\"><a href=\"#计算机的基础知识\" class=\"headerlink\" title=\"计算机的基础知识\"></a>计算机的基础知识</h1><h2 id=\"1-计算机概述-了解\"><a href=\"#1-计算机概述-了解\" class=\"headerlink\" title=\"1. 计算机概述(了解)\"></a>1. 计算机概述(了解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)计算机</span><br><span class=\"line\">(<span class=\"number\">2</span>)计算机硬件</span><br><span class=\"line\">(<span class=\"number\">3</span>)计算机软件</span><br><span class=\"line\">\t系统软件：window,linux,mac</span><br><span class=\"line\">\t应用软件：qq,yy,飞秋</span><br><span class=\"line\">(<span class=\"number\">4</span>)软件开发(理解)</span><br><span class=\"line\">\t软件：是由数据和指令组成的。(计算器)</span><br><span class=\"line\">\t开发：就是把软件做出来。</span><br><span class=\"line\">\t如何实现软件开发呢?</span><br><span class=\"line\">\t\t就是使用开发工具和计算机语言做出东西来</span><br><span class=\"line\">(<span class=\"number\">5</span>)语言</span><br><span class=\"line\">\t自然语言：人与人交流沟通的</span><br><span class=\"line\">\t计算机语言：人与计算机交流沟通的</span><br><span class=\"line\">\t\tC,C++,C#,Java</span><br><span class=\"line\">(<span class=\"number\">6</span>)人机交换</span><br><span class=\"line\">\t图形界面：操作方便只管</span><br><span class=\"line\">\tDOS命令：需要记忆一些常见的命令</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-键盘功能键的认识和快捷键-掌握\"><a href=\"#2-键盘功能键的认识和快捷键-掌握\" class=\"headerlink\" title=\"2. 键盘功能键的认识和快捷键(掌握)\"></a>2. 键盘功能键的认识和快捷键(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)功能键的认识</span><br><span class=\"line\">\ttab</span><br><span class=\"line\">\tshift</span><br><span class=\"line\">\tctrl</span><br><span class=\"line\">\talt</span><br><span class=\"line\">\twindos</span><br><span class=\"line\">\t空格</span><br><span class=\"line\">\t上下左右</span><br><span class=\"line\">\t回车</span><br><span class=\"line\">\t截图</span><br><span class=\"line\">(<span class=\"number\">2</span>)快捷键</span><br><span class=\"line\">\t全选\tCtrl+A</span><br><span class=\"line\">\t复制\tCtrl+C</span><br><span class=\"line\">\t粘贴\tCtrl+V</span><br><span class=\"line\">\t剪切\tCtrl+X</span><br><span class=\"line\">\t撤销\tCtrl+Z</span><br><span class=\"line\">\t保存\tCtrl+S</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-常见的DOS命令-掌握\"><a href=\"#3-常见的DOS命令-掌握\" class=\"headerlink\" title=\"3. 常见的DOS命令(掌握)\"></a>3. 常见的DOS命令(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)常见的如下</span><br><span class=\"line\">\t盘符的切换</span><br><span class=\"line\">\t\td:回车</span><br><span class=\"line\">\t目录的进入</span><br><span class=\"line\">\t\tcd javase</span><br><span class=\"line\">\t\tcd javase\\day01\\code</span><br><span class=\"line\">\t目录的回退</span><br><span class=\"line\">\t\tcd..</span><br><span class=\"line\">\t\tcd\\</span><br><span class=\"line\">\t清屏</span><br><span class=\"line\">\t\tcls</span><br><span class=\"line\">\t退出</span><br><span class=\"line\">\t\texit</span><br><span class=\"line\">(<span class=\"number\">2</span>)其他的几个(了解)</span><br><span class=\"line\">\t创建目录</span><br><span class=\"line\">\t\tmkdir</span><br><span class=\"line\">\t删除目录</span><br><span class=\"line\">\t\trmdir</span><br><span class=\"line\">\t创建文件</span><br><span class=\"line\">\t\tedit</span><br><span class=\"line\">\t删除文件</span><br><span class=\"line\">\t\tdel</span><br><span class=\"line\">\t显示目录下的内容</span><br><span class=\"line\">\t\tdir</span><br><span class=\"line\">\t删除带内容的目录</span><br><span class=\"line\">\t\trd /s/q</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-Java语言概述-了解\"><a href=\"#4-Java语言概述-了解\" class=\"headerlink\" title=\"4. Java语言概述(了解)\"></a>4. Java语言概述(了解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)Java语言的发展史</span><br><span class=\"line\">\tJava之父</span><br><span class=\"line\">\tJDK1.4.2</span><br><span class=\"line\">\tJDK5</span><br><span class=\"line\">\tJDK7</span><br><span class=\"line\">(<span class=\"number\">2</span>)Java语言的特点</span><br><span class=\"line\">\t有很多小特点，重点有两个开源，跨平台</span><br><span class=\"line\">(<span class=\"number\">3</span>)Java语言是跨平台的，请问是如何保证的呢?(理解)</span><br><span class=\"line\">\t我们是通过翻译的案例讲解的。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t针对不同的操作系统，提供不同的jvm来实现的。</span><br><span class=\"line\">(<span class=\"number\">4</span>)Java语言的平台</span><br><span class=\"line\">\tJavaSE</span><br><span class=\"line\">\tJavaME--Android</span><br><span class=\"line\">\tJavaEE</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-JDK-JRE-JVM的作用及关系-掌握\"><a href=\"#5-JDK-JRE-JVM的作用及关系-掌握\" class=\"headerlink\" title=\"5. JDK,JRE,JVM的作用及关系(掌握)\"></a>5. JDK,JRE,JVM的作用及关系(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)作用</span><br><span class=\"line\">\tJVM：保证Java语言跨平台</span><br><span class=\"line\">\tJRE：Java程序的运行环境</span><br><span class=\"line\">\tJDK：Java程序的开发环境</span><br><span class=\"line\">(<span class=\"number\">2</span>)关系</span><br><span class=\"line\">\tJDK：JRE+工具</span><br><span class=\"line\">\tJRE：JVM+类库</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-JDK的下载-安装-卸载-掌握\"><a href=\"#6-JDK的下载-安装-卸载-掌握\" class=\"headerlink\" title=\"6. JDK的下载,安装,卸载(掌握)\"></a>6. JDK的下载,安装,卸载(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)下载到官网。</span><br><span class=\"line\">\tA:也可以到百度搜索即可。</span><br><span class=\"line\">\tB:我给你。</span><br><span class=\"line\">(<span class=\"number\">2</span>)安装</span><br><span class=\"line\">\tA:绿色版\t解压就可以使用</span><br><span class=\"line\">\tB:安装版\t必须一步一步的安装，一般只要会点击下一步即可</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t注意：</span><br><span class=\"line\">\t\t建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。</span><br><span class=\"line\">(<span class=\"number\">3</span>)卸载</span><br><span class=\"line\">\tA:绿色版\t直接删除文件夹</span><br><span class=\"line\">\tB:安装版\t</span><br><span class=\"line\">\t\ta:控制面板 -- 添加删除程序</span><br><span class=\"line\">\t\tb:通过专业的软件卸载工具。(比如<span class=\"number\">360</span>的软件管家卸载)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-第一个程序：HelloWorld案例-掌握\"><a href=\"#7-第一个程序：HelloWorld案例-掌握\" class=\"headerlink\" title=\"7. 第一个程序：HelloWorld案例(掌握)\"></a>7. 第一个程序：HelloWorld案例(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"HelloWorld\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">1</span>)程序解释：</span><br><span class=\"line\">\tA:Java程序的最基本单位是类，所以我们要定义一个类。</span><br><span class=\"line\">\t\t格式：<span class=\"class\"><span class=\"keyword\">class</span> 类名</span></span><br><span class=\"line\"><span class=\"class\">\t\t举例：<span class=\"title\">class</span> <span class=\"title\">HelloWorld</span></span></span><br><span class=\"line\">\tB:在类中写内容的时候，用大括号括起来。</span><br><span class=\"line\">\tC:Java程序要想执行，必须有main方法。</span><br><span class=\"line\">\t\t格式：<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">\tD:要指向哪些东西呢，也用大括号括起来。</span></span><br><span class=\"line\"><span class=\"function\">\tE:你要做什么呢?今天我们仅仅做了一个简单的输出</span></span><br><span class=\"line\"><span class=\"function\">\t\t格式：System.out.<span class=\"title\">println</span><span class=\"params\">(<span class=\"string\">\"HelloWorld\"</span>)</span></span>;</span><br><span class=\"line\">\t\t注意：<span class=\"string\">\"\"</span>里面的内容是可以改动的。</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"number\">2</span>)Java程序的开发执行流程：</span><br><span class=\"line\">\tA:编写java源程序(.java)</span><br><span class=\"line\">\tB:通过javac命令编译生成.class文件</span><br><span class=\"line\">\tC:通过java命令运行.class文件</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-常见的问题-掌握\"><a href=\"#8-常见的问题-掌握\" class=\"headerlink\" title=\"8. 常见的问题(掌握)\"></a>8. 常见的问题(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)扩展名被隐藏</span><br><span class=\"line\">\t如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾</span><br><span class=\"line\">(<span class=\"number\">2</span>)我要求文件名称和类名一致。</span><br><span class=\"line\">\t实际上不这样做也是可以的。</span><br><span class=\"line\">\t但是，注意：</span><br><span class=\"line\">\t\tjavac后面跟的是文件名+扩展名</span><br><span class=\"line\">\t\tjava后面跟的类名不带扩展名</span><br><span class=\"line\">(<span class=\"number\">3</span>)Java语言严格区分大小写，请注意。</span><br><span class=\"line\">\t 还有就是单词不要写错了。</span><br><span class=\"line\">(<span class=\"number\">4</span>)见到非法字符: \\<span class=\"number\">65307</span>肯定是中文问题。</span><br><span class=\"line\">\t我们写程序要求标点符号必须全部是英文状态。</span><br><span class=\"line\">(<span class=\"number\">5</span>)括号的配对问题。</span><br><span class=\"line\">\t一般来说，括号都是成对出现的。</span><br><span class=\"line\">(<span class=\"number\">6</span>)遇到</span><br><span class=\"line\">\t在类 HelloWorld 中找不到主方法, 请将主方法定义为</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">\t肯定是主方法的格式问题。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-path环境变量-掌握\"><a href=\"#9-path环境变量-掌握\" class=\"headerlink\" title=\"9. path环境变量(掌握)\"></a>9. path环境变量(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)path环境变量的作用</span><br><span class=\"line\">\t保证javac命令可以在任意目录下运行。</span><br><span class=\"line\">\t同理可以配置qq等</span><br><span class=\"line\">(<span class=\"number\">2</span>)path配置的两种方案：</span><br><span class=\"line\">\tA:方案<span class=\"number\">1</span>(了解)</span><br><span class=\"line\">\tB:方案<span class=\"number\">2</span></span><br><span class=\"line\">\t\t找到环境变量的位置，在系统变量里面</span><br><span class=\"line\">\t\t新建：</span><br><span class=\"line\">\t\t\t变量名：JAVA_HOME</span><br><span class=\"line\">\t\t\t变量值：D:\\develop\\Java\\jdk1.7.0_60</span><br><span class=\"line\">\t\t修改：</span><br><span class=\"line\">\t\t\t变量名：Path</span><br><span class=\"line\">\t\t\t变量值：%JAVA_HOME%\\bin;以前的内容</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-classpath环境变量-理解\"><a href=\"#10-classpath环境变量-理解\" class=\"headerlink\" title=\"10. classpath环境变量(理解)\"></a>10. classpath环境变量(理解)</h2><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)classpath环境变量的作用</span><br><span class=\"line\">\t保证<span class=\"class\"><span class=\"keyword\">class</span>文件可以在任意目录下运行</span></span><br><span class=\"line\"><span class=\"class\">(2)<span class=\"title\">classpath</span>环境变量的配置</span></span><br><span class=\"line\"><span class=\"class\">\t找到环境变量的位置，在系统变量里面</span></span><br><span class=\"line\"><span class=\"class\">\t新建：</span></span><br><span class=\"line\"><span class=\"class\">\t\t变量名：<span class=\"title\">classpath</span></span></span><br><span class=\"line\">\t\t变量值：E:\\JavaSE\\day01\\code\\HelloWorld案例</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java语言基础\"><a href=\"#Java语言基础\" class=\"headerlink\" title=\"Java语言基础\"></a>Java语言基础</h1><h2 id=\"1-关键字-掌握\"><a href=\"#1-关键字-掌握\" class=\"headerlink\" title=\"1. 关键字(掌握)\"></a>1. 关键字(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)被Java语言赋予特定含义的单词</span><br><span class=\"line\">(<span class=\"number\">2</span>)特点：</span><br><span class=\"line\">\t全部小写。</span><br><span class=\"line\">(<span class=\"number\">3</span>)注意事项：</span><br><span class=\"line\">\tA:goto和<span class=\"keyword\">const</span>作为保留字存在。</span><br><span class=\"line\">\tB:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-标识符-掌握\"><a href=\"#2-标识符-掌握\" class=\"headerlink\" title=\"2. 标识符(掌握)\"></a>2. 标识符(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)就是给类，接口，方法，变量等起名字的字符序列</span><br><span class=\"line\">(<span class=\"number\">2</span>)组成规则：</span><br><span class=\"line\">\tA:英文大小写字母</span><br><span class=\"line\">\tB:数字</span><br><span class=\"line\">\tC:$和_</span><br><span class=\"line\">(<span class=\"number\">3</span>)注意事项：</span><br><span class=\"line\">\tA:不能以数字开头</span><br><span class=\"line\">\tB:不能是java中的关键字</span><br><span class=\"line\">\tC:区分大小写</span><br><span class=\"line\">(<span class=\"number\">4</span>)常见的命名规则(见名知意)</span><br><span class=\"line\">\tA:包\t全部小写</span><br><span class=\"line\">\t\t单级包：小写</span><br><span class=\"line\">\t\t\t举例：liuyi,com</span><br><span class=\"line\">\t\t多级包：小写，并用.隔开</span><br><span class=\"line\">\t\t\t举例：cn.itcast,com.baidu\t\t\t\t</span><br><span class=\"line\">\tB:类或者接口</span><br><span class=\"line\">\t\t一个单词：首字母大写</span><br><span class=\"line\">\t\t\t举例：Student,Demo</span><br><span class=\"line\">\t\t多个单词：每个单词首字母大写</span><br><span class=\"line\">\t\t\t举例：HelloWorld,StudentName</span><br><span class=\"line\">\tC:方法或者变量</span><br><span class=\"line\">\t\t一个单词：首字母小写</span><br><span class=\"line\">\t\t\t举例：name,main</span><br><span class=\"line\">\t\t多个单词：从第二个单词开始，每个单词首字母大写</span><br><span class=\"line\">\t\t\t举例：studentAge,showAllNames()</span><br><span class=\"line\">\tD:常量</span><br><span class=\"line\">\t\t全部大写</span><br><span class=\"line\">\t\t一个单词：大写</span><br><span class=\"line\">\t\t\t举例：PI</span><br><span class=\"line\">\t\t多个单词：大写，并用_隔开</span><br><span class=\"line\">\t\t\t举例：STUDENT_MAX_AGE</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-注释-掌握\"><a href=\"#3-注释-掌握\" class=\"headerlink\" title=\"3. 注释(掌握)\"></a>3. 注释(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)就是对程序进行解释说明的文字</span><br><span class=\"line\">(<span class=\"number\">2</span>)分类：</span><br><span class=\"line\">\tA:单行注释\t<span class=\"comment\">//</span></span><br><span class=\"line\">\tB:多行注释\t<span class=\"comment\">/**/</span></span><br><span class=\"line\"><span class=\"comment\">\tC:文档注释(后面讲) /** */</span></span><br><span class=\"line\">(<span class=\"number\">3</span>)把HelloWorld案例写了一个带注释的版本。</span><br><span class=\"line\">\t后面我们要写一个程序的过程。</span><br><span class=\"line\">\t需求：</span><br><span class=\"line\">\t分析：</span><br><span class=\"line\">\t实现：</span><br><span class=\"line\">\t代码体现：</span><br><span class=\"line\">(<span class=\"number\">4</span>)注释的作用</span><br><span class=\"line\">\tA:解释说明程序，提高了代码的阅读性。</span><br><span class=\"line\">\tB:可以帮助我们调试程序。</span><br><span class=\"line\">\t\t后面我们会讲解一个更高端的一个调试工具</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-常量-掌握\"><a href=\"#4-常量-掌握\" class=\"headerlink\" title=\"4. 常量(掌握)\"></a>4. 常量(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)在程序执行的过程中，其值不发生改变的量</span><br><span class=\"line\">(<span class=\"number\">2</span>)分类：</span><br><span class=\"line\">\tA:字面值常量</span><br><span class=\"line\">\tB:自定义常量(后面讲)</span><br><span class=\"line\">(<span class=\"number\">3</span>)字面值常量</span><br><span class=\"line\">\tA:字符串常量 <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">\tB:整数常量\t<span class=\"number\">12</span>,<span class=\"number\">23</span></span><br><span class=\"line\">\tC:小数常量\t<span class=\"number\">12.345</span></span><br><span class=\"line\">\tD:字符常量\t<span class=\"string\">'a'</span>,<span class=\"string\">'A'</span>,<span class=\"string\">'0'</span></span><br><span class=\"line\">\tE:布尔常量\t<span class=\"keyword\">true</span>,<span class=\"keyword\">false</span></span><br><span class=\"line\">\tF:空常量\t<span class=\"keyword\">null</span>(后面讲)</span><br><span class=\"line\">(<span class=\"number\">4</span>)在Java中针对整数常量提供了四种表现形式</span><br><span class=\"line\">\tA:二进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>组成。以<span class=\"number\">0</span>b开头。</span><br><span class=\"line\">\tB:八进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>，...<span class=\"number\">7</span>组成。以<span class=\"number\">0</span>开头。</span><br><span class=\"line\">\tC:十进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>，...<span class=\"number\">9</span>组成。整数默认是十进制。</span><br><span class=\"line\">\tD:十六进制\t由<span class=\"number\">0</span>，<span class=\"number\">1</span>，...<span class=\"number\">9</span>,a,b,c,d,e,f(大小写均可)组成。以<span class=\"number\">0</span>x开头。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-进制转换-了解\"><a href=\"#5-进制转换-了解\" class=\"headerlink\" title=\"5. 进制转换(了解)\"></a>5. 进制转换(了解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)其他进制到十进制</span><br><span class=\"line\">\t系数：就是每一个位上的数值</span><br><span class=\"line\">\t基数：x进制的基数就是x</span><br><span class=\"line\">\t权：对每一个位上的数据，从右，并且从<span class=\"number\">0</span>开始编号，对应的编号就是该数据的权。</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t结果：系数*基数^权次幂之和。</span><br><span class=\"line\">(<span class=\"number\">2</span>)十进制到其他进制</span><br><span class=\"line\">\t除基取余，直到商为<span class=\"number\">0</span>，余数反转。</span><br><span class=\"line\">(<span class=\"number\">3</span>)进制转换的快速转换法</span><br><span class=\"line\">\tA:十进制和二进制间的转换</span><br><span class=\"line\">\t\t<span class=\"number\">8421</span>码。</span><br><span class=\"line\">\tB:二进制到八进制，十六进制的转换</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-变量-掌握\"><a href=\"#6-变量-掌握\" class=\"headerlink\" title=\"6. 变量(掌握)\"></a>6. 变量(掌握)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)在程序的执行过程中，其值在某个范围内可以发生改变的量</span><br><span class=\"line\">(<span class=\"number\">2</span>)变量的定义格式：</span><br><span class=\"line\">\tA:数据类型 变量名 = 初始化值;</span><br><span class=\"line\">\tB:数据类型 变量名;</span><br><span class=\"line\">\t  变量名 = 初始化值;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-数据类型-掌握\"><a href=\"#7-数据类型-掌握\" class=\"headerlink\" title=\"7. 数据类型(掌握)\"></a>7. 数据类型(掌握)</h2><pre><code>(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。\n(2)分类：\n    A:基本数据类型：4类8种\n    B:引用数据类型：类，接口，数组。\n(3)基本数据类型\n    A:整数            占用字节数\n        byte            1\n        short            2\n        int             4\n        long            8\n    B:浮点数\n        float            4\n        double            8\n    C:字符\n        char            2\n    D:布尔\n        boolean            1\n\n    注意：\n        整数默认是int类型，浮点数默认是double。\n\n        长整数要加L或者l。\n        单精度的浮点数要加F或者f。</code></pre><h2 id=\"8-数据类型转换-掌握\"><a href=\"#8-数据类型转换-掌握\" class=\"headerlink\" title=\"8. 数据类型转换(掌握)\"></a>8. 数据类型转换(掌握)</h2><pre><code>(1)boolean类型不参与转换\n(2)默认转换\n    A:从小到大\n    B:byte,short,char -- int -- long -- float -- double\n    C:byte,short,char之间不相互转换，直接转成int类型参与运算。\n(3)强制转换\n    A:从大到小\n    B:可能会有精度的损失，一般不建议这样使用。\n    C:格式：\n        目标数据类型 变量名 = (目标数据类型) (被转换的数据);\n(4)思考题和面试题：\n    A:下面两种方式有区别吗?\n\n        float f1 = 12.345f;//本来就是float\n        float f2 = (float)12.345;//double转float\n\n    B:下面的程序有问题吗，如果有，在哪里呢?\n\n        byte b1 = 3;\n        byte b2 = 4;\n        byte b3 = b1 + b2;//b1+b2是int,需要强转(byte)(b1 + b2)\n        byte b4 = 3 + 4;//会先判断3+4的值是否在byte区间内,区间内就没问题\n\n    C:下面的操作结果是什么呢?\n        byte b = (byte)130;//-126\n\n    D:字符参与运算\n        是查找ASCII里面的值\n        &apos;a&apos;        97\n        &apos;A&apos;        65\n        &apos;0&apos;        48\n\n        System.out.println(&apos;a&apos;);//a\n        System.out.println(&apos;a&apos; + 1);//98\n\n    E:字符串参与运算\n        这里其实是字符串的连接        \n\n        System.out.println(&quot;hello&quot;+&apos;a&apos;+1);//helloa1\n        System.out.println(&apos;a&apos;+1+&quot;hello&quot;);//98hello\n        System.out.println(&quot;5+5=&quot;+5+5);//5+5=55\n        System.out.println(5+5+&quot;=5+5&quot;);//10=5+5</code></pre><h2 id=\"1-运算符-掌握\"><a href=\"#1-运算符-掌握\" class=\"headerlink\" title=\"1. 运算符(掌握)\"></a>1. 运算符(掌握)</h2><pre><code>(1)算术运算符\n    A:+,-,*,/,%,++,--\n    B:+的用法\n        a:加法\n        b:正号\n        c:字符串连接符\n    C:/和%的区别\n        数据做除法操作的时候，/取得是商，%取得是余数\n    D:++和--的用法\n        a:他们的作用是自增或者自减\n        b:使用\n            **单独使用\n                放在操作数据的前面和后面效果一样。\n                a++或者++a效果一样。\n            **参与操作使用\n                放在操作数的前面：先自增或者自减，再参与操作\n                    int a = 10;\n                    int b = ++a;\n                放在操作数的后面：先参与操作，再自增或者自减\n                    int a = 10;\n                    int b = a++;\n(2)赋值运算符\n    A:=,+=,-=,*=,/=,%=等\n    B:=叫做赋值运算符，也是最基本的赋值运算符\n        int x = 10; 把10赋值给int类型的变量x。\n    C:扩展的赋值运算符的特点\n        隐含了自动强制转换。\n\n面试题：\n\nshort s = 1;\ns = s + 1;//有问题,需要强转(short)(s + 1)\n\nshort s = 1;\ns += 1;//没问题,隐含了自动强制转换\n\n请问上面的代码哪个有问题?\n\n(3)比较运算符\n    A:==,!=,&gt;,&gt;=,&lt;,&lt;=\n    B:无论运算符两端简单还是复杂最终结果是boolean类型。\n    C:千万不要把==写成了=\n(4)逻辑运算符\n    A:&amp;,|,^,!,&amp;&amp;,||\n    B:逻辑运算符用于连接boolean类型的式子\n    C:结论\n        &amp;:有false则false\n        |:有true则true\n        ^:相同则false，不同则true。\n            情侣关系。\n        !:非true则false，非false则true\n\n        &amp;&amp;:结果和&amp;是一样的，只不过有短路效果。左边是false，右边不执行。\n        ||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。\n(5)位运算符(了解)\n    A:^的特殊用法\n        一个数据针对另一个数据位异或两次，该数不变\n    B:面试题\n        a:请实现两个变量的交换\n            **采用第三方变量\n            **用位异或运算符\n                左边a,b,a\n                右边a^b\n        b:请用最有效率的方式计算出2乘以8的结果\n            2&lt;&lt;3\n(6)三元运算符\n    A:格式\n        比较表达式?表达式1:表达式2;\n    B:执行流程：\n        首先计算比较表达式的值，看是true还是false。\n        如果是true，表达式1就是结果。\n        如果是false，表达式2就是结果。\n    C:案例：\n        a:比较两个数据是否相等\n            System.out.println(a == b ? true : false);\n        b:获取两个数据中的最大值\n            System.out.println(a &gt; b ? a : b);\n        c:获取三个数据中的最大值\n            System.out.println((a&gt;b?a:b)&gt;c?(a&gt;b?a:b):c);</code></pre><h2 id=\"2-键盘录入-掌握\"><a href=\"#2-键盘录入-掌握\" class=\"headerlink\" title=\"2. 键盘录入(掌握)\"></a>2. 键盘录入(掌握)</h2><pre><code>(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。\n(2)如何实现呢?目前就记住\n    A:导包\n        import java.util.Scanner;\n        位置：在class的上边\n    B:创建对象\n        Scanner sc = new Scanner(System.in);\n    C:获取数据\n        int x = sc.nextInt();\n(3)把三元运算符的案例加入键盘录入改进。\n    Scanner sc = new Scanner(System.in);\n    int a = sc.nextInt();\n    int b = sc.nextInt();\n    System.out.println(a &gt; b ? a : b);</code></pre><h2 id=\"3-流程控制语句\"><a href=\"#3-流程控制语句\" class=\"headerlink\" title=\"3. 流程控制语句\"></a>3. 流程控制语句</h2><pre><code>(1)顺序结构 从上往下，依次执行\n(2)选择结构    按照不同的选择，执行不同的代码\n(3)循环结构 做一些重复的代码</code></pre><h2 id=\"4-if语句-掌握\"><a href=\"#4-if语句-掌握\" class=\"headerlink\" title=\"4. if语句(掌握)\"></a>4. if语句(掌握)</h2><pre><code>(1)三种格式\n    A:格式1\n        if(比较表达式) {\n            语句体;\n        }\n\n        执行流程：\n            判断比较表达式的值，看是true还是false\n            如果是true，就执行语句体\n            如果是false，就不执行语句体\n\n    B:格式2\n        if(比较表达式) {\n            语句体1;\n        }else {\n            语句体2;\n        }\n\n        执行流程：\n            判断比较表达式的值，看是true还是false\n            如果是true，就执行语句体1\n            如果是false，就执行语句体2\n\n    C:格式3\n        if(比较表达式1) {\n            语句体1;\n        }else if(比较表达式2){\n            语句体2;\n        }\n        ...\n        else {\n            语句体n+1;\n        }\n\n        执行流程：\n            判断比较表达式1的值，看是true还是false\n            如果是true，就执行语句体1\n            如果是false，就继续判断比较表达式2的值，看是true还是false\n            如果是true，就执行语句体2\n            如果是false，就继续判断比较表达式3的值，看是true还是false\n            ...\n            如果都不满足，就执行语句体n+1\n(2)注意事项\n    A:比较表达式无论简单还是复杂，结果是boolean类型\n    B:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。\n        建议：永远不要省略。\n    C:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。\n    D:else后面如果没有if，是不会出现比较表达式的。\n    E:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。\n(3)案例：\n    A:比较两个数是否相等\n\n        if (a == b) {\n            System.out.println(&quot;a == b&quot;);\n        }\n\n    B:获取两个数中的最大值\n\n        if (a &gt; b) {\n            System.out.println(a);\n        } else if (a &lt; b) {\n            System.out.println(b);\n        }\n\n    C:获取三个数中的最大值(if语句的嵌套)\n        if (a &gt; b) {\n            if (a &gt; c) {\n                System.out.println(a);\n            } else if (c &gt; a) {\n                System.out.println(c);\n            } else if (b &gt; a) {\n                if (b &gt; c) {\n                    System.out.println(b);\n                } else if (c &gt; b) {\n                    System.out.println(c);\n                }\n            }\n\n    D:根据成绩输出对应的等级\n        if (score &gt; 0 &amp;&amp; score &lt; 60) {\n            System.out.println(&quot;不及格&quot;);\n        } else if (score &gt;= 60 &amp;&amp; score &lt; 90) {\n            System.out.println(&quot;合格&quot;);\n        } else if (score &gt;= 90 &amp;&amp; score &lt;= 100) {\n            System.out.println(&quot;优秀&quot;);\n        }\n    E:根据月份，输出对应的季节\n    F:根据x计算对应y的值并输出\n(4)三元运算符和if语句第二种格式的关系\n    所有的三元运算符能够实现的，if语句的第二种格式都能实现。\n    反之不成立。\n\n    如果if语句第二种格式控制的语句体是输出语句，就不可以。\n    因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。</code></pre><h2 id=\"1-switch语句-掌握\"><a href=\"#1-switch语句-掌握\" class=\"headerlink\" title=\"1. switch语句(掌握)\"></a>1. switch语句(掌握)</h2><pre><code>(1)格式：\n    switch(表达式) {\n        case 值1:\n            语句体1;\n            break;\n        case 值2:\n            语句体2;\n            break;\n        ...\n        default:\n            语句体n+1;\n            break;\n    }\n\n    格式解释说明：\n        switch:说明这是switch语句。\n        表达式:可以是byte,short,int,char\n            JDK5以后可以是枚举\n            JDK7以后可以是字符串\n        case:后面的值就是要和表达式进行比较的值\n        break:表示程序到这里中断，跳出switch语句\n        default:如果所有的情况都不匹配,就执行这里,相当于if语句中的else\n(2)面试题\n    switch语句的表达式可以是byte吗?可以是long吗?可以是String吗?\n        可以,不可以,JDK7以后可以\n(3)执行流程:\n    A:首先计算表达式的值\n    B:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。\n    C:如果没有匹配，就执行default的语句体n+1。\n(4)注意事项:\n    A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的\n    B:default可以省略吗?\n        可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。\n        特殊情况：\n            case就可以把值固定。\n            A,B,C,D\n    C:break可以省略吗?\n        可以省略，但是结果可能不是我们想要的。\n        会出现一个现象：case穿透。\n        最终我们建议不要省略\n    D:default一定要在最后吗?\n        不是，可以在任意位置。但是建议在最后。\n    E:switch语句的结束条件\n        a:遇到break就结束了\n        b:执行到末尾就结束了\n(5)案例：\n    A:键盘录入一个数字(1-7),输出对应的星期几。\n        Scanner sc = new Scanner(System.in);\n\n            switch (sc.nextInt()) {\n            case ## 1. \n                System.out.println(&quot;Monday&quot;);\n                break;\n            case ## 2. \n                System.out.println(&quot;Tuesday&quot;);\n                break;\n            case ## 3. \n                System.out.println(&quot;Wednesday&quot;);\n                break;\n            case ## 4. \n                System.out.println(&quot;Thursday&quot;);\n                break;\n            case ## 5. \n                System.out.println(&quot;Friday&quot;);\n                break;\n            case ## 6. \n                System.out.println(&quot;Saturday&quot;);\n                break;\n            case ## 7. \n                System.out.println(&quot;Sunday&quot;);\n                break;\n            default:\n                System.out.println(&quot;wrong&quot;);\n        }\n    B:单项选择题\n    C:键盘录入一个字符串的问题\n        String s = sc.nextLine();\n    D:根据给定的月份,输出对应的季节\n(6)if语句和switch语句各自的场景\n    A:if\n        针对boolean类型的判断\n        针对一个范围的判断\n        针对几个常量的判断\n    B:switch\n        针对几个常量的判断</code></pre><h2 id=\"2-循环语句-掌握\"><a href=\"#2-循环语句-掌握\" class=\"headerlink\" title=\"2. 循环语句(掌握)\"></a>2. 循环语句(掌握)</h2><pre><code>(1)有三种:for,while,do...while\n(2)for循环语句\n    A:格式\n        for(初始化语句;判断条件语句;控制条件语句){\n            循环体语句;\n        }\n\n        执行流程：\n            a:执行初始化语句\n            b:执行判断条件语句\n                如果这里是true，就继续\n                如果这里是false，循环就结束\n            c:执行循环体语句\n            d:执行控制条件语句\n            e:回到b\n    B:注意事项\n        a:判断条件语句无论简单还是复杂，结果是boolean类型\n        b:循环体语句如果是一条，可以省略大括号，但是不建议\n        c:有分号就没有左大括号，有左大括号就没有分号\n    C:案例\n        a:输出10次HelloWorld\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(&quot;HelloWorld&quot;);\n            }\n        b:输出1-10的数据\n            for (int i = 1; i &lt; 11; i++) {\n                System.out.println(i);\n            }\n        c:输出10-1的数据\n            for (int i = 10; i &gt; 0; i--) {\n                System.out.println(i);\n            }\n        d:求1-10的和\n            int sum = 0;\n            for (int i = 1; i &lt; 11; i++) {\n                sum += i;\n            }\n            System.out.println(sum);\n        e:求1-100的和,求1-100的偶数和,求1-100的奇数和\n            int sum = 0;\n            int oddSum = 0;\n            int evenSum = 0;\n\n            for (int i = 1; i &lt; 101; i++) {\n                sum += i;\n            }\n            System.out.println(&quot;sum:&quot; + sum);\n\n            for (int i = 1; i &lt; 101; i+=2) {\n                oddSum += i;\n            }\n            System.out.println(&quot;oddSum:&quot; + oddSum);\n\n            for (int i = 2; i &lt; 101; i+=2) {\n                evenSum += i;\n            }\n            System.out.println(&quot;evenSum:&quot; + evenSum);\n        f:求5的阶乘\n            int sum = 1;\n            for (int i = 5; i &gt; 0; i--) {\n                sum *= i;\n            }\n            System.out.println(sum);\n        g:在控制台打印水仙花数(个位,十位,百位的立方和等于该数)\n            for (int i = 100; i &lt; 1000; i++) {\n                int ge = i % 10;\n                int shi = i / 10 % 10;\n                int bai = i / 100 % 10;        \n                if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n                    System.out.println(i);\n                }\n            }\n        h:统计水仙花个数\n            int flag = 0;\n            for (int i = 100; i &lt; 1000; i++) {\n                int ge = i % 10;\n                int shi = i / 10 % 10;\n                int bai = i / 100 % 10;\n                if (Math.pow(ge, 3) + Math.pow(shi, 3) + Math.pow(bai, 3) == i) {\n                    flag++;\n                }\n            }\n            System.out.println(flag);\n        i:改进版的回文数\n            一个五位数\n            个位 = 万位\n            十位 = 千位\n            个位 + 十位 + 千位 + 万位 = 百位\n            for (int i = 10000; i &lt; 100000; i++) {\n                int ge = i % 10;\n                int shi = i / 10 %10;\n                int bai = i / 100 % 10;\n                int qian = i /1000 % 10;\n                int wan = i / 10000 % 10;\n                if (ge == wan &amp;&amp; shi == qian &amp;&amp; (ge + shi + qian + wan) == bai) {\n                    System.out.println(i);\n                }\n            }\n        j:统计1-1000之间同时满足如下条件的数据有多少个\n            x%3==2\n            x%5==3\n            x%7==2\n            int flag = 0;\n            for (int i = 1; i &lt; 1001; i++) {\n                if (i % 3 == 2 &amp;&amp; i % 5 == 3 &amp;&amp; i % 7 == 2) {\n                    flag++;\n                }\n            }\n            System.out.println(flag);\n(3)while循环\n    A:基本格式\n        while(判断条件语句) {\n            循环体语句;\n        }\n\n        扩展格式：\n        初始化语句;\n        while(判断条件语句){\n            循环体语句;\n            控制条件语句;\n        }\n\n        通过查看这个格式，我们就知道while循环可以和for循环等价转换。\n    B:while的练习\n        把for语句的练习用while改进\n    C:for和while的区别\n        a:使用上的区别\n            for语句的那个控制条件变量,在循环结束后不能在使用了。\n            而while的可以继续使用。\n        b:理解上的区别\n            for适合于一个范围的判断\n            while适合次数不明确的\n                举例:吃葡萄\n    D:案例：\n        a:珠穆朗玛峰问题\n        b:小芳存钱问题(break以后才能做)\n(4)do...while循环\n    A:基本格式\n        do {\n            循环体语句;\n        }while(判断条件语句);\n\n        扩展格式：\n        初始化语句;\n        do {\n            循环体语句;\n            控制条件语句;\n        }while(判断条件语句);\n\n        通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。\n    B:三种循环的区别\n        a:do...while循环至少执行一次循环体\n        b:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体\n(5)循环使用的注意事项(死循环)\n    A:一定要注意修改控制条件,否则容易出现死循环。\n    B:最简单的死循环格式\n        a:while(true){...}\n\n        b:for(;;){}</code></pre><h2 id=\"3-控制跳转语句-掌握\"><a href=\"#3-控制跳转语句-掌握\" class=\"headerlink\" title=\"3. 控制跳转语句(掌握)\"></a>3. 控制跳转语句(掌握)</h2><pre><code>(1)break:中断的意思\n    A:用在循环和switch语句中，离开此应用场景无意义。\n    B:作用\n        a:跳出单层循环\n        b:跳出多层循环，需要标签语句的配合\n(2)continue:继续\n    A:用在循环中，离开此应用场景无意义。\n    B:作用\n        a:跳出单层循环的一次，可以继续下一次\n    C:填空题\n        for(int x=1; x&lt;=10; x++) {\n            if(x%3 == 0) {\n                //补齐代码\n            }\n            System.out.println(&quot;Java基础班&quot;);\n        }\n        如何让控制台输出2次：Java基础班\n            break;\n        如何让控制台输出7次：Java基础班\n            continue;\n        如何让控制台输出13次：Java基础班\n            System.out.println(&quot;Java基础班&quot;);\n(3)return:返回\n    A:用于结束方法的，后面还会在继续讲解和使用。\n    B:一旦遇到return,程序就不会在继续往后执行。</code></pre><h2 id=\"1-方法-掌握\"><a href=\"#1-方法-掌握\" class=\"headerlink\" title=\"1. 方法(掌握)\"></a>1. 方法(掌握)</h2><pre><code>(1)方法：就是完成特定功能的代码块。\n    注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。\n(2)格式：\n    修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {\n        方法体语句;\n        return 返回值;\n    }\n\n\n    修饰符：目前就用 public static。后面再详细讲解其他修饰符\n    返回值类型：就是功能结果的数据类型\n    方法名：就是起了一个名字，方便我们调用该方法。\n    参数类型：就是参数的数据类型\n    参数名：就是变量\n    参数分类：\n        实参：实际参与运算的数据\n        形参：方法上定义的，用于接收实际参数的变量\n    方法体语句：就是完成功能的代码块\n    return：结束方法\n    返回值：就是功能的结果，由return带给调用者。\n(3)两个明确：\n    返回值类型：结果的数据类型\n    参数列表：参数的个数及对应的数据类型\n(4)方法调用\n    A:有明确返回值的方法\n        a:单独调用，没有意义\n        b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。\n        c:赋值调用，推荐方案\n    B:void类型修饰的方法\n        a:单独调用\n(5)案例：\n    A:求和方案\n        public static void sum(int a, int b) {\n            System.out.println(&quot;a + b = &quot; + (a + b));\n        }\n    B:获取两个数中的较大值\n        public static void max(int a, int b) {\n            if (a &gt; b) {\n                System.out.println(a);\n            } else if (b &gt; a) {\n                System.out.println(b);\n            }\n        }\n    C:比较两个数据是否相同\n        public static void isEquals(int a, int b) {\n            if (a == b) {\n                System.out.println(&quot;a == b&quot;);\n            }\n        }\n    D:获取三个数中的最大值\n        public static void max(int a, int b, int c) {\n            if (a &gt; b) {\n                if (a &gt; c) {\n                    System.out.println(a);\n                } else if (c &gt; a) {\n                    System.out.println(c);\n                }\n            } else if (b &gt; a) {\n                if (b &gt; c) {\n                    System.out.println(b);\n                } else if (c &gt; b) {\n                    System.out.println(c);\n                }\n            }\n        }\n    E:输出m行n列的星形\n        public static void printStar(int row, int column) {\n            for (int m = 0; m &lt; row; m++) {\n                String star = &quot;&quot;;\n                for (int n = 0; n &lt; column; n++) {\n                    star += &quot;*&quot;;\n                }\n                System.out.println(star);\n            }\n            System.out.println(&quot;--------------&quot;);\n            for (int m = 0; m &lt; row; m++) {\n                String star = &quot;&quot;;\n                for (int n = 0; n &lt;= m; n++) {\n                    star += &quot;*&quot;;\n                }\n                System.out.println(star);\n            }\n            System.out.println(&quot;---------------&quot;);\n            for (int m = row; m &gt; 0; m--) {\n                String star = &quot;&quot;;\n                for (int n = 0; n &lt; m; n++) {\n                    star += &quot;*&quot;;\n                }\n                System.out.println(star);\n            }\n        }\n    F:输出nn乘法表\n        public static void chengfabiao(int n) {\n            for (int i = 1; i &lt;= n; i++) {\n                for (int j = 1; j &lt;= i; j++) {\n                    System.out.print(j + &quot; * &quot; + i + &quot; = &quot; + (j * i) + &quot;\\t&quot;);\n                }\n                System.out.println();\n            }\n        }\n(6)方法的注意事项\n    A:方法不调用不执行\n    B:方法之间是平级关系，不能嵌套定义\n    C:方法定义的时候，参数是用，隔开的\n    D:方法在调用的时候，不用在传递数据类型\n    E:如果方法有明确的返回值类型，就必须有return语句返回。\n(7)方法重载\n    在同一个类中，方法名相同，参数列表不同。与返回值无关。\n\n    参数列表不同：\n        参数的个数不同。\n        参数的对应的数据类型不同。\n(8)方法重载案例\n    不同的类型的多个同名方法的比较。</code></pre><h2 id=\"2-数组-掌握\"><a href=\"#2-数组-掌握\" class=\"headerlink\" title=\"2. 数组(掌握)\"></a>2. 数组(掌握)</h2><pre><code>(1)数组：存储同一种数据类型的多个元素的容器。\n(2)特点：每一个元素都有编号，从0开始，最大编号是长度-1。\n         编号的专业叫法：索引\n(3)定义格式\n    A:数据类型[] 数组名;\n    B:数据类型 数组名[];\n\n    推荐是用A方式，B方法就忘了吧。\n    但是要能看懂\n(4)数组的初始化\n    A:动态初始化\n        只给长度，系统给出默认值\n\n        举例：int[] arr = new int[3];\n    B:静态初始化\n        给出值，系统决定长度\n\n        举例：int[] arr = new int[]{1,2,3};\n        简化版：int[] arr = {1,2,3};\n(5)Java的内存分配\n    A:栈 存储局部变量\n    B:堆 存储所有new出来的\n    C:方法区(面向对象部分详细讲解)\n    D:本地方法区(系统相关)\n    E:寄存器(CPU使用)\n\n    注意：\n        a:局部变量 在方法定义中或者方法声明上定义的变量。\n        b:栈内存和堆内存的区别\n            栈：数据使用完毕，就消失。\n            堆：每一个new出来的东西都有地址\n                每一个变量都有默认值\n                    byte,short,int,long 0\n                    float,double 0.0\n                    char &apos;\\u0000&apos;\n                    boolean false\n                    引用类型 null\n                数据使用完毕后，在垃圾回收器空闲的时候回收。\n(6)数组内存图\n    A:一个数组\n    B:二个数组\n    C:三个数组(两个栈变量指向同一个堆内存)\n(7)数组的常见操作\n    A:遍历\n        方式1：\n            public static void printArray(int[] arr) {\n                for(int x=0; x&lt;arr.length; x++) {\n                    System.out.println(arr[x]);\n                }\n            }\n\n        方式2：\n            public static void printArray(int[] arr) {\n                System.out.print(&quot;[&quot;);\n                for(int x=0; x&lt;arr.length; x++) {\n                    if(x == arr.length-1) {\n                        System.out.println(arr[x]+&quot;]&quot;);\n                    }else {\n                        System.out.println(arr[x]+&quot;, &quot;);\n                    }\n                }\n            }\n    B:最值\n        最大值：\n            public static int getMax(int[] arr) {\n                int max = arr[0];\n\n                for(int x=1; x&lt;arr.length; x++) {\n                    if(arr[x] &gt; max) {\n                        max = arr[x];\n                    }\n                }\n\n                return max;\n            }\n\n        最小值：\n            public static int getMin(int[] arr) {\n                int min = arr[0];\n\n                for(int x=1; x&lt;arr.length; x++) {\n                    if(arr[x] &lt; min) {\n                        min = arr[x];\n                    }\n                }\n\n                return min;\n            }\n    C:逆序\n        方式1：\n            public static void reverse(int[] arr) {\n                for(int x=0; x&lt;arr.length/2; x++) {\n                    int temp = arr[x];\n                    arr[x] = arr[arr.length-1-x];\n                    arr[arr.length-1-x] = temp;\n                }\n            }\n\n        方式2：\n            public static void reverse(int[] arr) {\n                for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) {\n                    int temp = arr[start];\n                    arr[start] = arr[end];\n                    arr[end] = temp;\n                }\n            }\n    D:查表\n            public static String getString(String[] strArray,int index) {\n                return strArray[index];\n            }\n    E:基本查找\n        方式1：\n            public static int getIndex(int[] arr,int value) {\n                for(int x=0; x&lt;arr.length; x++) {\n                    if(arr[x] == value) {\n                        return x;\n                    }\n                }\n\n                return -1;\n            }\n\n        方式2：\n            public static int getIndex(int[] arr,int value) {\n                int index = -1;\n\n                for(int x=0; x&lt;arr.length; x++) {\n                    if(arr[x] == value) {\n                        index = x;\n                        break;\n                    }\n                }\n\n                return index;\n            }</code></pre><h1 id=\"Java面向对象\"><a href=\"#Java面向对象\" class=\"headerlink\" title=\"Java面向对象\"></a>Java面向对象</h1><h2 id=\"1-成员变量和局部变量的区别-理解\"><a href=\"#1-成员变量和局部变量的区别-理解\" class=\"headerlink\" title=\"1. 成员变量和局部变量的区别(理解)\"></a>1. 成员变量和局部变量的区别(理解)</h2><pre><code>(1)在类中的位置不同\n    成员变量：类中方法外\n    局部变量：方法定义中或者方法声明上\n(2)在内存中的位置不同\n    成员变量：在堆中\n    局部变量：在栈中\n(3)生命周期不同\n    成员变量：随着对象的创建而存在，随着对象的消失而消失\n    局部变量：随着方法的调用而存在，随着方法的调用完毕而消失\n(4)初始化值不同\n    成员变量：有默认值\n    局部变量：没有默认值，必须定义，赋值，然后才能使用</code></pre><h2 id=\"2-类作为形式参数的问题-理解\"><a href=\"#2-类作为形式参数的问题-理解\" class=\"headerlink\" title=\"2. 类作为形式参数的问题?(理解)\"></a>2. 类作为形式参数的问题?(理解)</h2><pre><code>(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。</code></pre><h2 id=\"3-匿名对象-理解\"><a href=\"#3-匿名对象-理解\" class=\"headerlink\" title=\"3. 匿名对象(理解)\"></a>3. 匿名对象(理解)</h2><pre><code>(1)没有名字的对象\n(2)应用场景\n    A:调用方法，仅仅只调用一次的时候。\n    b:可以作为实际参数传递。</code></pre><h2 id=\"4-封装-理解\"><a href=\"#4-封装-理解\" class=\"headerlink\" title=\"4. 封装(理解)\"></a>4. 封装(理解)</h2><pre><code>(1)隐藏实现细节，提供公共的访问方式\n(2)好处：\n    A:隐藏实现细节，提供公共的访问方式\n    B:提高代码的复用性\n    C:提高代码的安全性\n(3)设计原则\n    把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式\n(4)private是封装的一种体现。\n    封装：类，方法，private修饰成员变量</code></pre><h2 id=\"5-private关键字-掌握\"><a href=\"#5-private关键字-掌握\" class=\"headerlink\" title=\"5. private关键字(掌握)\"></a>5. private关键字(掌握)</h2><pre><code>(1)私有的意义，可以修饰成员变量和成员方法\n(2)特点：\n    被private修饰的后的成员只能在本类中被访问\n(3)private的应用：\n    以后再写一个类的时候：\n        把所有的成员变量给private了\n        提供对应的getXxx()/setXxx()方法</code></pre><h2 id=\"6-this关键字-掌握\"><a href=\"#6-this关键字-掌握\" class=\"headerlink\" title=\"6. this关键字(掌握)\"></a>6. this关键字(掌握)</h2><pre><code>(1)代表当前类的引用对象\n    记住：哪个对象调用方法，该方法内部的this就代表那个对象\n(2)this的应用场景：\n    A:解决了局部变量隐藏成员变量的问题\n    B:其实this还有其他的应用，明天讲解。</code></pre><h2 id=\"7-构造方法-掌握\"><a href=\"#7-构造方法-掌握\" class=\"headerlink\" title=\"7. 构造方法(掌握)\"></a>7. 构造方法(掌握)</h2><pre><code>(1)作用：用于对对象的数据进行初始化\n(2)格式：\n    A:方法名和类名相同\n    B:没有返回值类型，连void都不能有\n    C:没有返回值\n\n    思考题：构造方法中可不可以有return语句呢?\n    可以。只要我们写成这个样子就OK了：return;\n    其实，在任何的void类型的方法的最后你都可以写上：return;\n(3)构造方法的注意事项\n    A:如果我们没写构造方法，系统将提供一个默认的无参构造方法\n    B:如果我们给出了构造方法，系统将不再提供默认构造方法\n        如果这个时候，我们要使用无参构造方法，就必须自己给出。\n        推荐：永远手动自己给出无参构造方法。\n(4)给成员变量赋值的方式\n    A:setXxx()\n    B:带参构造方法\n(5)标准案例\n    class Student {\n        private String name;\n        private int age;\n\n        public Student(){}\n\n        public Student(String name,int age) {\n            this.name = name;\n            this.age = age;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public int getAge() {\n            return age;\n        }\n\n        public void setAge(int age) {\n            this.age = age;\n        }\n    }\n\n    测试：\n    class StudentDemo {\n        public static void main(String[] args) {\n            //方式1\n            Student s1 = new Student();\n            s1.setName(&quot;林青霞&quot;);\n            s1.setAge(27);\n            System.out.println(s1.getName()+&quot;---&quot;+s1.getAge());\n\n            //方式2\n            Student s2 = new Student(&quot;刘意&quot;,30);\n            System.out.println(s2.getName()+&quot;---&quot;+s2.getAge());\n        }\n    }</code></pre><h2 id=\"8-代码：Student-s-new-Student-做了哪些事情-理解\"><a href=\"#8-代码：Student-s-new-Student-做了哪些事情-理解\" class=\"headerlink\" title=\"8. 代码：Student s = new Student();做了哪些事情?(理解)\"></a>8. 代码：Student s = new Student();做了哪些事情?(理解)</h2><pre><code>(1)把Student.class文件加载到内存\n(2)在栈内存为s开辟空间\n(3)在堆内存为学生对象申请空间\n(4)给学生的成员变量进行默认初始化。null,0\n(5)给学生的成员变量进行显示初始化。林青霞,27\n(6)通过构造方法给成员变量进行初始化。刘意,30\n(7)对象构造完毕，把地址赋值给s变量</code></pre><h2 id=\"9-面向对象的练习题-掌握\"><a href=\"#9-面向对象的练习题-掌握\" class=\"headerlink\" title=\"9. 面向对象的练习题(掌握)\"></a>9. 面向对象的练习题(掌握)</h2><pre><code>(1)标准的手机类的定义和测试\n(2)Demo类有求和方法，Test类进行测试。\n    什么时候定义成员变量?\n    当该变量是用来描述一个类的时候。\n(3)长方形案例\n(4)员工案例\n(5)MyMath案例(自己提供加减乘除并测试)\n    public class MyMath {\n        public MyMath() {\n        }\n\n        public static void add(int a, int b) {\n            System.out.println(&quot;add&quot; + (a + b));\n        }\n\n        public static void subtract(int a, int b) {\n            System.out.println(&quot;subtract&quot; + (a - b));\n        }\n\n        public static void multiply(int a, int b) {\n            System.out.println(&quot;multiply&quot; + (a * b));\n        }\n\n        public static void divide(int a, int b) {\n            System.out.println(&quot;divide&quot; + (a / b));\n        }\n    }</code></pre><h2 id=\"10-static关键字-理解\"><a href=\"#10-static关键字-理解\" class=\"headerlink\" title=\"10. static关键字(理解)\"></a>10. static关键字(理解)</h2><pre><code>(1)静态的意思。可以修饰成员变量和成员方法。\n(2)静态的特点：\n    A:随着类的加载而加载\n    B:优先于对象存在\n    C:被类的所有对象共享\n        这其实也是我们判断该不该使用静态的依据。\n        举例：饮水机和水杯的问题思考\n    D:可以通过类名调用\n        既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。\n(3)静态的内存图\n    静态的内容在方法区的静态区\n(4)静态的注意事项；\n    A:在静态方法中没有this对象\n    B:静态只能访问静态(代码测试过)\n(5)静态变量和成员变量的区别\n    A:所属不同\n        静态变量：属于类，类变量\n        成员变量：属于对象，对象变量，实例变量\n    B:内存位置不同\n        静态变量：方法区的静态区\n        成员变量：堆内存\n    C:生命周期不同\n        静态变量：静态变量是随着类的加载而加载，随着类的消失而消失\n        成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失\n    D:调用不同\n        静态变量：可以通过对象名调用，也可以通过类名调用\n        成员变量：只能通过对象名调用\n(6)main方法是静态的\n    public:权限最大\n    static:不用创建对象调用\n    void:返回值给jvm没有意义\n    main:就是一个常见的名称。\n    String[] args:可以接收数据，提供程序的灵活性\n        格式：java MainDemo hello world java\n              java MainDemo 10 20 30</code></pre><h2 id=\"1-如何制作帮助文档-了解\"><a href=\"#1-如何制作帮助文档-了解\" class=\"headerlink\" title=\"1. 如何制作帮助文档(了解)\"></a>1. 如何制作帮助文档(了解)</h2><pre><code>(1)写一个类\n(2)加入文档注释\n(3)通过javadoc工具生成即可\n    javadoc -d 目录 -author -version ArrayTool.java</code></pre><h2 id=\"2-通过JDK提供的API学习了Math类-掌握\"><a href=\"#2-通过JDK提供的API学习了Math类-掌握\" class=\"headerlink\" title=\"2. 通过JDK提供的API学习了Math类(掌握)\"></a>2. 通过JDK提供的API学习了Math类(掌握)</h2><pre><code>(1)API(Application Programming Interface)\n    应用程序编程接口(帮助文档)\n(2)如何使用呢?\n    请参照\n        day08\\code\\02_如何使用JDK提供的帮助文档\\如何使用帮助文档.txt\n(3)Math类\n    A:是针对数学进行操作的类\n    B:没有构造方法，因为它的成员都是静态的\n    C:产生随机数\n        public static double random(): [0.0,1.0)\n    D:如何产生一个1-100之间的随机数\n        int number = (int)(Math.random()*100)+1;\n    E:猜数字小游戏</code></pre><h2 id=\"3-代码块-理解\"><a href=\"#3-代码块-理解\" class=\"headerlink\" title=\"3. 代码块(理解)\"></a>3. 代码块(理解)</h2><pre><code>(1)用{}括起来的代码。\n(2)分类：\n    A:局部代码块\n        用于限定变量的生命周期，及早释放，提高内存利用率。\n    B:构造代码块\n        把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。\n    C:静态代码块\n        对类的数据进行初始化，仅仅只执行一次。\n(3)静态代码块,构造代码块,构造方法的顺序问题?\n    静态代码块 &gt; 构造代码块 &gt; 构造方法</code></pre><h2 id=\"4-继承-掌握\"><a href=\"#4-继承-掌握\" class=\"headerlink\" title=\"4. 继承(掌握)\"></a>4. 继承(掌握)</h2><pre><code>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，\n   这多个类就具备了这些内容。这个关系叫继承。\n(2)Java中如何表示继承呢?格式是什么呢?\n    A:用关键字extends表示\n    B:格式：\n        class 子类名 extends 父类名 {}\n(3)继承的好处：\n    A:提高了代码的复用性\n    B:提高了代码的维护性\n    C:让类与类产生了一个关系，是多态的前提\n(4)继承的弊端：\n    A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。\n        原则：低耦合，高内聚。\n        耦合：类与类的关系\n        内聚：自己完成某件事情的能力\n    B:打破了封装性\n(5)Java中继承的特点\n    A:Java中类只支持单继承\n    B:Java中可以多层(重)继承(继承体系)\n(6)继承的注意事项：\n    A:子类不能继承父类的私有成员\n    B:子类不能继承父类的构造方法，但是可以通过super去访问\n    C:不要为了部分功能而去继承\n(7)什么时候使用继承呢?\n    A:继承体现的是：is a的关系。\n    B:采用假设法\n(8)Java继承中的成员关系\n    A:成员变量\n        a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单\n        b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?\n            子类的方法访问变量的查找顺序：\n                在子类方法的局部范围找，有就使用。\n                在子类的成员范围找，有就使用。\n                在父类的成员范围找，有就使用。\n                找不到，就报错。\n    B:构造方法\n        a:子类的构造方法默认会去访问父类的无参构造方法\n            是为了子类访问父类数据的初始化\n        b:父类中如果没有无参构造方法，怎么办?\n            子类通过super去明确调用带参构造\n            子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造\n            让父类提供无参构造\n    C:成员方法\n        a:子类的成员方法和父类中的成员方法名称不一样，这个太简单\n        b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?\n            通过子类对象访问一个方法的查找顺序：\n                在子类中找，有就使用\n                在父类中找，有就使用\n                找不到，就报错\n(9)两个面试题：\n    A:Override和Overload的区别?Overload是否可以改变返回值类型?\n    B:this和super的区别和各自的作用?\n(10)数据初始化的面试题\n    A:一个类的初始化过程\n    B:子父类的构造执行过程\n    C:分层初始化\n(11)案例：\n    A:学生和老师案例\n        继承前\n        继承后\n    B:猫狗案例的分析和实现</code></pre><h2 id=\"1-final关键字-掌握\"><a href=\"#1-final关键字-掌握\" class=\"headerlink\" title=\"1. final关键字(掌握)\"></a>1. final关键字(掌握)</h2><pre><code>(1)是最终的意思，可以修饰类，方法，变量。\n(2)特点：\n    A:它修饰的类，不能被继承。\n    B:它修饰的方法，不能被重写。\n    C:它修饰的变量，是一个常量。\n(3)面试相关：\n    A:局部变量\n        a:基本类型 值不能发生改变\n        b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的\n    B:初始化时机\n        a:只能初始化一次。\n        b:常见的给值\n            定义的时候。(推荐)\n            构造方法中。</code></pre><h2 id=\"2-多态-掌握\"><a href=\"#2-多态-掌握\" class=\"headerlink\" title=\"2. 多态(掌握)\"></a>2. 多态(掌握)</h2><pre><code>(1)同一个对象在不同时刻体现出来的不同状态。\n(2)多态的前提：\n    A:有继承或者实现关系。\n    B:有方法重写。\n    C:有父类或者父接口引用指向子类对象。\n\n    多态的分类：\n        a:具体类多态\n            class Fu {}\n            class Zi extends Fu {}\n\n            Fu f = new Zi();\n        b:抽象类多态\n            abstract class Fu {}\n            class Zi extends Fu {}\n\n            Fu f = new Zi();\n        c:接口多态\n            interface Fu {}\n            class Zi implements Fu {}\n\n            Fu f = new Zi();\n(3)多态中的成员访问特点\n    A:成员变量\n        编译看左边，运行看左边\n    B:构造方法\n        子类的构造都会默认访问父类构造\n    C:成员方法\n        编译看左边，运行看右边\n    D:静态方法\n        编译看左边，运行看左边\n\n    为什么?\n        因为成员方法有重写。\n(4)多态的好处：\n    A:提高代码的维护性(继承体现)\n    B:提高代码的扩展性(多态体现)\n(5)多态的弊端：\n    父不能使用子的特有功能。\n\n    现象：\n        子可以当作父使用，父不能当作子使用。\n(6)多态中的转型\n    A:向上转型\n        从子到父\n    B:向下转型\n        从父到子\n(7)孔子装爹的案例帮助大家理解多态\n(8)多态的练习\n    A:猫狗案例\n    B:老师和学生案例</code></pre><h2 id=\"3-抽象类-掌握\"><a href=\"#3-抽象类-掌握\" class=\"headerlink\" title=\"3. 抽象类(掌握)\"></a>3. 抽象类(掌握)</h2><pre><code>(1)把多个共性的东西提取到一个类中，这是继承的做法。\n   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。\n   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。\n   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。\n   而一个没有具体的方法体的方法是抽象的方法。\n   在一个类中如果有抽象方法，该类必须定义为抽象类。\n(2)抽象类的特点\n    A:抽象类和抽象方法必须用关键字abstract修饰\n    B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类\n    C:抽象类不能实例化\n    D:抽象类的子类\n        a:是一个抽象类。\n        b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。\n(3)抽象类的成员特点：\n    A:成员变量\n        有变量，有常量\n    B:构造方法\n        有构造方法\n    C:成员方法\n        有抽象，有非抽象\n(4)抽象类的练习\n    A:猫狗案例练习\n    B:老师案例练习\n    C:学生案例练习\n    D:员工案例练习\n(5)抽象类的几个小问题\n    A:抽象类有构造方法，不能实例化，那么构造方法有什么用?\n        用于子类访问父类数据的初始化\n    B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?\n        为了不让创建对象\n    C:abstract不能和哪些关键字共存\n        a:final    冲突\n        b:private 冲突\n        c:static 无意义</code></pre><h2 id=\"4-接口-掌握\"><a href=\"#4-接口-掌握\" class=\"headerlink\" title=\"4. 接口(掌握)\"></a>4. 接口(掌握)</h2><pre><code>(1)回顾猫狗案例，它们仅仅提供一些基本功能。\n   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，\n   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。\n(2)接口的特点：\n    A:接口用关键字interface修饰\n        interface 接口名 {}\n    B:类实现接口用implements修饰\n        class 类名 implements 接口名 {}\n    C:接口不能实例化\n    D:接口的实现类\n        a:是一个抽象类。\n        b:是一个具体类，这个类必须重写接口中的所有抽象方法。\n(3)接口的成员特点：\n    A:成员变量\n        只能是常量\n        默认修饰符：public static final\n    B:构造方法\n        没有构造方法\n    C:成员方法\n        只能是抽象的\n        默认修饰符：public abstract\n(4)类与类,类与接口,接口与接口\n    A:类与类\n        继承关系，只能单继承，可以多层继承\n    B:类与接口\n        实现关系，可以单实现，也可以多实现。\n        还可以在继承一个类的同时，实现多个接口\n    C:接口与接口\n        继承关系，可以单继承，也可以多继承\n(5)抽象类和接口的区别(自己补齐)?\n    A:成员区别\n        抽象类：可以是变量可以是常量\n        接口：只能是常量\n    B:关系区别:\n        类与类：继承\n        类与接口：实现\n        接口与接口：继承\n    C:设计理念不同\n        抽象类：is a，抽象类中定义的是共性功能。\n        接口：like a，接口中定义的是扩展功能。\n(6)练习：\n    A:猫狗案例，加入跳高功能\n    B:老师和学生案例，加入抽烟功能0</code></pre><h2 id=\"1-形式参数和返回值的问题-理解\"><a href=\"#1-形式参数和返回值的问题-理解\" class=\"headerlink\" title=\"1. 形式参数和返回值的问题(理解)\"></a>1. 形式参数和返回值的问题(理解)</h2><pre><code>(1)形式参数：\n    类名：需要该类的对象\n    抽象类名：需要该类的子类对象\n    接口名：需要该接口的实现类对象\n(2)返回值类型：\n    类名：返回的是该类的对象\n    抽象类名：返回的是该类的子类对象\n    接口名：返回的是该接口的实现类的对象\n(3)链式编程\n    对象.方法1().方法2().......方法n();\n\n    这种用法：其实在方法1()调用完毕后，应该一个对象；\n              方法2()调用完毕后，应该返回一个对象。\n              方法n()调用完毕后，可能是对象，也可以不是对象。</code></pre><h2 id=\"2-包-理解\"><a href=\"#2-包-理解\" class=\"headerlink\" title=\"2. 包(理解)\"></a>2. 包(理解)</h2><pre><code>(1)其实就是文件夹\n(2)作用：\n    A:区分同名的类\n    B:对类进行分类管理\n        a:按照功能分\n        b:按照模块分\n(3)包的定义(掌握)\n    package 包名;\n    多级包用.分开。\n(4)注意事项：(掌握)\n    A:package语句必须在文件中的第一条有效语句\n    B:在一个java文件中，只能有一个package\n    C:如果没有package，默认就是无包名\n(5)带包的编译和运行\n    A:手动式\n    B:自动式(掌握)\n        javac -d . HelloWorld.java</code></pre><h2 id=\"3-导包-掌握\"><a href=\"#3-导包-掌握\" class=\"headerlink\" title=\"3. 导包(掌握)\"></a>3. 导包(掌握)</h2><pre><code>(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。\n(2)格式：\n    import 包名...类名;\n    另一种：\n        import 包名...*;(不建议)\n(3)package,import,class的顺序\n    package &gt; import &gt; class</code></pre><h2 id=\"4-权限修饰符-掌握\"><a href=\"#4-权限修饰符-掌握\" class=\"headerlink\" title=\"4. 权限修饰符(掌握)\"></a>4. 权限修饰符(掌握)</h2><pre><code>(1)权限修饰符\n                本类    同一个包下    不同包下的子类    不同包下的无关类\n    private        Y\n        默认        Y        Y\n    protected    Y        Y             Y\n    public        Y        Y             Y                  Y\n(2)这四种权限修饰符在任意时刻只能出现一种。\n    public class Demo {}        </code></pre><h2 id=\"5-常见的修饰符-理解\"><a href=\"#5-常见的修饰符-理解\" class=\"headerlink\" title=\"5. 常见的修饰符(理解)\"></a>5. 常见的修饰符(理解)</h2><pre><code>(1)分类：\n    权限修饰符：private,默认,protected,public\n    状态修饰符：static,final\n    抽象修饰符：abstract\n(2)常见的类及其组成的修饰\n    类：\n        默认,public,final,abstract\n        常用的：public\n    成员变量：\n        private,默认,protected,public,static,final\n        常用的：private\n    构造方法：\n        private,默认,protected,public\n        常用的：public\n    成员方法：\n        private,默认,protected,public,static,final,abstract\n        常用的：public\n(3)另外比较常见的：\n    public static final int X = 10;\n    public static void show() {}\n    public final void show() {}\n    public abstract void show();</code></pre><h2 id=\"6-内部类-理解\"><a href=\"#6-内部类-理解\" class=\"headerlink\" title=\"6. 内部类(理解)\"></a>6. 内部类(理解)</h2><pre><code>(1)把类定义在另一个类的内部，该类就被称为内部类。\n    举例：把类B定义在类A中，类B就被称为内部类。\n(2)内部类的访问规则\n    A:可以直接访问外部类的成员，包括私有\n    B:外部类要想访问内部类成员，必须创建对象\n(3)内部类的分类\n    A:成员内部类\n    B:局部内部类\n(4)成员内部类\n    A:private 为了数据的安全性\n    B:static 为了访问的方便性        \n成员内部类不是静态的：\n    外部类名.内部类名 对象名 = new 外部类名.new 内部类名();\n成员内部类是静态的：\n    外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre><p>(5)成员内部类的面试题(填空)</p>\n<pre><code>30,20,10\nclass Outer {\n    public int num = 10;\n        class Inner {\n            public int num = 20;\n            public viod show() {\n            int num  = 30;\n            System.out.println(num);\n            System.out.println(this.num);\n            System.out.println(Outer.this.num);\n            }\n        }\n    }</code></pre><p>(6)局部内部类</p>\n<pre><code>A:局部内部类访问局部变量必须加final修饰。\nB:为什么呢?\n    因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。\n    所以，堆内存还是用该变量，而改变量已经没有了。\n    为了让该值还存在，就加final修饰。\n    通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。</code></pre><p>(7)匿名内部类(掌握)</p>\n<pre><code>A:是局部内部类的简化形式\nB:前提\n    存在一个类或者接口\nC:格式:\n    new 类名或者接口名() {\n        重写方法;\n    }\nD:本质：\n    其实是继承该类或者实现接口的子类匿名对象</code></pre><p>(8)匿名内部类在开发中的使用</p>\n<pre><code>我们在开发的时候，会看到抽象类，或者接口作为参数。\n而这个时候，我们知道实际需要的是一个子类对象。\n如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。\n\ninterface Person {\n    public abstract void study();\n}\n\nclass PersonDemo {\n    public void method(Person p) {\n        p.study();\n    }\n}\n\nclass PersonTest {\n    public static void main(String[] args) {\n        PersonDemo pd = new PersonDemo();\n        pd.method(new Person() {\n            public void study() {\n                System.out.println(&quot;好好学习，天天向上&quot;);\n            }\n        });\n    }\n}</code></pre><p>(9)匿名内部类的面试题(补齐代码)</p>\n<pre><code>interface Inter {\n    void show();\n}\n\nclass Outer {\n    public static Inter method() {\n        return new Inter() {\n            public void show() {\n                System.out.println(&quot;HelloWorld&quot;);\n            }    \n        };\n    }\n}\n\nclass OuterDemo {\n    public static void main(String[] args) {\n        Outer.method().show(); //&quot;HelloWorld&quot;\n    }\n\n}</code></pre><p>Java开发工具</p>\n<pre><code>## 1. Eclipse的概述使用(掌握)\n    请参照ppt和课堂练习.txt\n\n## 2. API的概述(了解)\n    (1)应用程序编程接口。\n    (2)就是JDK提供给我们的一些提高编程效率的java类。</code></pre><p>​<br>    ## 3. Object类(掌握)<br>        (1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。<br>        (2)Object类的构造方法有一个，并且是无参构造<br>            这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造<br>        (3)要掌握的方法：<br>            A:toString()<br>                返回对象的字符串表示，默认是由类的全路径+’@’+哈希值的十六进制表示。<br>                这个表示其实是没有意义的，一般子类都会重写该方法。<br>                如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。<br>                但是最终还是自动生成。<br>            B:equals()<br>                比较两个对象是否相同。默认情况下，比较的是地址值是否相同。<br>                而比较地址值是没有意义的，所以，一般子类也会重写该方法。<br>                重写过程，我也详细的讲解和分析了。<br>                但是最终还是自动生成。<br>        (4)要了解的方法：<br>            A:hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。<br>            B:getClass() 返回对象的字节码文件对象，反射中我们会详细讲解<br>            C:finalize() 用于垃圾回收，在不确定的时间<br>            D:clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。<br>        (5)两个注意问题；<br>            A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。<br>            B:面试题<br>                ==和equals()的区别?<br>                A:==<br>                    基本类型：比较的是值是否相同<br>                    引用类型：比较的是地址值是否相同<br>                B:equals()<br>                    只能比较引用类型。默认情况下，比较的是地址值是否相同。</p>\n<pre><code>但是，我们可以根据自己的需要重写该方法。</code></pre><h1 id=\"Java常见对象\"><a href=\"#Java常见对象\" class=\"headerlink\" title=\"Java常见对象\"></a>Java常见对象</h1><h2 id=\"1-Scanner的使用-了解\"><a href=\"#1-Scanner的使用-了解\" class=\"headerlink\" title=\"1. Scanner的使用(了解)\"></a>1. Scanner的使用(了解)</h2><pre><code>    (1)在JDK5以后出现的用于键盘录入数据的类。\n    (2)构造方法：\n        A:讲解了System.in这个东西。\n            它其实是标准的输入流,对应于键盘录入\n        B:构造方法\n            InputStream is = System.in;\n            Scanner(InputStream is)\n        C:常用的格式\n            Scanner sc = new Scanner(System.in);\n(3)基本方法格式：\n    A:hasNextXxx() 判断是否是某种类型的\n    B:nextXxx()    返回某种类型的元素\n(4)要掌握的两个方法\n    A:public int nextInt()\n    B:public String nextLine()\n(5)需要注意的小问题\n    A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。\n    B:解决方案：\n        a:重新定义一个Scanner对象\n        b:把所有的数据都用字符串获取，然后再进行相应的转换</code></pre><h2 id=\"2-String类的概述和使用-掌握\"><a href=\"#2-String类的概述和使用-掌握\" class=\"headerlink\" title=\"2. String类的概述和使用(掌握)\"></a>2. String类的概述和使用(掌握)</h2><pre><code>(1)多个字符组成的一串数据。\n    其实它可以和字符数组进行相互转换。\n(2)构造方法：\n    A:public String()\n    B:public String(byte[] bytes)\n    C:public String(byte[] bytes,int offset,int length)\n    D:public String(char[] value)\n    E:public String(char[] value,int offset,int count)\n    F:public String(String original)\n    下面的这一个虽然不是构造方法，但是结果也是一个字符串对象\n    G:String s = &quot;hello&quot;;\n(3)字符串的特点\n    A:字符串一旦被赋值，就不能改变。\n        注意：这里指的是字符串的内容不能改变，而不是引用不能改变。\n    B:字面值作为字符串对象和通过构造方法创建对象的不同\n        String s = new String(&quot;hello&quot;);和String s = &quot;hello&quot;的区别?\n        new String(&quot;hello&quot;)会在堆内存开辟空间,另一种不会,但是最终的值都在字符串缓存区.\n(4)字符串的面试题(看程序写结果)\n    A:==和equals()\n        String s1 = new String(&quot;hello&quot;);\n        String s2 = new String(&quot;hello&quot;);\n        System.out.println(s1 == s2);// false\n        System.out.println(s1.equals(s2));// true\n\n\n        String s3 = new String(&quot;hello&quot;);\n        String s4 = &quot;hello&quot;;\n        System.out.println(s3 == s4);// false\n        System.out.println(s3.equals(s4));// true\n\n\n        String s5 = &quot;hello&quot;;\n        String s6 = &quot;hello&quot;;\n        System.out.println(s5 == s6);// true(常量会先去缓存区找,存在就不创建新的对象)\n        System.out.println(s5.equals(s6));// true\n    B:字符串的拼接\n        String s1 = &quot;hello&quot;;\n        String s2 = &quot;world&quot;;\n        String s3 = &quot;helloworld&quot;;\n        System.out.println(s3 == s1 + s2);// false\n        System.out.println(s3.equals((s1 + s2)));// true\n\n\n        System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// false 这个我们错了，应该是true\n        System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true\n(5)字符串的功能(自己补齐方法中文意思)\n    A:判断功能\n        boolean equals(Object obj)\n        boolean equalsIgnoreCase(String str)\n        boolean contains(String str)\n        boolean startsWith(String str)\n        boolean endsWith(String str)\n        boolean isEmpty()\n    B:获取功能\n        int length()\n        char charAt(int index)\n        int indexOf(int ch)\n        int indexOf(String str)\n        int indexOf(int ch,int fromIndex)\n        int indexOf(String str,int fromIndex)\n        String substring(int start)\n        String substring(int start,int end)\n    C:转换功能\n        byte[] getBytes()\n        char[] toCharArray()\n        static String valueOf(char[] chs)\n        static String valueOf(int i)\n        String toLowerCase()\n        String toUpperCase()\n        String concat(String str)\n    D:其他功能\n        a:替换功能 \n            String replace(char old,char new)\n            String replace(String old,String new)\n        b:去空格功能\n            String trim()\n        c:按字典比较功能\n            int compareTo(String str)\n            int compareToIgnoreCase(String str) \n(6)字符串的案例\n    A:模拟用户登录\n        public static void login(String userName, String passwd) {\n            if (userName == &quot;Xmos&quot; &amp;&amp; passwd == &quot;123&quot;) {\n                System.out.println(&quot;login success&quot;);\n            }\n        }\n    B:字符串遍历\n        public static void printString(String s) {\n            char[] c = s.toCharArray();\n            for (int i = 0; i &lt; c.length; i++) {\n                System.out.print(c[i]);\n            }\n        }\n    C:统计字符串中大写，小写及数字字符的个数\n        public static void method(String s) {\n            char[] c = s.toCharArray();\n            int lowerCaseNum = 0;\n            int upperCaseNum = 0;\n            int num = 0;\n            for (char c1 : c) {\n                if (c1 &gt;= &apos;a&apos; &amp;&amp; c1 &lt;= &apos;z&apos;) {\n                    lowerCaseNum++;\n                } else if (c1 &gt;= &apos;A&apos; &amp;&amp; c1 &lt;= &apos;Z&apos;) {\n                    upperCaseNum++;\n                } else if (c1 &gt;= &apos;0&apos; &amp;&amp; c1 &lt;= &apos;9&apos;) {\n                    num++;\n                }\n            }\n\n    D:把字符串的首字母转成大写，其他小写\n        public static void method1(String s) {\n            String s1 = s.substring(0, 1);\n            String s2 = s.substring(1, s.length());\n            String s3 = s1.toUpperCase() + s2.toLowerCase();\n\n            System.out.println(s3);\n        }        \n    E:把int数组拼接成一个指定格式的字符串\n        //方法一\n        public static void method3(int[] i) {\n            String s = Arrays.toString(i);\n            System.out.println(s);\n        }\n        //方法二\n        public static void method3(int[] i) {\n                String s = &quot;&quot;;\n                for (int i1 : i) {\n                    s += String.valueOf(i1);\n                }\n                System.out.println(s);\n            }\n    F:字符串反转\n        public static void revers(String s) {\n            char[] c = s.toCharArray();\n            for (int i = 0; i &lt; c.length / 2; i++) {\n                char tmp = c[i];\n                c[i] = c[c.length - 1 - i];\n                c[c.length - 1 - i] = tmp;\n            }\n            System.out.println(String.valueOf(c));\n        }        \n    G:统计大串中小串出现的次数</code></pre><h2 id=\"1-StringBuffer-掌握\"><a href=\"#1-StringBuffer-掌握\" class=\"headerlink\" title=\"1. StringBuffer(掌握)\"></a>1. StringBuffer(掌握)</h2><pre><code>(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了\n   一个字符串缓冲区类。StringBuffer供我们使用。\n(2)StringBuffer的构造方法\n    A:StringBuffer()\n    B:StringBuffer(int size)\n    C:StringBuffer(String str)\n(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)\n    A:添加功能\n        appen();\n    B:删除功能\n        delete();\n    C:替换功能\n        replace()\n    D:反转功能\n        reverse()\n    E:截取功能(注意这个返回值)\n        String substring()\n(4)StringBuffer的练习(做一遍)\n    A:String和StringBuffer相互转换\n        String -- StringBuffer\n            构造方法\n        StringBuffer -- String\n            toString()方法\n    B:字符串的拼接\n        StringBuffer sb = new StringBuffer(&quot;hello&quot;);\n        StringBuffer sb2 = new StringBuffer(&quot;world&quot;);\n\n        StringBuffer sb3 = sb.append(sb2);\n    C:把字符串反转\n        StringBuffer sb = new StringBuffer(&quot;abc&quot;);\n        StringBuffer sb1 = sb.reverse();\n    D:判断一个字符串是否对称\n        public static void method(StringBuffer sb) {\n            if (sb.toString().equals(sb.reverse().toString())) {\n                System.out.println(true);\n            } else {\n                System.out.println(false);\n            }\n        }\n\n(5)面试题\n    小细节：\n        StringBuffer：同步的，数据安全，效率低。\n        StringBuilder：不同步的，数据不安全，效率高。\n    A:String,StringBuffer,StringBuilder的区别\n        String 字符串常量\n        StringBuffer 字符串变量（线程安全）\n        StringBuilder 字符串变量（非线程安全）\n    B:StringBuffer和数组的区别?\n        StringBuffer : 可以存放任意类型的数据\n        数组 : 只能存放同类型的数据\n(6)注意的问题：\n    String作为形式参数，StringBuffer作为形式参数。\n        String : 不会受影响\n        StringBuffer : 除了=操作，其他操作会受影响</code></pre><h2 id=\"2-数组高级以及Arrays-掌握\"><a href=\"#2-数组高级以及Arrays-掌握\" class=\"headerlink\" title=\"2. 数组高级以及Arrays(掌握)\"></a>2. 数组高级以及Arrays(掌握)</h2><pre><code>(1)排序\n    A:冒泡排序\n        相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。\n\n        public static void bubbleSort(int[] arr) {\n            for(int x=0; x&lt;arr.length-1; x++) {\n                for(int y=0; y&lt;arr.length-1-x; y++) {\n                    if(arr[y] &gt; arr[y+1]) {\n                        int temp = arr[y];\n                        arr[y] = arr[y+1];\n                        arr[y+1] = temp;\n                    }\n                }\n            }\n        }\n\n    B:选择排序\n        把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。\n\n        public static void selectSort(int[] arr) {\n            for(int x=0; x&lt;arr.length-1; x++) {\n                for(int y=x+1; y&lt;arr.length; y++) {\n                    if(arr[y] &lt; arr[x]) {\n                        int temp = arr[x];\n                        arr[x] = arr[y];\n                        arr[y] = temp;\n                    }\n                }\n            }\n        }\n(2)查找\n    A:基本查找\n        针对数组无序的情况\n\n        public static int getIndex(int[] arr,int value) {\n            int index = -1;\n\n            for(int x=0; x&lt;arr.length; x++) {\n                if(arr[x] == value) {\n                    index = x;\n                    break;\n                }\n            }\n\n            return index;\n        }\n    B:二分查找(折半查找)\n        针对数组有序的情况(千万不要先排序，在查找)\n\n        public static int binarySearch(int[] arr,int value) {\n            int min = 0;\n            int max = arr.length-1;\n            int mid = (min+max)/2;\n\n            while(arr[mid] != value) {\n                if(arr[mid] &gt; value) {\n                    max = mid - 1;\n                }else if(arr[mid] &lt; value) {\n                    min = mid + 1;\n                }\n\n                if(min &gt; max) {\n                    return -1;\n                }\n\n                mid = (min+max)/2;\n            }\n\n            return mid;\n        }\n(3)Arrays工具类\n    A:是针对数组进行操作的工具类。包括排序和查找等功能。\n    B:要掌握的方法(自己补齐方法)\n        把数组转成字符串：\n            Arrays.toString();\n        排序：\n            Arrays.sort();\n        二分查找：\n            Arrays.binarySearch();\n(4)Arrays工具类的源码解析\n(5)把字符串中的字符进行排序\n    举例：\n        &quot;edacbgf&quot;\n        得到结果\n        &quot;abcdefg&quot;\n        String s = &quot;edacbgf&quot;;\n        char[] c = s.toCharArray();\n        Arrays.sort(c);\n        System.out.println(Arrays.toString(c));</code></pre><h2 id=\"3-Integer-掌握\"><a href=\"#3-Integer-掌握\" class=\"headerlink\" title=\"3. Integer(掌握)\"></a>3. Integer(掌握)</h2><pre><code>(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型\n    byte         Byte\n    short        Short\n    int            Integer\n    long        Long\n    float        Float\n    double        Double\n    char        Character\n    boolean        Boolean\n(2)Integer的构造方法\n    A:Integer i = new Integer(100);\n    B:Integer i = new Integer(&quot;100&quot;);\n        注意：这里的字符串必须是由数字字符组成\n(3)String和int的相互转换\n    A:String -- int\n        Integer.parseInt(&quot;100&quot;);\n    B:int -- String\n        String.valueOf(100);\n(4)其他的功能(了解)\n    进制转换\n        Integer.toBinaryString();\n        Integer.toHexString();\n        Integer.toOctalString();\n(5)JDK5的新特性\n    自动装箱    基本类型--引用类型\n    自动拆箱    引用类型--基本类型\n\n    把下面的这个代码理解即可：\n        Integer i = 100;\n        i += 200;\n(6)面试题\n    -128到127之间的数据缓冲池问题</code></pre><h2 id=\"4-Character-了解\"><a href=\"#4-Character-了解\" class=\"headerlink\" title=\"4. Character(了解)\"></a>4. Character(了解)</h2><pre><code>(1)Character构造方法    \n    Character ch = new Character(&apos;a&apos;);\n(2)要掌握的方法：(自己补齐)\n    A:判断给定的字符是否是大写\n        isUpperCase();\n    B:判断给定的字符是否是小写\n        isLowerCase();\n    C:判断给定的字符是否是数字字符\n        isDigit();\n    D:把给定的字符转成大写\n        toUpperCase();\n    E:把给定的字符转成小写\n        toLowerCase();\n(3)案例：\n\n    统计字符串中大写，小写及数字字符出现的次数\n        String s = &quot;abcDEF123&quot;;\n        char[] c = s.toCharArray();\n        int lowerCaseNum = 0;\n        int upperCaseNum = 0;\n        int digitNum = 0;\n\n        for (char c1 : c) {\n            if (Character.isLowerCase(c1)) {\n                lowerCaseNum++;\n            } else if (Character.isUpperCase(c1)) {\n                upperCaseNum++;\n            } else if (Character.isDigit(c1)) {\n                digitNum++;\n            }\n        }\n\n        System.out.println(&quot;lowerCase:&quot; + lowerCaseNum + &quot;\\t&quot; + &quot;upperCase:&quot; + upperCaseNum + &quot;\\t&quot; + &quot;digit:&quot; + digitNum);</code></pre><h2 id=\"1-正则表达式-理解\"><a href=\"#1-正则表达式-理解\" class=\"headerlink\" title=\"1. 正则表达式(理解)\"></a>1. 正则表达式(理解)</h2><pre><code>(1)就是符合一定规则的字符串\n(2)常见规则\n    A:字符\n        x 字符 x。举例：&apos;a&apos;表示字符a\n        \\\\ 反斜线字符。\n        \\n 新行（换行）符 (&apos;\\u000A&apos;) \n        \\r 回车符 (&apos;\\u000D&apos;)\n\n    B:字符类\n        [abc] a、b 或 c（简单类） \n        [^abc] 任何字符，除了 a、b 或 c（否定） \n        [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） \n        [0-9] 0到9的字符都包括\n\n    C:预定义字符类\n        . 任何字符。我的就是.字符本身，怎么表示呢? \\.\n        \\d 数字：[0-9]\n        \\w 单词字符：[a-zA-Z_0-9]\n            在正则表达式里面组成单词的东西必须有这些东西组成\n\n    D:边界匹配器\n        ^ 行的开头 \n        $ 行的结尾 \n        \\b 单词边界\n            就是不是单词字符的地方。\n            举例：hello world?haha;xixi\n\n    E:Greedy 数量词 \n        X? X，一次或一次也没有\n        X* X，零次或多次\n        X+ X，一次或多次\n        X{n} X，恰好 n 次 \n        X{n,} X，至少 n 次 \n        X{n,m} X，至少 n 次，但是不超过 m 次 \n(3)常见功能：(分别用的是谁呢?)\n    A:判断功能\n        String类的public boolean matches(String regex)\n    B:分割功能\n        String类的public String[] split(String regex)\n    C:替换功能\n        String类的public String replaceAll(String regex,String replacement)\n    D:获取功能\n        Pattern和Matcher\n            Pattern p = Pattern.compile(&quot;a*b&quot;);\n            Matcher m = p.matcher(&quot;aaaaab&quot;);\n\n            find():查找存不存在\n            group():获取刚才查找过的数据\n(4)案例\n    A:判断电话号码和邮箱\n        //普安段邮箱\n        public static boolean checkMail(String s){\n            String regex = &quot;\\\\d*\\\\w*@sina\\\\.com&quot;;\n            return s.matches(regex);\n        }\n        //判断电话号码\n        public static boolean checkPhoneNum(String s) {\n            String regex = &quot;\\\\d{11}&quot;;\n            return s.matches(regex);\n        }\n    B:按照不同的规则分割数据\n        public static String[] split(String s) {\n            String regex = &quot;,&quot;;\n            String[] result = s.split(regex);\n            return result;\n        }\n    C:把论坛中的数字替换为*\n        //替换为和数字等量的*\n        public static String replaceStar(String s) {\n            String regex = &quot;\\\\d&quot;;\n            return s.replaceAll(regex, &quot;*&quot;);\n        }\n        //所有相连数字替换为一个*\n        public static String replaceStar(String s) {\n            String regex = &quot;\\\\d+&quot;;\n            return s.replaceAll(regex, &quot;*&quot;);\n        }\n    D:获取字符串中由3个字符组成的单词\n        public static List&lt;String&gt; method(String s) {\n            Pattern p = Pattern.compile(&quot;a\\\\d{3}b&quot;);\n            Matcher m = p.matcher(s);\n            List&lt;String&gt; result = new ArrayList&lt;String&gt;();\n\n            while (m.find()) {\n                result.add(m.group());\n            }\n            return  result;\n        }</code></pre><h2 id=\"2-Math-掌握\"><a href=\"#2-Math-掌握\" class=\"headerlink\" title=\"2. Math(掌握)\"></a>2. Math(掌握)</h2><pre><code>(1)针对数学运算进行操作的类\n(2)常见方法(自己补齐)\n    A:绝对值\n        Math.abs();\n    B:向上取整\n        Math.ceil();\n    C:向下取整\n        Math.floor();\n    D:两个数据中的大值\n        Math.max();\n    E:a的b次幂\n        Math.pow(a, b);\n    F:随机数\n        Math.random();\n    G:四舍五入\n        Math.round();\n    H:正平方根\n        Math.sqrt();\n(3)案例：\n    A:猜数字小游戏\n        Scanner sc = new Scanner(System.in);\n        int i = (int)(Math.random() * 100) + 1;\n        int answer;\n        while ((answer = sc.nextInt()) != i) {\n            if (answer &gt; i) {\n                System.out.println(&quot;bigger than result,go on&quot;);\n            } else if (answer &lt; i) {\n                System.out.println(&quot;smaller than result,go on&quot;);\n            }\n        }\n        System.out.println(&quot;you are right&quot;);\n    B:获取任意范围的随机数\n        Scanner sc = new Scanner(System.in);\n        System.out.println(&quot;请输入起始:&quot;);\n        int start = sc.nextInt();\n        System.out.println(&quot;请输入结束:&quot;);\n        int end = sc.nextInt();\n\n        int i = (int)(Math.random() * (end - start)) + start;\n        System.out.println(i);</code></pre><h2 id=\"3-Random-理解\"><a href=\"#3-Random-理解\" class=\"headerlink\" title=\"3. Random(理解)\"></a>3. Random(理解)</h2><pre><code>(1)用于产生随机数的类\n(2)构造方法:\n    A:Random() 默认种子，每次产生的随机数不同\n    B:Random(long seed) 指定种子，每次种子相同，随机数就相同\n(3)成员方法:\n    A:int nextInt() 返回int范围内的随机数\n    B:int nextInt(int n) 返回[0,n)范围内的随机数</code></pre><h2 id=\"4-System-掌握\"><a href=\"#4-System-掌握\" class=\"headerlink\" title=\"4. System(掌握)\"></a>4. System(掌握)</h2><pre><code>(1)系统类,提供了一些有用的字段和方法\n(2)成员方法(自己补齐)\n    A:运行垃圾回收器\n        System.gc();\n    B:退出jvm\n        System.exit(0);\n    C:获取当前时间的毫秒值\n        System.currentTimemillis();\n    D:数组复制\n        System.arraycopy();</code></pre><h2 id=\"5-BigInteger-理解\"><a href=\"#5-BigInteger-理解\" class=\"headerlink\" title=\"5. BigInteger(理解)\"></a>5. BigInteger(理解)</h2><pre><code>(1)针对大整数的运算\n(2)构造方法    \n    A:BigInteger(String s)\n(3)成员方法(自己补齐)\n    A:加\n        add();\n    B:减\n        subtract();\n    C:乘\n        multiply();\n    D:除\n        divide();\n    E:商和余数\n        divideAndRemainder();</code></pre><h2 id=\"6-BigDecimal-理解\"><a href=\"#6-BigDecimal-理解\" class=\"headerlink\" title=\"6. BigDecimal(理解)\"></a>6. BigDecimal(理解)</h2><pre><code>(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)\n(2)构造方法\n    A:BigDecimal(String s)\n(3)成员方法：\n    A:加\n        add();\n    B:减\n        subtract();\n    C:乘\n        multiply();\n    D:除\n        divide();\n    E:自己保留小数几位\n        setScale();</code></pre><h2 id=\"7-Date-DateFormat-掌握\"><a href=\"#7-Date-DateFormat-掌握\" class=\"headerlink\" title=\"7. Date/DateFormat(掌握)\"></a>7. Date/DateFormat(掌握)</h2><pre><code>(1)Date是日期类，可以精确到毫秒。\n    A:构造方法\n        Date()\n        Date(long time)\n    B:成员方法\n        getTime()\n        setTime(long time)\n    C:日期和毫秒值的相互转换\n    案例：你来到这个世界多少天了?\n(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat\n    A:SimpleDateFormat(String pattern) 给定模式\n        yyyy-MM-dd HH:mm:ss\n    B:日期和字符串的转换\n        a:Date -- String\n            format()\n\n        b:String -- Date\n            parse()\n    C:案例：\n        制作了一个针对日期操作的工具类。\n            Date d = new Date();\n            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n            System.out.println(sdf.format(d));</code></pre><h2 id=\"8-Calendar-掌握\"><a href=\"#8-Calendar-掌握\" class=\"headerlink\" title=\"8. Calendar(掌握)\"></a>8. Calendar(掌握)</h2><pre><code>(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。\n(2)如何得到一个日历对象呢?\n    Calendar rightNow = Calendar.getInstance();\n    本质返回的是子类对象\n(3)成员方法\n    A:根据日历字段得到对应的值\n        Calendar c =Calendar.getInstance();\n        System.out.println(c.get(Calendar.YEAR));\n        System.out.println(c.get(Calendar.MONTH));\n        System.out.println(c.get(Calendar.DAY_OF_MONTH));\n    B:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值\n        add(Calendar.DAY_OF_MONTH, +3);\n    C:设置日历对象的年月日\n        set(2018,5,30);\n        set(Calendar.YEAR, 2018);\n        set(Calendar.MONTH, 2018);\n        set(Calendar.DAY_OF_MONTH, 2018);\n(4)案例：\n    计算任意一年的2月份有多少天?\n        Scanner sc = new Scanner(System.in);\n        Calendar c =Calendar.getInstance();\n\n        c.set(Calendar.YEAR, sc.nextInt());\n        System.out.println(c.get(Calendar.DAY_OF_MONTH));</code></pre><h1 id=\"Java集合框架\"><a href=\"#Java集合框架\" class=\"headerlink\" title=\"Java集合框架\"></a>Java集合框架</h1><h1 id=\"JavaIO流\"><a href=\"#JavaIO流\" class=\"headerlink\" title=\"JavaIO流\"></a>JavaIO流</h1><h2 id=\"1-异常-理解\"><a href=\"#1-异常-理解\" class=\"headerlink\" title=\"1. 异常(理解)\"></a>1. 异常(理解)</h2><pre><code>(1)程序出现的不正常的情况。\n(2)异常的体系\n    Throwable\n        |--Error    严重问题，我们不处理。\n        |--Exception\n            |--RuntimeException    运行期异常，我们需要修正代码\n            |--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过\n(3)异常的处理：\n    A:JVM的默认处理\n        把异常的名称,原因,位置等信息输出在控制台，但是程序不能继续执行了。\n    B:自己处理\n        a:try...catch...finally\n            自己编写处理代码,后面的程序可以继续执行\n        b:throws\n            把自己处理不了的，在方法上声明，告诉调用者，这里有问题\n(4)面试题\n    A:编译期异常和运行期异常的区别?\n        编译期异常 必须要处理的，否则编译不通过\n        运行期异常 可以不处理，也可以处理\n    B:throw和throws是的区别\n        throw:\n            在方法体中,后面跟的是异常对象名,并且只能是一个\n            throw抛出的是一个异常对象，说明这里肯定有一个异常产生了\n        throws:\n            在方法声明上,后面跟的是异常的类名,可以是多个\n            throws是声明方法有异常，是一种可能性，这个异常并不一定会产生\n(5)finally关键字及其面试题\n    A:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了\n    B:面试题\n        a:final,finally,finalize的区别?\n            final : 关键字,修饰类、方法、变量,被修饰的类无法被继承,方法无法重写,变量值不能改变.\n            finally : try...catch...finally,一定会执行.\n            finalize : 对象被垃圾回收器回收时执行的方法.\n        b:如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后\n            会，前。\n\n            实际上在中间。这个上课我们讲过\n    C:异常处理的变形\n        try...catch...finally\n        try...catch...\n        try...catch...catch...\n        try...catch...catch...fianlly\n        try...finally\n(6)自定义异常\n    继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可\n        public class MyException extends RuntimeException {\n            public MyException(String message) {\n                super(message);\n            }\n\n            public MyException() {\n                super();\n            }\n        }\n(7)异常的注意实现\n    A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 \n    B:父的方法没有异常抛出,子的重写方法不能有异常抛出\n    C:父的方法抛出多个异常,子的重写方法必须比父少或者小</code></pre><h2 id=\"2-File-掌握\"><a href=\"#2-File-掌握\" class=\"headerlink\" title=\"2. File(掌握)\"></a>2. File(掌握)</h2><pre><code>(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件\n(2)构造方法\n    A:File file = new File(&quot;e:\\\\demo\\\\a.txt&quot;);\n    B:File file = new File(&quot;e:\\\\demo&quot;,&quot;a.txt&quot;);\n    C:File file = new File(&quot;e:\\\\demo&quot;);\n      File file2 = new File(file,&quot;a.txt&quot;);\n(3)File类的功能(自己补齐)\n    A:创建功能\n        createNewFile();\n        mkdir();\n        mkdirs();\n    B:删除功能\n        delete();\n    C:重命名功能\n        renameTo();\n    D:判断功能\n        isFile();\n        isDirectory();\n        exists();\n        canRea();\n        canWrite();\n        isAbsolute();\n        isHidden();\n    E:获取功能\n        getAbsoluteFile();\n        getAbsolutePath();\n        getPath();\n        getParent();\n        getParentFile();\n        getName();\n        length();\n        lastModified();\n    F:高级获取功能\n        list();\n        listFiles();\n    G:过滤器功能\n        list(FilenameFilter filter);\n            String[] s = file1.list(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return new File(dir, name).isFile() &amp;&amp; name.endsWith(&quot;.jpg&quot;);\n            }\n        });\n        listFiles(FilenameFilter filter);\n(4)案例：\n    A:输出指定目录下指定后缀名的文件名称\n        a:先获取所有的，在遍历的时候判断，再输出\n            File file = new File(&quot;D:\\\\Movie\\\\M&quot;);\n            String[] s = file.list();\n\n            for (String result : s) {\n                if (result.endsWith(&quot;.mp4&quot;)) {\n                    System.out.println(result);\n                }\n            }\n        b:先判断，再获取，最后直接遍历输出即可\n            String[] s1 = file.list(new FilenameFilter() {\n                @Override\n                public boolean accept(File dir, String name) {\n                    return name.endsWith(&quot;.mp4&quot;);\n                }\n            });\n            for (String result : s1) {\n                System.out.println(result);\n            }\n    B:批量修改文件名称\n        File file = new File(&quot;D:\\\\Movie&quot;);\n        String[] s = file.list(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return name.startsWith(&quot;相对宇宙&quot;);\n            }\n        });\n        for (String result : s) {\n            System.out.println(&quot;beforeRename : &quot; + result);\n            File file1 = new File(file,result.replaceAll(&quot;WEB.*影视\\\\.&quot;, &quot;&quot;));\n            File file2 = new File(file, result);\n            file2.renameTo(file1);\n            System.out.println(&quot;afterRename : &quot; + file1.exists() + &quot;, &quot; + file1.getName());\n        }\n        ## 1. 递归(理解)\n\n(1)方法定义中调用方法本身的现象\n    举例：老和尚给小和尚讲故事，我们学编程\n(2)递归的注意事项；\n    A:要有出口，否则就是死递归\n    B:次数不能过多，否则内存溢出\n    C:构造方法不能递归使用\n(3)递归的案例：\n    A:递归求阶乘\n        public static int method(int i) {\n            while (i &gt; 1) {\n                return i * method(--i);\n            }\n            return 1;\n        }\n    B:兔子问题\n    C:递归输出指定目录下所有指定后缀名的文件绝对路径\n        public static void method(File filePath, String suffix) {\n            File[] files = filePath.listFiles();\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    method(file, suffix);\n                } else if (file.getName().endsWith(suffix)){\n                    System.out.println(file.getName());\n                }\n            }\n        }\n    D:递归删除带内容的目录(小心使用)\n        public static void method(File filePath) {\n            File[] files = filePath.listFiles();\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    method(file);\n                } else {\n                    file.delete();\n                }\n            }\n            filePath.delete();\n        }</code></pre><h2 id=\"2-IO流-掌握\"><a href=\"#2-IO流-掌握\" class=\"headerlink\" title=\"2. IO流(掌握)\"></a>2. IO流(掌握)</h2><pre><code>(1)IO用于在设备间进行数据传输的操作    \n(2)分类：\n    A:流向\n        输入流    读取数据\n        输出流    写出数据\n    B:数据类型\n        字节流    \n                字节输入流\n                字节输出流\n        字符流\n                字符输入流\n                字符输出流\n    注意：\n        a:如果我们没有明确说明按照什么分，默认按照数据类型分。\n        b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。\n(3)FileOutputStream写出数据\n    A:操作步骤\n        a:创建字节输出流对象\n        b:调用write()方法\n        c:释放资源\n\n    B:代码体现：\n        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);\n\n        fos.write(&quot;hello&quot;.getBytes());\n\n        fos.close();\n\n    C:要注意的问题?\n        a:创建字节输出流对象做了几件事情?\n            调用系统功能去创建文件\n            创建fos对象\n            把fos对象指向这个文件\n        b:为什么要close()?\n            关闭此文件输出流并释放与此流有关的所有系统资源。\n        c:如何实现数据的换行?\n            windows:\\r\\n\n            linux:\\n\n            Mac:\\r\n        d:如何实现数据的追加写入?\n            FileOutputStream fos = new FileOutputStream(&quot;F:\\\\&quot;, true);\n(4)FileInputStream读取数据\n    A:操作步骤\n        a:创建字节输入流对象\n        b:调用read()方法\n        c:释放资源\n\n    B:代码体现：\n        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);\n\n        //方式1\n        int by = 0;\n        while((by=fis.read())!=-1) {\n            System.out.print((char)by);\n        }\n\n        //方式2\n        byte[] bys = new byte[1024];\n        int len = 0;\n        while((len=fis.read(bys))!=-1) {\n            System.out.print(new String(bys,0,len));\n        }\n\n        fis.close();\n(5)案例：2种实现\n    A:复制文本文件\n        FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;);\n        //方式一\n        int i = 0;\n        while ((i = fis.read()) != -1) {\n            fos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式二\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    B:复制图片\n        FileInputStream fis = new FileInputStream(&quot;a.jpg&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;b.jpg&quot;);\n        //方式一\n        int i = 0;\n        while ((i = fis.read()) != -1) {\n            fos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式二\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    C:复制视频\n        FileInputStream fis = new FileInputStream(&quot;a.mp4&quot;);\n        FileOutputStream fos = new FileOutputStream(&quot;b.mp4&quot;);\n        //方式一\n        int i = 0;\n        while ((i = fis.read()) != -1) {\n            fos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式二\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n(6)字节缓冲区流\n    A:BufferedOutputStream\n    B:BufferedInputStream\n(7)案例：4种实现\n    A:复制文本文件\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.txt&quot;));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.txt&quot;));\n\n        //方式三\n        int i = 0;\n        while ((i = bis.read()) != -1) {\n            bos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式四\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    B:复制图片\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.jpg&quot;));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.jpg&quot;));\n\n        //方式三\n        int i = 0;\n        while ((i = bis.read()) != -1) {\n            bos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式四\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();\n    C:复制视频\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.mp4&quot;));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.mp4&quot;));\n\n        //方式三\n        int i = 0;\n        while ((i = bis.read()) != -1) {\n            bos.write(i);\n        }\n        fis.close();\n        fos.close();\n        //方式四\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        fis.close();\n        fos.close();</code></pre><h2 id=\"3-自学字符流\"><a href=\"#3-自学字符流\" class=\"headerlink\" title=\"3. 自学字符流\"></a>3. 自学字符流</h2><pre><code>IO流分类\n    字节流：\n        InputStream\n            FileInputStream\n            BufferedInputStream\n        OutputStream\n            FileOutputStream\n            BufferedOutputStream\n\n    字符流：\n        Reader\n            FileReader\n            BufferedReader\n        Writer\n            FileWriter\n            BufferedWriter</code></pre><h2 id=\"1-字符流-掌握\"><a href=\"#1-字符流-掌握\" class=\"headerlink\" title=\"1. 字符流(掌握)\"></a>1. 字符流(掌握)</h2><pre><code>(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。\n   转换流的作用就是把字节流转换字符流来使用。\n(2)转换流其实是一个字符流\n    字符流 = 字节流 + 编码表\n(3)编码表\n    A:就是由字符和对应的数值组成的一张表\n    B:常见的编码表\n        ASCII\n        ISO-8859-1\n        GB2312\n        GBK\n        GB18030\n        UTF-8\n    C:字符串中的编码问题\n        编码\n            String -- byte[]\n        解码\n            byte[] -- String\n(4)IO流中的编码问题\n    A:OutputStreamWriter\n        OutputStreamWriter(OutputStream os):默认编码，GBK\n        OutputStreamWriter(OutputStream os,String charsetName):指定编码。\n    B:InputStreamReader\n        InputStreamReader(InputStream is):默认编码，GBK\n        InputStreamReader(InputStream is,String charsetName):指定编码\n    C:编码问题其实很简单\n        编码只要一致即可\n(5)字符流\n    Reader\n        |--InputStreamReader\n            |--FileReader\n        |--BufferedReader\n    Writer\n        |--OutputStreamWriter\n            |--FileWriter\n        |--BufferedWriter\n(6)复制文本文件(5种方式)\n    public class CopyDemo {\n    public static void main(String[] args) throws IOException {\n        File srcFile = new File(&quot;a.txt&quot;);\n        File destFile = new File(&quot;b.txt&quot;);\n\n        method1(srcFile, destFile);\n        method2(srcFile, destFile);\n        method3(srcFile, destFile);\n        method4(srcFile, destFile);\n        method5(srcFile, destFile);\n    }\n\n    private static void method5(File srcFile, File destFile) throws IOException{\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        String s = null;\n        while ((s = br.readLine()) != null) {\n            bw.write(s);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method4(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int len = 0;\n        char[] chars = new char[1024];\n        while ((len = br.read(chars)) != -1) {\n            bw.write(chars, 0, len);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method3(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int by = 0;\n        while ((by = br.read()) != -1) {\n            bw.write(by);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method2(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int len = 0;\n        char[] bytes = new char[1024];\n        while ((len = fr.read(bytes)) != -1) {\n            fw.write(bytes, 0, len);\n        }\n        fr.close();\n        fw.close();\n    }\n\n    private static void method1(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int by = 0;\n        while ((by = fr.read()) != -1) {\n            fw.write(by);\n        }\n        fr.close();\n        fw.close();\n    }\n}                                                </code></pre><h2 id=\"2-IO流小结-掌握\"><a href=\"#2-IO流小结-掌握\" class=\"headerlink\" title=\"2. IO流小结(掌握)\"></a>2. IO流小结(掌握)</h2><pre><code>IO流\n    |--字节流\n        |--字节输入流\n            InputStream\n                int read():一次读取一个字节\n                int read(byte[] bys):一次读取一个字节数组\n\n                |--FileInputStream\n                |--BufferedInputStream\n        |--字节输出流\n            OutputStream\n                void write(int by):一次写一个字节\n                void write(byte[] bys,int index,int len):一次写一个字节数组的一部分\n\n                |--FileOutputStream\n                |--BufferedOutputStream\n    |--字符流\n        |--字符输入流\n            Reader\n                int read():一次读取一个字符\n                int read(char[] chs):一次读取一个字符数组\n\n                |--InputStreamReader\n                    |--FileReader\n                |--BufferedReader\n                    String readLine():一次读取一个字符串\n        |--字符输出流\n            Writer\n                void write(int ch):一次写一个字符\n                void write(char[] chs,int index,int len):一次写一个字符数组的一部分\n\n                |--OutputStreamWriter\n                    |--FileWriter\n                |--BufferedWriter\n                    void newLine():写一个换行符\n\n                    void write(String line):一次写一个字符串</code></pre><h2 id=\"3-案例-理解-练习一遍\"><a href=\"#3-案例-理解-练习一遍\" class=\"headerlink\" title=\"3. 案例(理解 练习一遍)\"></a>3. 案例(理解 练习一遍)</h2><pre><code>A:复制文本文件 5种方式(掌握)\n    private static void method5(File srcFile, File destFile) throws IOException{\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        String s = null;\n        while ((s = br.readLine()) != null) {\n            bw.write(s);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method4(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int len = 0;\n        char[] chars = new char[1024];\n        while ((len = br.read(chars)) != -1) {\n            bw.write(chars, 0, len);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method3(File srcFile, File destFile) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(srcFile));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n        int by = 0;\n        while ((by = br.read()) != -1) {\n            bw.write(by);\n        }\n        br.close();\n        bw.close();\n    }\n\n    private static void method2(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int len = 0;\n        char[] bytes = new char[1024];\n        while ((len = fr.read(bytes)) != -1) {\n            fw.write(bytes, 0, len);\n        }\n        fr.close();\n        fw.close();\n    }\n\n    private static void method1(File srcFile, File destFile) throws IOException {\n        FileReader fr = new FileReader(srcFile);\n        FileWriter fw = new FileWriter(destFile);\n\n        int by = 0;\n        while ((by = fr.read()) != -1) {\n            fw.write(by);\n        }\n        fr.close();\n        fw.close();\n    }\nB:复制图片(二进制流数据) 4种方式(掌握)\n    private static void method4(File srcFile, File destFile) throws IOException{\n        BufferedInputStream bis = new BufferedInputStream(\n            new FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(\n            new FileOutputStream(destFile));\n\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = bis.read()) != -1) {\n            bos.write(bytes, 0, len);\n        }\n        bis.close();\n        bos.close();\n    }\n\n    private static void method3(File srcFile, File destFile) throws IOException{\n        BufferedInputStream bis = new BufferedInputStream(\n            new FileInputStream(srcFile));\n        BufferedOutputStream bos = new BufferedOutputStream(\n            new FileOutputStream(destFile));\n\n        int by = 0;\n        while ((by = bis.read()) != -1) {\n            bos.write(by);\n        }\n        bis.close();\n        bos.close();\n    }\n\n    private static void method2(File srcFile, File destFile) throws IOException{\n        FileInputStream fis = new FileInputStream(srcFile);\n        FileOutputStream fos = new FileOutputStream(destFile);\n\n        int len = 0;\n        byte[] bytes = new byte[1024];\n        while ((len = fis.read(bytes)) != -1) {\n            fos.write(bytes,0,len);\n        }\n        fis.close();\n        fos.close();\n    }\n\n    private static void method1(File srcFile, File destFile) throws IOException{\n        FileInputStream fis = new FileInputStream(srcFile);\n        FileOutputStream fos = new FileOutputStream(destFile);\n\n        int by = 0;\n        while ((by = fis.read()) != -1) {\n            fos.write(by);\n        }\n        fis.close();\n        fos.close();\n    }\nC:把集合中的数据存储到文本文件\n    File srcFile = new File(&quot;a.txt&quot;);\n    List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n    list.add(&quot;hello&quot;);\n    list.add(&quot;world&quot;);\n    list.add(&quot;java&quot;);\n    //方式一\n    FileOutputStream fos = new FileOutputStream(srcFile);\n    for (String s : list) {\n        fos.write((s).getBytes());\n    }\n    fos.close();\n    //方式二\n    FileWriter fw = new FileWriter(srcFile);\n    for (String s : list) {\n        fw.write(s.toCharArray());\n        fw.flush();\n    }\n    fw.close();\n    //方式三\n    BufferedWriter bw = new BufferedWriter(new FileWriter(srcFile));\n    for (String s : list) {\n        bw.write(s);\n        bw.flush();\n    }\n    bw.close();\nD:把文本文件中的数据读取到集合并遍历集合\n    File srcFile = new File(&quot;a.txt&quot;);\n    List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n\n    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n    String s = null;\n    while ((s = br.readLine()) != null) {\n        list.add(s);\n    }\n    br.close();\nE:复制单级文件夹\n    File srcPath = new File(&quot;F:\\\\struts-1.2.7&quot;);\n    File destPath = new File(&quot;F:\\\\test1&quot;);\n\n    File[] srcFiles = srcPath.listFiles();\n    BufferedInputStream bis = null;\n    BufferedOutputStream bos = null;\n    if (!destPath.exists()) {\n        destPath.mkdir();\n    }\n    for (File srcFile : srcFiles) {\n        if (srcFile.isFile()) {\n             bis = new BufferedInputStream(new FileInputStream(srcFile));\n             bos = new BufferedOutputStream(\n                 new FileOutputStream(new File(destPath,srcFile.getName())));\n            int len = 0;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n                bos.flush();\n            }\n        }\n    }\n    bis.close();\n    bos.close();\nF:复制单级文件夹中指定的文件\n    File srcPath = new File(&quot;F:\\\\test&quot;);\n    File destPath = new File(&quot;F:\\\\test1&quot;);\n\n    File[] srcFiles = srcPath.listFiles(new FilenameFilter(){\n\n        @Override\n        public boolean accept(File dir, String name) {\n            return dir.isFile()&amp;&amp;name.endsWith(&quot;.java&quot;);\n        }\n    });\n    BufferedInputStream bis = null;\n    BufferedOutputStream bos = null;\n    if (!destPath.exists()) {\n        destPath.mkdir();\n    }\n    for (File srcFile : srcFiles) {\n        if (srcFile.isFile()) {\n             bis = new BufferedInputStream(new FileInputStream(srcFile));\n             bos = new BufferedOutputStream(\n                 new FileOutputStream(new File(destPath,srcFile.getName())));\n            int len = 0;\n            byte[] bytes = new byte[1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0, len);\n                bos.flush();\n            }\n        }\n    }\n    bis.close();\n    bos.close();\nG:复制多级文件夹\n    public class CopyDemo {\n    public static void main(String[] args) throws IOException {\n        File srcPath = new File(&quot;F:\\\\test&quot;);\n        File destPath = new File(&quot;F:\\\\test1&quot;);\n\n        copyFolder(srcPath,destPath);\n\n    }\n\n    public static void copyFolder(File srcPath, File destPath) throws IOException{\n        if (!destPath.exists()) {\n            destPath.mkdir();\n        }\n        File[] files = srcPath.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n\n                copyFolder(file,new File(destPath,file.getName()));\n            } else if (file.isFile()) {\n                BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));\n                BufferedOutputStream bos = new BufferedOutputStream(\n                    new FileOutputStream(new File(destPath,file.getName())));\n                int len = 0;\n                byte[] bytes = new byte[1024];\n                while ((len = bis.read(bytes)) != -1) {\n                    bos.write(bytes,0,len);\n                    bos.flush();\n                }\n                bis.close();\n                bos.close();\n            }\n        }\n\n    }\n\n}\nH:键盘录入学生信息按照总分从高到低存储到文本文件\n    public class CopyDemo {\n        public static void main(String[] args) throws IOException {\n            Scanner sc = new Scanner(System.in);\n            //比较器返回-1降序，返回1升序\n            TreeSet&lt;Student&gt; studentList = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() {\n                @Override\n                public int compare(Student o1, Student o2) {\n                    int sum1 = o1.getChinese() + o1.getEnglish() + o1.getMath();\n                    int sum2 = o2.getChinese() + o2.getEnglish() + o2.getMath();\n                    if (sum1 &gt; sum2) {\n                        return -1;\n                    } else if (sum1 == sum2) {\n                        if (o1.getName().compareTo(o2.getName()) &gt;=0 ) {\n                            return -1;\n                        } else {\n                            return 1;\n                        }\n                    } else {\n                        return 1;\n                    }\n                }\n            });\n            for (int i = 0; i &lt; 3; i++) {\n                Student st = new Student();\n                System.out.println(&quot;请输入学生信息:&quot;);\n                System.out.println(&quot;姓名: &quot;);\n                st.setName(sc.nextLine());\n                System.out.println(&quot;语文: &quot;);\n                st.setChinese(Integer.valueOf(sc.nextLine()));\n                System.out.println(&quot;数学: &quot;);\n                st.setEnglish(Integer.valueOf(sc.nextLine()));\n                System.out.println(&quot;英语: &quot;);\n                st.setMath(Integer.valueOf(sc.nextLine()));\n                studentList.add(st);\n            }\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;a.txt&quot;)));\n            for (Student student : studentList) {\n                bw.write(&quot;name: &quot; + student.getName());\n                bw.newLine();\n                bw.write(&quot;chinese: &quot;+student.getChinese());\n                bw.newLine();\n                bw.write(&quot;english: &quot; + student.getEnglish());\n                bw.newLine();\n                bw.write(&quot;math: &quot;+student.getMath());\n                bw.newLine();\n                bw.write(&quot;---------------------&quot;);\n                bw.newLine();\n                bw.flush();\n            }\n            bw.close();\n        }\n}\n\nclass Student {\n    private String name;\n    private int chinese;\n    private int math;\n    private int english;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getChinese() {\n        return chinese;\n    }\n\n    public void setChinese(int chinese) {\n        this.chinese = chinese;\n    }\n\n    public int getMath() {\n        return math;\n    }\n\n    public void setMath(int math) {\n        this.math = math;\n    }\n\n    public int getEnglish() {\n        return english;\n    }\n\n    public void setEnglish(int english) {\n        this.english = english;\n    }\n}\nI:把某个文件中的字符串排序后输出到另一个文本文件中\n    File srcFile = new File(&quot;a.txt&quot;);\n    File destFile = new File(&quot;b.txt&quot;);\n\n    BufferedReader br = new BufferedReader(new FileReader(srcFile));\n    BufferedWriter bw = new BufferedWriter(new FileWriter(destFile));\n\n    StringBuilder sb = new StringBuilder();\n    String s = null;\n    while ((s = br.readLine()) != null) {\n        sb.append(s);\n    }\n    char[] ch = sb.toString().toCharArray();\n    Arrays.sort(ch);\n    bw.write(ch);\n    bw.close();\n    br.close();\nJ:用Reader模拟BufferedReader的特有功能\nK:模拟LineNumberReader的特有功能</code></pre><h1 id=\"Java多线程\"><a href=\"#Java多线程\" class=\"headerlink\" title=\"Java多线程\"></a>Java多线程</h1><h2 id=\"1-多线程-理解\"><a href=\"#1-多线程-理解\" class=\"headerlink\" title=\"1. 多线程(理解)\"></a>1. 多线程(理解)</h2><pre><code>(1)多线程：一个应用程序有多条执行路径\n    进程：正在执行的应用程序\n    线程：进程的执行单元，执行路径\n    单线程：一个应用程序只有一条执行路径\n    多线程：一个应用程序有多条执行路径\n\n    多进程的意义?\n        提高CPU的使用率\n    多线程的意义?\n        提高应用程序的使用率\n(2)Java程序的运行原理及JVM的启动是多线程的吗?\n    A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。\n    B:JVM的启动是多线程的，因为它至少有两个线程启动了，主线程和垃圾回收线程。\n(3)多线程的实现方案(自己补齐步骤及代码    掌握)\n    A:继承Thread类\n    public class MyThread extends Thread {\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(getName() + &quot;:&quot; + i);\n            }\n        }\n\n        public static class MyThreadTest {\n            public static void main(String[] args) {\n                MyThread mt = new MyThread();\n                mt.start();\n            }\n        }\n    }\n    B:实现Runnable接口\n    public class MyRunnable implements Runnable {\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);\n            }\n        }\n\n        public static class MyRunnableTest {\n            public static void main(String[] args) {\n                MyRunnable mr = new MyRunnable();\n                Thread td = new Thread(mr);\n\n                td.start();\n            }\n        }\n    }\n(4)线程的调度和优先级问题\n    A:线程的调度\n        a:分时调度\n        b:抢占式调度 (Java采用的是该调度方式)\n    B:获取和设置线程优先级\n        a:默认是5\n        b:范围是1-10（Thread.MIN_PRIORITY，Thread.MAX_PRIORITY）\n(5)线程的控制(常见方法)\n    A:休眠线程：sleep()\n    B:加入线程：join()\n    C:礼让线程：yield()\n    D:后台线程：setDaemon()\n    E:终止线程(掌握)：interrupt()\n(6)线程的生命周期(参照    线程生命周期图解.bmp)\n    A:新建\n    B:就绪\n    C:运行\n    D:阻塞\n    E:死亡</code></pre><p><img src=\"https://img-blog.csdn.net/20181003115703845?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA1MzM2MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"线程生命周期图解\"></p>\n<pre><code>(7)电影院卖票程序的实现\n    A:继承Thread类\n    public class ThreadTicket extends Thread {\n        private static int ticket = 100;\n\n        @Override\n        public void run() {\n           while (true) {\n                if (ticket &gt; 0) {\n                    System.out.println(getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);\n                }\n            }\n        }\n\n        public static class ThreadTicketTest {\n            public static void main(String[] args) {\n                ThreadTicket threadTicket = new ThreadTicket();\n                ThreadTicket threadTicket1 = new ThreadTicket();\n                ThreadTicket threadTicket2 = new ThreadTicket();\n\n                threadTicket.start();\n                threadTicket1.start();\n                threadTicket2.start();\n            }\n        }\n    }\n    B:实现Runnable接口\n    public class RunnableTicket implements Runnable {\n        private int ticket = 100;\n\n        @Override\n        public void run() {\n            while (true) {\n                if (ticket &gt; 0) {\n                    System.out.println(getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);\n                }\n            }\n        }\n\n        public static class RunnableTicketTest {\n            public static void main(String[] args) {\n                RunnableTicket rt = new RunnableTicket();\n                Thread thread = new Thread(rt);\n                Thread thread1 = new Thread(rt);\n                Thread thread2 = new Thread(rt);\n\n                thread.start();\n                thread1.start();\n                thread2.start();\n            }\n        }\n    }\n(8)电影院卖票程序出问题\n    A:为了更符合真实的场景，加入了休眠100毫秒。\n    B:卖票问题\n        a:同票多次\n        b:负数票\n(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)\n    A:是否有多线程环境\n    B:是否有共享数据\n    C:是否有多条语句操作共享数据\n(10)同步解决线程安全问题\n    A:同步代码块\n        synchronized(对象) {\n            需要被同步的代码;\n        }\n\n        这里的锁对象可以是任意对象。\n\n    B:同步方法\n        把同步加在方法上。\n\n        这里的锁对象是this\n\n    C:静态同步方法\n        把同步加在方法上。\n\n        这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)\n(11)回顾以前的线程安全的类\n    A:StringBuffer\n    B:Vector\n    C:Hashtable\n    D:如何把一个线程不安全的集合类变成一个线程安全的集合类\n        用Collections工具类的方法即可。\n        List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></pre><h2 id=\"1-多线程-理解-1\"><a href=\"#1-多线程-理解-1\" class=\"headerlink\" title=\"1. 多线程(理解)\"></a>1. 多线程(理解)</h2><pre><code>(1)JDK5以后的针对线程的锁定操作和释放操作\n    Lock锁\n    public class RunnableTicket implements Runnable {\n        private int ticket = 100;\n        private ReentrantLock lock = new ReentrantLock();\n\n        @Override\n        public void run() {\n            while (true) {\n                lock.lock();\n                if (ticket &gt; 0) {\n                System.out.println(Thread.currentThread().getName() + &quot;正在售出第&quot; + ticket-- + &quot;张票&quot;);\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                lock.unlock();\n            }\n        }\n\n        public static class RunnableTicketTest {\n            public static void main(String[] args) {\n                RunnableTicket rt = new RunnableTicket();\n                Thread thread = new Thread(rt);\n                Thread thread1 = new Thread(rt);\n                Thread thread2 = new Thread(rt);\n\n                thread.start();\n                thread1.start();\n                thread2.start();\n            }\n        }\n    }\n(2)死锁问题的描述和代码体现\npublic class DeadLockDemo implements Runnable {\n        boolean flag;\n\n        @Override\n        public void run() {\n            if (flag) {\n                synchronized (Lock.object1) {\n                    System.out.println(Thread.currentThread().getName() + &quot;获取了锁object1&quot;);\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (Lock.object2) {\n                        System.out.println(Thread.currentThread().getName() + &quot;获取了锁object2&quot;);\n                    }\n                }\n            } else {\n                synchronized (Lock.object2) {\n                    System.out.println(Thread.currentThread().getName() + &quot;获取了锁object2&quot;);\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    synchronized (Lock.object1) {\n                        System.out.println(Thread.currentThread().getName() + &quot;获取了锁object1&quot;);\n                    }\n                }\n            }\n        }\n\n        public static void main(String[] args) {\n            DeadLockDemo lockDemo = new DeadLockDemo();\n            DeadLockDemo lockDemo1 = new DeadLockDemo();\n            lockDemo.flag = true;\n            Thread td1 = new Thread(lockDemo);\n            Thread td2 = new Thread(lockDemo1);\n\n            td1.start();\n            td2.start();\n        }\n    }\n\n    class Lock {\n        public static Object object1 = new Object();\n        public static Object object2 = new Object();\n    }\n(3)生产者和消费者多线程体现(线程间通信问题)\n    以学生作为资源来实现的\n\n    资源类：Student\n    设置数据类：SetThread(生产者)\n    获取数据类：GetThread(消费者)\n    测试类：StudentDemo\n\n    代码：\n        A:最基本的版本，只有一个数据。\n\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    SetThread st = new SetThread(student);\n                    GetThread gt = new GetThread(student);\n\n                    new Thread(st).start();\n                    new Thread(gt).start();\n                }\n            }\n\n            class Student {\n                String name;\n                int age;\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    student.name = &quot;xmos&quot;;\n                    student.age = 23;\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        System.out.println(student.name + &quot;:&quot; + student.age);\n                    }\n                }\n            }\n        B:改进版本，给出了不同的数据，并加入了同步机制\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    GetThread gt = new GetThread(student);\n                    SetThread st = new SetThread(student);\n\n                    new Thread(gt).start();\n                    new Thread(st).start();\n                }\n            }\n\n            class Student {\n                String name;\n                int age;\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n                private int x;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    while (true) {\n                        synchronized (student) {\n                            if (x % 2 == 0) {\n                                student.name = &quot;xmos&quot;;\n                                student.age = 23;\n                            } else {\n                                student.name = &quot;tmos&quot;;\n                                student.age = 22;\n                            }\n\n                            x++;\n                        }\n                    }\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        synchronized (student) {\n                            System.out.println(student.name + &quot;:&quot; + student.age);\n                        }\n\n                    }\n                }\n            }\n        C:等待唤醒机制改进该程序，让数据能够实现依次的出现\n            wait()\n            notify()\n            notifyAll() (多生产多消费)\n\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    GetThread gt = new GetThread(student);\n                    SetThread st = new SetThread(student);\n\n                    new Thread(gt).start();\n                    new Thread(st).start();\n                }\n            }\n\n            class Student {\n                String name;\n                int age;\n                boolean flag;\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n                private int x;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    while (true) {\n                        synchronized (student) {\n                            if (student.flag) {\n                                try {\n                                    student.wait();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                            }\n                            if (x % 2 == 0) {\n                                student.name = &quot;xmos&quot;;\n                                student.age = 23;\n                            } else {\n                                student.name = &quot;tmos&quot;;\n                                student.age = 22;\n                            }\n                            x++;\n                            student.flag = true;\n                            student.notify();\n                        }\n                    }\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        synchronized (student) {\n                            if (!student.flag) {\n                                try {\n                                    student.wait();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                            }\n                            System.out.println(student.name + &quot;:&quot; + student.age);\n                            student.flag = false;\n                            student.notify();\n                        }\n                    }\n                }\n            }\n        D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中\n            public class ThreadDemo {\n                public static void main(String[] args) {\n                    Student student = new Student();\n                    GetThread gt = new GetThread(student);\n                    SetThread st = new SetThread(student);\n\n                    new Thread(gt).start();\n                    new Thread(st).start();\n                }\n            }\n\n            class Student {\n                private String name;\n                private int age;\n                private int x;\n                private boolean flag;\n\n                synchronized void setStudent() {\n                    while (true) {\n                        if (flag) {\n                            try {\n                                wait();\n                            } catch (InterruptedException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        if (x % 2 == 0) {\n                            name = &quot;xmos&quot;;\n                            age = 23;\n                        } else {\n                            name = &quot;tmos&quot;;\n                            age = 22;\n                        }\n                        x++;\n                        flag = true;\n                        notify();\n                    }\n                }\n\n                synchronized void getStudent() {\n                    for (int i = 0; i &lt; 100; i++) {\n                        if (!flag) {\n                            try {\n                                wait();\n                            } catch (InterruptedException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        System.out.println(name + &quot;:&quot; + age);\n                        flag = false;\n                        notify();\n                    }\n                }\n            }\n\n            class SetThread implements Runnable {\n                private Student student;\n\n                public SetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    student.setStudent();\n                }\n            }\n\n            class GetThread implements Runnable {\n                private Student student;\n\n                public GetThread(Student student) {\n                    this.student = student;\n                }\n\n                @Override\n                public void run() {\n                    student.getStudent();\n                }\n            }\n(4)线程组\n    public class ThreadGroupDemo {\n       public static void main(String[] args) {\n            ThreadGroup tg = new ThreadGroup(&quot;MyThreadGroup&quot;);\n            MyRunnable mr = new MyRunnable();\n            Thread th1 = new Thread(tg, mr, &quot;xmos&quot;);\n            Thread th2 = new Thread(tg, mr, &quot;tmos&quot;);\n\n            th1.start();\n            th2.start();\n\n        }\n    }\n\n    class MyRunnable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(Thread.currentThread().getThreadGroup().getName() + &quot;:&quot; \n                + Thread.currentThread().getName());\n        }\n    }\n    (5)线程池\n        public class ThreadPoolDemo {\n            public static void main(String[] args) {\n                ExecutorService pool = Executors.newFixedThreadPool(3);\n                MyRunnable mr = new MyRunnable();\n                pool.submit(mr);\n                pool.submit(mr);\n\n                pool.shutdown();\n            }\n        }\n\n        class MyRunnable implements Runnable{\n\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        }\n(6)多线程实现的第三种方案\n    public class ThreadPoolDemo {\n        public static void main(String[] args) {\n            ExecutorService pool = Executors.newFixedThreadPool(3);\n            MyCallable mc = new MyCallable();\n            pool.submit(mc);\n            pool.submit(mc);\n\n            pool.shutdown();\n        }\n    }\n\n    class MyCallable implements Callable {\n        @Override\n        public Object call() throws Exception {\n            System.out.println(Thread.currentThread().getName());\n            return null;\n        }\n    }\n(7)定时器\n    案例1：\n        public class TimerDemo {\n            public static void main(String[] args) throws ParseException {\n                Timer t = new Timer();\n                String s = new String(&quot;2018-10-03 12:46:00&quot;);\n                SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n                Date date = sdf.parse(s);\n                t.schedule(new Boom(), date, 100);\n\n                t.cancel();</code></pre><p>​<br>                }<br>            }</p>\n<pre><code>    class Boom extends TimerTask {\n\n        @Override\n        public void run() {\n            System.out.println(&quot;Boom!&quot;);\n        }\n    }\n    案例2：\n        public class TimerDemo {\n            public static void main(String[] args) throws ParseException {\n                Timer t = new Timer();\n                t.schedule(new Boom(t), 300, 100);\n            }\n        }\n\n        class Boom extends TimerTask {\n            private Timer t;\n            int i = 0;\n\n            public Boom(Timer t) {\n                this.t = t;\n            }\n\n            @Override\n            public void run() {\n                System.out.println(&quot;Boom---&quot; + ++i);\n\n                if (i == 30) {\n                    t.cancel();\n                }\n            }\n        }\n(8)多线程的面试题\n    ## 1. 多线程有几种实现方案，分别是哪几种?\n    两种。\n\n    继承Thread类\n    实现Runnable接口\n\n    扩展一种：实现Callable接口。这个得和线程池结合。\n\n    ## 2. 同步有几种方式，分别是什么?\n        两种。\n\n        同步代码块\n        同步方法\n\n    ## 3. 启动一个线程是run()还是start()?它们的区别?\n        start();\n\n        run():封装了被线程执行的代码,直接调用仅仅是普通方法的调用\n        start():启动线程，并由JVM自动调用run()方法\n\n    ## 4. sleep()和wait()方法的区别\n        sleep():必须指时间;不释放锁。\n        wait():可以不指定时间，也可以指定时间;释放锁。\n\n    ## 5. 为什么wait(),notify(),notifyAll()等方法都定义在Object类中\n        因为这些方法的调用是依赖于锁对象的，而同步代码块的锁对象是任意锁。\n        而Object代码任意的对象，所以，定义在这里面。\n\n    ## 6. 线程的生命周期图\n        新建 -- 就绪 -- 运行 -- 死亡\n        新建 -- 就绪 -- 运行 -- 阻塞 -- 就绪 -- 运行 -- 死亡\n        建议：画图解释。</code></pre><h2 id=\"2-设计模式-理解\"><a href=\"#2-设计模式-理解\" class=\"headerlink\" title=\"2. 设计模式(理解)\"></a>2. 设计模式(理解)</h2><pre><code>(1)面试对象的常见设计原则\n    单一\n    开闭\n    里氏\n    依赖注入\n    接口\n    迪米特\n(2)设计模式概述和分类\n    A:经验的总结\n    B:三类\n        创建型\n        结构型\n        行为型\n(3)改进的设计模式\n    A:简单工厂模式（Simple Factory Pattern）\n        public abstract class Animal {\n            public abstract void eat();\n\n            public static Animal getDog() {\n                return new Dog();\n            }\n\n            public static Animal getCat() {\n                return new Cat();\n            }\n\n            public static void main(String[] args) {\n                Animal dog = Animal.getDog();\n                Animal cat = Animal.getCat();\n\n                dog.eat();\n                cat.eat();\n            }\n        }\n\n        class Dog extends Animal{\n\n            @Override\n            public void eat(){\n                System.out.println(&quot;eat bone&quot;);\n            }\n        }\n\n        class Cat extends Animal{\n\n            @Override\n            public void eat() {\n                System.out.println(&quot;eat fish&quot;);\n            }\n        }\n    B:工厂方法模式（Factory Method Pattern）\n        public abstract class Animal {\n            public abstract void eat();\n\n            public static Animal getDog() {\n                return new Dog();\n            }\n\n            public static Animal getCat() {\n                return new Cat();\n            }\n\n            public static void main(String[] args) {\n                Animal dog = new DogFactory().getAnimal();\n                Animal cat = new CatFactory().getAnimal();\n\n                dog.eat();\n                cat.eat();\n            }\n        }\n\n        interface AnimalFactory {\n            Animal getAnimal();\n        }\n\n        class DogFactory implements AnimalFactory {\n\n            @Override\n            public Animal getAnimal() {\n                return new Dog();\n            }\n        }\n\n        class CatFactory implements AnimalFactory {\n\n            @Override\n            public Animal getAnimal() {\n                return new Cat();\n            }\n        }\n\n        class Dog extends Animal {\n\n            @Override\n            public void eat() {\n                System.out.println(&quot;eat bone&quot;);\n            }\n        }\n\n        class Cat extends Animal {\n\n            @Override\n            public void eat() {\n                System.out.println(&quot;eat fish&quot;);\n            }\n        }\n    C:单例模式(Singleton Pattern掌握)\n        a:饿汉式（开发常用）\n            public class TeacherDemo {\n                public static void main(String[] args) {\n                    Teacher t1 = Teacher.getTeacher();\n                    Teacher t2 = Teacher.getTeacher();\n\n                    System.out.println(t1 == t2);\n                }\n            }\n\n            class Teacher {\n                private static Teacher teacher = new Teacher();\n\n                private Teacher() {\n                }\n\n                public static Teacher getTeacher() {\n                    return teacher;\n                }\n            }\n        b:懒汉式（面试常用，容易有线程安全问题，需要线程同步）\n            public class StudentDemo {\n                public static void main(String[] args) {\n                    Student s1 = Student.getStudent();\n                    Student s2 = Student.getStudent();\n\n                    System.out.println(s1 == s2);\n                }\n            }\n\n            class Student {\n                private static Student student = null;\n\n                private Student() {\n                }\n\n                public synchronized static Student getStudent() {\n                    if (Objects.isNull(student)) {\n                        student = new Student();\n                    }\n                    return student;\n                }\n            }\n(4)Runtime\n    JDK提供的一个单例模式应用的类。\n    还可以调用系统命令。\n    public class RuntimeDemo {\n        public static void main(String[] args) throws IOException {\n            Runtime r = Runtime.getRuntime();\n            r.exec(&quot;touch 1.txt&quot;);\n        }\n    }</code></pre><h1 id=\"JavaGUI\"><a href=\"#JavaGUI\" class=\"headerlink\" title=\"JavaGUI\"></a>JavaGUI</h1><h1 id=\"Java网络编程\"><a href=\"#Java网络编程\" class=\"headerlink\" title=\"Java网络编程\"></a>Java网络编程</h1><h2 id=\"1-网络编程-理解\"><a href=\"#1-网络编程-理解\" class=\"headerlink\" title=\"1. 网络编程(理解)\"></a>1. 网络编程(理解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)网络编程：用Java语言实现计算机间数据的信息传递和资源共享</span><br><span class=\"line\">(<span class=\"number\">2</span>)网络编程模型</span><br><span class=\"line\">\t应用层-表示层-会话层-传输层-网络层-数据链路层-物理层</span><br><span class=\"line\">(<span class=\"number\">3</span>)网络编程的三要素</span><br><span class=\"line\">\tA:IP地址</span><br><span class=\"line\">\t\ta:点分十进制：<span class=\"number\">192.168</span>.1.1</span><br><span class=\"line\">\t\tb:IP地址的组成：网络号段+主机号段</span><br><span class=\"line\">\t\tc:IP地址的分类：</span><br><span class=\"line\">\t\t\tA类\t<span class=\"number\">1.0</span>.0.1---<span class=\"number\">127.255</span>.255.254\t</span><br><span class=\"line\">\t\t\t\t(<span class=\"number\">1</span>)<span class=\"number\">10</span>.X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t(<span class=\"number\">2</span>)<span class=\"number\">127</span>.X.X.X是保留地址，用做循环测试用的。</span><br><span class=\"line\">\t\t\tB类\t<span class=\"number\">128.0</span>.0.1---<span class=\"number\">191.255</span>.255.254\t<span class=\"number\">172.16</span>.0.0---<span class=\"number\">172.31</span>.255.255是私有地址。<span class=\"number\">169.254</span>.X.X是保留地址。</span><br><span class=\"line\">\t\t\tC类\t<span class=\"number\">192.0</span>.0.1---<span class=\"number\">223.255</span>.255.254\t<span class=\"number\">192.168</span>.X.X是私有地址</span><br><span class=\"line\">\t\t\tD类\t<span class=\"number\">224.0</span>.0.1---<span class=\"number\">239.255</span>.255.254 \t</span><br><span class=\"line\">\t\t\tE类\t<span class=\"number\">240.0</span>.0.1---<span class=\"number\">247.255</span>.255.254</span><br><span class=\"line\">\t\td:dos命令</span><br><span class=\"line\">\t\t\tipconfig; telnet; ping</span><br><span class=\"line\">\t\te:InetAddress</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IPDemo</span> </span>&#123;</span><br><span class=\"line\">\t\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> UnknownHostException </span>&#123;</span><br><span class=\"line\">\t\t\t        InetAddress ip = InetAddress.getByName(<span class=\"string\">\"192.168.2.203\"</span>);</span><br><span class=\"line\">\t\t\t        System.out.println(ip.getHostName() + <span class=\"string\">\":\"</span> + ip.getHostAddress());</span><br><span class=\"line\">\t\t\t    &#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\tB:端口</span><br><span class=\"line\">\t\t是应用程序的标识。范围：<span class=\"number\">0</span>-<span class=\"number\">65535</span>。其中<span class=\"number\">0</span>-<span class=\"number\">1024</span>不建议使用。</span><br><span class=\"line\">\tC:协议</span><br><span class=\"line\">\t\tUDP:数据打包,有限制,不连接,效率高,不可靠</span><br><span class=\"line\">\t\tTCP:建立数据通道,无限制,效率低,可靠</span><br><span class=\"line\">(<span class=\"number\">3</span>)Socket机制</span><br><span class=\"line\">\tA:通信两端都应该有Socket对象</span><br><span class=\"line\">\tB:所有的通信都是通过Socket间的IO进行操作的</span><br><span class=\"line\">(<span class=\"number\">4</span>)UDP协议发送和接收数据(掌握 自己补齐代码)</span><br><span class=\"line\">\t发送：</span><br><span class=\"line\">\t\t创建UDP发送端的Socket对象</span><br><span class=\"line\">\t\t创建数据并把数据打包</span><br><span class=\"line\">\t\t发送数据</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">\t接收：</span><br><span class=\"line\">\t\t创建UDP接收端的Socket对象</span><br><span class=\"line\">\t\t创建数据包用于接收数据</span><br><span class=\"line\">\t\t接收数据</span><br><span class=\"line\">\t\t解析数据包</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">(<span class=\"number\">5</span>)TCP协议发送和接收数据(掌握 自己补齐代码)</span><br><span class=\"line\">\t发送：</span><br><span class=\"line\">\t\t创建TCP客户端的Socket对象</span><br><span class=\"line\">\t\t获取输出流，写数据</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t接收：</span><br><span class=\"line\">\t\t创建TCP服务器端的Socket对象</span><br><span class=\"line\">\t\t监听客户端连接</span><br><span class=\"line\">\t\t获取输入流，读取数据</span><br><span class=\"line\">\t\t释放资源</span><br><span class=\"line\">(<span class=\"number\">6</span>)案例：</span><br><span class=\"line\">\tA:UDP</span><br><span class=\"line\">\t\ta:最基本的UDP协议发送和接收数据</span><br><span class=\"line\">\t\tb:把发送数据改进为键盘录入</span><br><span class=\"line\">\t\t发送端：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SendSocket</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        <span class=\"comment\">//设置socket发送的端口号，不设置的则为随机端口号</span></span><br><span class=\"line\">\t\t        DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12307</span>);</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span> (Objects.equals(s, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">byte</span>[] bytes = s.getBytes();</span><br><span class=\"line\">\t\t            DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(</span><br><span class=\"line\">\t\t            \tbytes, bytes.length, InetAddress.getByName(<span class=\"string\">\"192.168.2.203\"</span>), <span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t            ds.send(dp);</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t        ds.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t接收端：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReceiveSocket</span> </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t\t\t\t        <span class=\"comment\">//设置socket接收的端口号</span></span><br><span class=\"line\">\t\t\t\t\t        DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t\t\t\t        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t            <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t\t\t\t            DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class=\"line\">\t\t\t\t\t            ds.receive(dp);</span><br><span class=\"line\">\t\t\t\t\t            String s = <span class=\"keyword\">new</span> String(dp.getData(), <span class=\"number\">0</span>, dp.getLength());</span><br><span class=\"line\">\t\t\t\t\t            System.out.println(dp.getAddress().getHostAddress() + <span class=\"string\">\":\"</span> + dp.getPort() + <span class=\"string\">\"\\n\"</span> + s);</span><br><span class=\"line\">\t\t\t\t\t        &#125;</span><br><span class=\"line\">\t\t\t\t\t</span><br><span class=\"line\">\t\t\t\t\t    &#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\tc:一个简易聊天小程序并用多线程改进</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChatRoom</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t        Thread sendThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t\t            <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t                    DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12307</span>);</span><br><span class=\"line\">\t\t                    BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t                    String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t                    <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t                        <span class=\"keyword\">if</span> (Objects.equals(s, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t                        &#125;</span><br><span class=\"line\">\t\t                        <span class=\"keyword\">byte</span>[] bytes = s.getBytes();</span><br><span class=\"line\">\t\t                        DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(</span><br><span class=\"line\">\t\t                        \tbytes, bytes.length, InetAddress.getByName(<span class=\"string\">\"192.168.2.203\"</span>), <span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t                        ds.send(dp);</span><br><span class=\"line\">\t\t                    &#125;</span><br><span class=\"line\">\t\t                    ds.close();</span><br><span class=\"line\">\t\t                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t                    e.printStackTrace();</span><br><span class=\"line\">\t\t                &#125;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t        &#125;);</span><br><span class=\"line\">\t\t        Thread receiveThread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">\t\t            <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t                    DatagramSocket ds = <span class=\"keyword\">new</span> DatagramSocket(<span class=\"number\">12306</span>);</span><br><span class=\"line\">\t\t                    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">\t\t                        <span class=\"keyword\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t                        DatagramPacket dp = <span class=\"keyword\">new</span> DatagramPacket(bytes, bytes.length);</span><br><span class=\"line\">\t\t                        ds.receive(dp);</span><br><span class=\"line\">\t\t                        String s = <span class=\"keyword\">new</span> String(dp.getData(), <span class=\"number\">0</span>, dp.getLength());</span><br><span class=\"line\">\t\t                        System.out.println(dp.getAddress().getHostAddress() + <span class=\"string\">\":\"</span> + dp.getPort() + <span class=\"string\">\"\\n\"</span> + s);</span><br><span class=\"line\">\t\t                    &#125;</span><br><span class=\"line\">\t\t                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t                    e.printStackTrace();</span><br><span class=\"line\">\t\t                &#125;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t        &#125;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        sendThread.start();</span><br><span class=\"line\">\t\t        receiveThread.start();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\tB:TCP</span><br><span class=\"line\">\t\ta:最基本的TCP协议发送和接收数据</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>, <span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t        </span><br><span class=\"line\">\t\t        bw.write(<span class=\"string\">\"hello tcp\"</span>);</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = server.accept();</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        System.out.println(br.readLine());</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tb:服务器给出反馈</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>, <span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.write(<span class=\"string\">\"hello tcp\"</span>);</span><br><span class=\"line\">\t\t        bw.flush();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        <span class=\"comment\">//给服务端发送停止写入的信号，否则服务端会一直阻塞</span></span><br><span class=\"line\">\t\t        client.shutdownOutput();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\">\t\t        System.out.println(br.readLine());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        client.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = server.accept();</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        System.out.println(br.readLine());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class=\"line\">\t\t        bw.write(<span class=\"string\">\"已收到\"</span>);</span><br><span class=\"line\">\t\t        bw.flush();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        server.close();</span><br><span class=\"line\">\t\t        server.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tc:客户端键盘录入服务器控制台输出</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>, <span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span> (Objects.equals(s, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t            bw.write(s);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        <span class=\"comment\">//给服务端发送停止写入的信号，否则服务端会一直阻塞</span></span><br><span class=\"line\">\t\t        client.shutdownOutput();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        client.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = server.accept();</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String client = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((client = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            System.out.println(client);</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        s.close();</span><br><span class=\"line\">\t\t        server.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\td:客户端键盘录入服务器写到文本文件</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"192.168.2.203\"</span>,<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((msg = br.readLine()) != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\t            <span class=\"keyword\">if</span> (Objects.equals(msg, <span class=\"string\">\"bye\"</span>)) &#123;</span><br><span class=\"line\">\t\t                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t            &#125;</span><br><span class=\"line\">\t\t            bw.write(msg);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        s.shutdownOutput();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedReader br1 = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t        System.out.println(br1.readLine());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        br1.close();</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        s.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        ServerSocket ss = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8809</span>);</span><br><span class=\"line\">\t\t        Socket s = ss.accept();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"test.txt\"</span>));</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((msg = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            bw.write(msg);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedWriter bw1 = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(s.getOutputStream()));</span><br><span class=\"line\">\t\t        bw1.write(<span class=\"string\">\"已全部接收！\"</span>);</span><br><span class=\"line\">\t\t        bw1.newLine();</span><br><span class=\"line\">\t\t        bw1.flush();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        bw1.close();</span><br><span class=\"line\">\t\t        s.close();</span><br><span class=\"line\">\t\t        ss.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\te:客户端读取文本文件服务器控制台输出</span><br><span class=\"line\">\t\tclient：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">\t\t    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t        Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"localhost\"</span>, <span class=\"number\">8808</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"1.txt\"</span>)));</span><br><span class=\"line\">\t\t        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        String s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t        <span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t            bw.write(s);</span><br><span class=\"line\">\t\t            bw.newLine();</span><br><span class=\"line\">\t\t            bw.flush();</span><br><span class=\"line\">\t\t        &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t        bw.close();</span><br><span class=\"line\">\t\t        br.close();</span><br><span class=\"line\">\t\t        client.close();</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tserver：</span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t\t\tServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8808</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tSocket client = server.accept();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tBufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t\tString s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> ((s = br.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(s);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tf:客户端读取文本文件服务器写到文本文件</span><br><span class=\"line\">\t\tg:上传图片</span><br><span class=\"line\">\t\th:多线程改进上传文件</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Java反射\"><a href=\"#Java反射\" class=\"headerlink\" title=\"Java反射\"></a>Java反射</h1><h2 id=\"1-反射-理解\"><a href=\"#1-反射-理解\" class=\"headerlink\" title=\"1. 反射(理解)\"></a>1. 反射(理解)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)类的加载及类加载器</span><br><span class=\"line\">(<span class=\"number\">2</span>)反射：</span><br><span class=\"line\">\t通过字节码文件对象，去使用成员变量，构造方法，成员方法</span><br><span class=\"line\">(<span class=\"number\">3</span>)反射的使用</span><br><span class=\"line\">\tA:通过反射获取构造方法并使用</span><br><span class=\"line\">\tB:通过反射获取成员变量并使用</span><br><span class=\"line\">\tC:通过反射获取成员方法并使用</span><br><span class=\"line\">(<span class=\"number\">4</span>)反射案例</span><br><span class=\"line\">\tA:通过反射运行配置文件的内容</span><br><span class=\"line\">\tB:通过反射越过泛型检查</span><br><span class=\"line\">\tC:通过反射给任意的一个对象的任意的属性赋值为指定的值</span><br><span class=\"line\">(<span class=\"number\">5</span>)动态代理</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-设计模式\"><a href=\"#2-设计模式\" class=\"headerlink\" title=\"2. 设计模式\"></a>2. 设计模式</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)装饰设计模式</span><br><span class=\"line\">\tBufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tScanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">(<span class=\"number\">2</span>)模版设计模式</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-JDK新特性\"><a href=\"#3-JDK新特性\" class=\"headerlink\" title=\"3. JDK新特性\"></a>3. JDK新特性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>)JDK5(掌握)</span><br><span class=\"line\">\t装箱和拆箱</span><br><span class=\"line\">\t泛型</span><br><span class=\"line\">\t增强<span class=\"keyword\">for</span></span><br><span class=\"line\">\t静态导入</span><br><span class=\"line\">\t可变参数</span><br><span class=\"line\">\t枚举</span><br><span class=\"line\">(<span class=\"number\">2</span>)JDK6(了解)</span><br><span class=\"line\">(<span class=\"number\">3</span>)JDK7(理解)</span><br><span class=\"line\">\t二进制的表现形式</span><br><span class=\"line\">\t用_分隔数据</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>语句可是用字符串</span><br><span class=\"line\">\t泛型推断(菱形泛型)</span><br><span class=\"line\">\t多<span class=\"keyword\">catch</span>的使用</span><br><span class=\"line\">\t自动释放资源的用法</span><br><span class=\"line\">(<span class=\"number\">4</span>)JDK8(了解)</span><br><span class=\"line\">\t可以去网上了解资料</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck037qbq90000liydunj55vq1","tag_id":"ck037qbqd0002liydt20s0jer","_id":"ck037qbqg0005liydnaai85a9"},{"post_id":"ck037qbqc0001liydpqm8u73i","tag_id":"ck037qbqd0002liydt20s0jer","_id":"ck037qbqh0007liydojsplde7"},{"post_id":"ck037qbqe0003liyd39wdct9b","tag_id":"ck037qbqd0002liydt20s0jer","_id":"ck037qbqh0008liydpfw6x61p"},{"post_id":"ck037qbqj0009liyd7gb1e2lg","tag_id":"ck037qbqd0002liydt20s0jer","_id":"ck037qbqk000cliydsa8wm7ue"},{"post_id":"ck037qbqk000bliydpw5f2s95","tag_id":"ck037qbql000dliyd8i8ysp8x","_id":"ck037qbql000eliydaf7rc8xn"},{"post_id":"ck037qbqm000fliyd3ehlicg9","tag_id":"ck037qbqd0002liydt20s0jer","_id":"ck037qbqn000gliydj88heirz"}],"Tag":[{"name":"学习笔记","_id":"ck037qbqd0002liydt20s0jer"},{"name":"环境搭建","_id":"ck037qbql000dliyd8i8ysp8x"}]}}